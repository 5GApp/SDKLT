/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: $
 * Copyright: (c) 2018 Broadcom. All Rights Reserved. "Broadcom" refers to 
 * Broadcom Limited and/or its subsidiaries.
 * 
 * Broadcom Switch Software License
 * 
 * This license governs the use of the accompanying Broadcom software. Your 
 * use of the software indicates your acceptance of the terms and conditions 
 * of this license. If you do not agree to the terms and conditions of this 
 * license, do not use the software.
 * 1. Definitions
 *    "Licensor" means any person or entity that distributes its Work.
 *    "Software" means the original work of authorship made available under 
 *    this license.
 *    "Work" means the Software and any additions to or derivative works of 
 *    the Software that are made available under this license.
 *    The terms "reproduce," "reproduction," "derivative works," and 
 *    "distribution" have the meaning as provided under U.S. copyright law.
 *    Works, including the Software, are "made available" under this license 
 *    by including in or with the Work either (a) a copyright notice 
 *    referencing the applicability of this license to the Work, or (b) a copy 
 *    of this license.
 * 2. Grant of Copyright License
 *    Subject to the terms and conditions of this license, each Licensor 
 *    grants to you a perpetual, worldwide, non-exclusive, and royalty-free 
 *    copyright license to reproduce, prepare derivative works of, publicly 
 *    display, publicly perform, sublicense and distribute its Work and any 
 *    resulting derivative works in any form.
 * 3. Grant of Patent License
 *    Subject to the terms and conditions of this license, each Licensor 
 *    grants to you a perpetual, worldwide, non-exclusive, and royalty-free 
 *    patent license to make, have made, use, offer to sell, sell, import, and 
 *    otherwise transfer its Work, in whole or in part. This patent license 
 *    applies only to the patent claims licensable by Licensor that would be 
 *    infringed by Licensor's Work (or portion thereof) individually and 
 *    excluding any combinations with any other materials or technology.
 *    If you institute patent litigation against any Licensor (including a 
 *    cross-claim or counterclaim in a lawsuit) to enforce any patents that 
 *    you allege are infringed by any Work, then your patent license from such 
 *    Licensor to the Work shall terminate as of the date such litigation is 
 *    filed.
 * 4. Redistribution
 *    You may reproduce or distribute the Work only if (a) you do so under 
 *    this License, (b) you include a complete copy of this License with your 
 *    distribution, and (c) you retain without modification any copyright, 
 *    patent, trademark, or attribution notices that are present in the Work.
 * 5. Derivative Works
 *    You may specify that additional or different terms apply to the use, 
 *    reproduction, and distribution of your derivative works of the Work 
 *    ("Your Terms") only if (a) Your Terms provide that the limitations of 
 *    Section 7 apply to your derivative works, and (b) you identify the 
 *    specific derivative works that are subject to Your Terms. 
 *    Notwithstanding Your Terms, this license (including the redistribution 
 *    requirements in Section 4) will continue to apply to the Work itself.
 * 6. Trademarks
 *    This license does not grant any rights to use any Licensor's or its 
 *    affiliates' names, logos, or trademarks, except as necessary to 
 *    reproduce the notices described in this license.
 * 7. Limitations
 *    Platform. The Work and any derivative works thereof may only be used, or 
 *    intended for use, with a Broadcom switch integrated circuit.
 *    No Reverse Engineering. You will not use the Work to disassemble, 
 *    reverse engineer, decompile, or attempt to ascertain the underlying 
 *    technology of a Broadcom switch integrated circuit.
 * 8. Termination
 *    If you violate any term of this license, then your rights under this 
 *    license (including the license grants of Sections 2 and 3) will 
 *    terminate immediately.
 * 9. Disclaimer of Warranty
 *    THE WORK IS PROVIDED "AS IS" WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 *    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WARRANTIES OR CONDITIONS OF 
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR 
 *    NON-INFRINGEMENT. YOU BEAR THE RISK OF UNDERTAKING ANY ACTIVITIES UNDER 
 *    THIS LICENSE. SOME STATES' CONSUMER LAWS DO NOT ALLOW EXCLUSION OF AN 
 *    IMPLIED WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO YOU.
 * 10. Limitation of Liability
 *    EXCEPT AS PROHIBITED BY APPLICABLE LAW, IN NO EVENT AND UNDER NO LEGAL 
 *    THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE 
 *    SHALL ANY LICENSOR BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY DIRECT, 
 *    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF 
 *    OR RELATED TO THIS LICENSE, THE USE OR INABILITY TO USE THE WORK 
 *    (INCLUDING BUT NOT LIMITED TO LOSS OF GOODWILL, BUSINESS INTERRUPTION, 
 *    LOST PROFITS OR DATA, COMPUTER FAILURE OR MALFUNCTION, OR ANY OTHER 
 *    COMMERCIAL DAMAGES OR LOSSES), EVEN IF THE LICENSOR HAS BEEN ADVISED OF 
 *    THE POSSIBILITY OF SUCH DAMAGES.
 */

#include <bcmdrd/bcmdrd_types.h>
#include <bcmdrd/bcmdrd_chip.h>
#include <bcmdrd/bcmdrd_field.h>
#include <bcmdrd/chip/bcm56960_a0_defs.h>

/* Block types */
const char *bcm56960_a0_blktype_names[] = {
    "avs",
    "clport",
    "cmic",
    "epipe",
    "ipipe",
    "iproc",
    "lbport",
    "mmu_glb",
    "mmu_sc",
    "mmu_xpe",
    "ser",
    "top",
    "xlport"
};

/* Block structures */
bcmdrd_block_t bcm56960_a0_blocks[] =
{
    { BLKTYPE_CLPORT,                   15,   BCMDRD_PBMP_1(0x0000001e) },
    { BLKTYPE_CLPORT,                   16,   BCMDRD_PBMP_1(0x000001e0) },
    { BLKTYPE_CLPORT,                   17,   BCMDRD_PBMP_1(0x00001e00) },
    { BLKTYPE_CLPORT,                   18,   BCMDRD_PBMP_1(0x0001e000) },
    { BLKTYPE_CLPORT,                   19,   BCMDRD_PBMP_1(0x001e0000) },
    { BLKTYPE_CLPORT,                   20,   BCMDRD_PBMP_1(0x01e00000) },
    { BLKTYPE_CLPORT,                   21,   BCMDRD_PBMP_1(0x1e000000) },
    { BLKTYPE_CLPORT,                   22,   BCMDRD_PBMP_2(0xe0000000, 0x00000001) },
    { BLKTYPE_CLPORT,                   23,   BCMDRD_PBMP_2(0x00000000, 0x0000001e) },
    { BLKTYPE_CLPORT,                   24,   BCMDRD_PBMP_2(0x00000000, 0x000001e0) },
    { BLKTYPE_CLPORT,                   25,   BCMDRD_PBMP_2(0x00000000, 0x00001e00) },
    { BLKTYPE_CLPORT,                   26,   BCMDRD_PBMP_2(0x00000000, 0x0001e000) },
    { BLKTYPE_CLPORT,                   27,   BCMDRD_PBMP_2(0x00000000, 0x001e0000) },
    { BLKTYPE_CLPORT,                   28,   BCMDRD_PBMP_2(0x00000000, 0x01e00000) },
    { BLKTYPE_CLPORT,                   29,   BCMDRD_PBMP_2(0x00000000, 0x1e000000) },
    { BLKTYPE_CLPORT,                   30,   BCMDRD_PBMP_3(0x00000000, 0xe0000000, 0x00000001) },
    { BLKTYPE_CLPORT,                   31,   BCMDRD_PBMP_3(0x00000000, 0x00000000, 0x0000001e) },
    { BLKTYPE_CLPORT,                   32,   BCMDRD_PBMP_3(0x00000000, 0x00000000, 0x000001e0) },
    { BLKTYPE_CLPORT,                   33,   BCMDRD_PBMP_3(0x00000000, 0x00000000, 0x00001e00) },
    { BLKTYPE_CLPORT,                   34,   BCMDRD_PBMP_3(0x00000000, 0x00000000, 0x0001e000) },
    { BLKTYPE_CLPORT,                   35,   BCMDRD_PBMP_3(0x00000000, 0x00000000, 0x001e0000) },
    { BLKTYPE_CLPORT,                   36,   BCMDRD_PBMP_3(0x00000000, 0x00000000, 0x01e00000) },
    { BLKTYPE_CLPORT,                   37,   BCMDRD_PBMP_3(0x00000000, 0x00000000, 0x1e000000) },
    { BLKTYPE_CLPORT,                   38,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0xe0000000, 0x00000001) },
    { BLKTYPE_CLPORT,                   39,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0x00000000, 0x0000001e) },
    { BLKTYPE_CLPORT,                   40,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0x00000000, 0x000001e0) },
    { BLKTYPE_CLPORT,                   41,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0x00000000, 0x00001e00) },
    { BLKTYPE_CLPORT,                   42,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0x00000000, 0x0001e000) },
    { BLKTYPE_CLPORT,                   43,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0x00000000, 0x001e0000) },
    { BLKTYPE_CLPORT,                   44,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0x00000000, 0x01e00000) },
    { BLKTYPE_CLPORT,                   45,   BCMDRD_PBMP_4(0x00000000, 0x00000000, 0x00000000, 0x1e000000) },
    { BLKTYPE_CLPORT,                   46,   BCMDRD_PBMP_5(0x00000000, 0x00000000, 0x00000000, 0xe0000000, 0x00000001) },
    { BLKTYPE_CLPORT,                   55,   BCMDRD_PBMP_1(0x00000000) },
    { BLKTYPE_LBPORT,                   54,   BCMDRD_PBMP_5(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010) },
    { BLKTYPE_LBPORT,                   51,   BCMDRD_PBMP_5(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000020) },
    { BLKTYPE_LBPORT,                   52,   BCMDRD_PBMP_5(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000040) },
    { BLKTYPE_LBPORT,                   53,   BCMDRD_PBMP_5(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000080) },
    { BLKTYPE_XLPORT,                   11,   BCMDRD_PBMP_5(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000000e) },
    { BLKTYPE_IPIPE,                     1,   BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000ff) },
    { BLKTYPE_EPIPE,                     2,   BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000ff) },
    { BLKTYPE_MMU_XPE,                   3,   BCMDRD_PBMP_8(0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003) },
    { BLKTYPE_MMU_SC,                    4,   BCMDRD_PBMP_8(0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003) },
    { BLKTYPE_MMU_GLB,                   5,   BCMDRD_PBMP_8(0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003) },
    { BLKTYPE_TOP,                       7,   BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000ff) },
    { BLKTYPE_SER,                       8,   BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000ff) },
    { BLKTYPE_IPROC,                    10,   BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000ff) },
    { BLKTYPE_AVS,                      59,   BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000ff) }
};

/* Symbol table */
#if BCMDRD_CONFIG_INCLUDE_CHIP_SYMBOLS == 1
extern bcmdrd_symbols_t bcm56960_a0_symbols;
#endif

/* Declare function first to prevent compiler warnings */
extern bcmdrd_port_num_domain_t
bcm56960_a0_port_num_domain(int enum_val, int blktype);

bcmdrd_port_num_domain_t
bcm56960_a0_port_num_domain(int enum_val, int blktype)
{
    switch (blktype) {
    case BLKTYPE_IPIPE:
    case BLKTYPE_EPIPE:
        return BCMDRD_PND_LOGIC;
    case BLKTYPE_MMU_GLB:
    case BLKTYPE_MMU_SC:
    case BLKTYPE_MMU_XPE:
        return BCMDRD_PND_MMU;
    default:
        break;
    }
    return BCMDRD_PND_PHYS;
}

extern uint32_t
bcm56960_a0_pipe_info(bcmdrd_pipe_info_t *pi, bcmdrd_pipe_info_type_t pi_type);

uint32_t
bcm56960_a0_pipe_info(bcmdrd_pipe_info_t *pi, bcmdrd_pipe_info_type_t pi_type)
{
    uint32_t base_type;
    int baseidx;

    /* Base types */
#define BT_IPORT        0
#define BT_EPORT        1
#define BT_IPIPE        2
#define BT_EPIPE        3
#define BT_CHIP         4
#define BT_XPE          5
#define BT_SLICE        6
#define BT_LAYER        7

    /* Access types */
#define AT_DUPLICATE    9
#define AT_SINGLE       20
#define AT_UNIQUE       31

    /* Per-pipe memory section size */
#define SECT_SHFT_32K   15

#define MMUPORT_IN_PIPE(_m, _p) \
    (((_m) >= ((_p) * 64)) && ((_m) < (((_p) * 64) + 34)))
#define MMUPORT_IN_PIPE0(_m) MMUPORT_IN_PIPE(_m, 0)
#define MMUPORT_IN_PIPE1(_m) MMUPORT_IN_PIPE(_m, 1)
#define MMUPORT_IN_PIPE2(_m) MMUPORT_IN_PIPE(_m, 2)
#define MMUPORT_IN_PIPE3(_m) MMUPORT_IN_PIPE(_m, 3)

    /* Transparent information */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_AT_UNIQUE_GLOBAL) {
        return AT_DUPLICATE;
    }

    if (pi_type == BCMDRD_PIPE_INFO_TYPE_NUM_PIPE_INST) {
        if (pi == NULL) {
            /* Get the number of pipes for the device. */
            return 4;
        }
        /* Get the number of block-based pipes for the device. */
        switch (pi->blktype) {
        case BLKTYPE_IPIPE:
        case BLKTYPE_EPIPE:
        case BLKTYPE_MMU_XPE:
            return 4;
        case BLKTYPE_MMU_SC:
            return 2;
        default:
            return 0;
        }
    }

    if (pi == NULL) {
        return 0;
    }

    /* Return the pipe index for a given physical device port. */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_PIPE_INDEX_FROM_PORT) {
        uint32_t pipe_idx = 0;

        if (pi->pnd == BCMDRD_PND_PHYS) {
            if (pi->port >= 1 && pi->port <= 128) {
                pipe_idx = (pi->port - 1) >> 5;
            } else if (pi->port == 0) {
                pipe_idx = 0;
            } else if (pi->port == 129) {
                pipe_idx = 1;
            } else if (pi->port == 131) {
                pipe_idx = 2;
            } else if (pi->port >= 132 && pi->port <= 135) {
                pipe_idx = pi->port - 132;
            }
        } else if (pi->pnd == BCMDRD_PND_LOGIC) {
            if (pi->port >= 0 && pi->port < 136) {
                pipe_idx = pi->port / 34;
            }
        } else if (pi->pnd == BCMDRD_PND_MMU) {
            if (pi->port >= 0 && pi->port <= 225) {
                pipe_idx = pi->port >> 6;
            }
        }
        return pipe_idx;
    }

    /* Information without base type */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_PMASK) {
        /* Unique block instances */
        uint32_t inst_mask = 0;

        if (pi->acctype == AT_UNIQUE) {
            switch (pi->blktype) {
            case BLKTYPE_IPIPE:
            case BLKTYPE_EPIPE:
            case BLKTYPE_MMU_XPE:
                inst_mask = 0xf;
                break;
            case BLKTYPE_MMU_SC:
                inst_mask = 0x3;
                break;
            default:
                break;
            }
        }
        return inst_mask;
    }

    base_type = ((pi->offset) >> 23) & 0x7;

    /* Information with base type, without base index */
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_LINST) {
        /* Basetype instances */
        uint32_t num_inst = 0;

        switch (pi->blktype) {
        case BLKTYPE_MMU_XPE:
        case BLKTYPE_MMU_SC:
        case BLKTYPE_MMU_GLB:
            switch (base_type) {
            case BT_IPORT:
            case BT_EPORT:
                num_inst = 226;
                break;
            case BT_IPIPE:
            case BT_EPIPE:
                num_inst = 4;
                if (pi->acctype < 4) {
                    /* Separate SIDs for UNIQUE access type */
                    num_inst = 1;
                }
                break;
            case BT_CHIP:
                num_inst = 1;
                break;
            case BT_XPE:
                num_inst = 4;
                if (pi->acctype < 4) {
                    /* Separate SIDs for UNIQUE access type */
                    num_inst = 1;
                }
                break;
            case BT_SLICE:
            case BT_LAYER:
                num_inst = 2;
                if (pi->acctype < 4) {
                    /* Separate SIDs for UNIQUE access type */
                    num_inst = 1;
                }
                break;
            }
            break;
        default:
            break;
        }
        return num_inst;
    } else if (pi_type == BCMDRD_PIPE_INFO_TYPE_SECT_SHFT) {
        uint32_t sect_shft = 0;

        switch (pi->blktype) {
        case BLKTYPE_MMU_XPE:
            switch (base_type) {
            case BT_XPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            case BT_IPIPE:
            case BT_EPIPE:
            case BT_SLICE:
            case BT_LAYER:
                if (pi->acctype == AT_UNIQUE || pi->acctype == AT_DUPLICATE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            default:
                break;
            }
            break;
        case BLKTYPE_MMU_SC:
            switch (base_type) {
            case BT_EPIPE:
            case BT_XPE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            case BT_SLICE:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            case BT_IPIPE:
            case BT_LAYER:
                if (pi->acctype == AT_UNIQUE || pi->acctype == AT_DUPLICATE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            default:
                break;
            }
            break;
        case BLKTYPE_MMU_GLB:
            switch (base_type) {
            case BT_IPIPE:
            case BT_EPIPE:
            case BT_XPE:
            case BT_SLICE:
            case BT_LAYER:
                if (pi->acctype == AT_SINGLE) {
                    sect_shft = SECT_SHFT_32K;
                }
                break;
            default:
                break;
            }
            break;
        }
        return sect_shft;
    }

    /* Information with base type and base index */
    baseidx = pi->baseidx;
    if (baseidx < 0) {
        return 0;
    }
    if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASETYPE_PMASK ||
        pi_type == BCMDRD_PIPE_INFO_TYPE_BASEIDX_INVALID) {
        /* Valid unique block instances for specific baseidx */
        uint32_t inst_mask = 0;

        if (pi->blktype == BLKTYPE_MMU_XPE) {
            switch (base_type) {
            case BT_IPORT:
                if (MMUPORT_IN_PIPE0(baseidx) ||
                    MMUPORT_IN_PIPE3(baseidx)) {
                    inst_mask = 0x3;
                } else if (MMUPORT_IN_PIPE1(baseidx) ||
                           MMUPORT_IN_PIPE2(baseidx)) {
                    inst_mask = 0xc;
                }
                break;
            case BT_EPORT:
                if (MMUPORT_IN_PIPE0(baseidx) ||
                    MMUPORT_IN_PIPE1(baseidx)) {
                    inst_mask = 0x5;
                } else if (MMUPORT_IN_PIPE2(baseidx) ||
                           MMUPORT_IN_PIPE3(baseidx)) {
                    inst_mask = 0xa;
                }
                break;
            case BT_IPIPE:
                if (baseidx == 0 || baseidx == 3) {
                    inst_mask = 0x3;
                } else if (baseidx == 1 || baseidx == 2) {
                    inst_mask = 0xc;
                }
                break;
            case BT_EPIPE:
                if (baseidx == 0 || baseidx == 1) {
                    inst_mask = 0x5;
                } else if (baseidx == 2 || baseidx == 3) {
                    inst_mask = 0xa;
                }
                break;
            case BT_XPE:
                if (baseidx < 4) {
                    inst_mask = (1 << baseidx);
                }
                break;
            case BT_SLICE:
                if (baseidx == 0) {
                    inst_mask = 0x5;
                } else if (baseidx == 1) {
                    inst_mask = 0xa;
                }
                break;
            case BT_LAYER:
                if (baseidx == 0) {
                    inst_mask = 0x3;
                } else if (baseidx == 1) {
                    inst_mask = 0xc;
                }
                break;
            default:
                break;
            }
        } else if (pi->blktype == BLKTYPE_MMU_SC) {
            switch (base_type) {
            case BT_IPORT:
                if (MMUPORT_IN_PIPE0(baseidx) ||
                    MMUPORT_IN_PIPE1(baseidx) ||
                    MMUPORT_IN_PIPE2(baseidx) ||
                    MMUPORT_IN_PIPE3(baseidx)) {
                    inst_mask = 0x3;
                }
                break;
            case BT_IPIPE:
                if (baseidx < 4) {
                    inst_mask = 0x3;
                }
                break;
            case BT_SLICE:
                if (baseidx < 2) {
                    inst_mask = (1 << baseidx);
                }
                break;
            case BT_LAYER:
                if (baseidx < 2) {
                    inst_mask = 0x3;
                }
                break;
            default:
                break;
            }
        }
        if (pi_type == BCMDRD_PIPE_INFO_TYPE_BASEIDX_INVALID) {
            /*
             * If access type is UNIQUE_PIPE_#, need to check
             * whether the pipe is in BASETYPE_PAMSK inst_mask.
             */
            if (inst_mask != 0 && pi->acctype < 4 &&
                ((1 << pi->acctype) & inst_mask) == 0) {
                return 1;
            }
            return 0;
        }
        return inst_mask;
    }

    return 0;
}

/* Index ranges for this chip */
static bcmdrd_numel_range_t _numel_ranges[] = {
    {  0,  0, BCMDRD_PBMP_7(0xffffffff, 0x00000000, 0xffffffff, 0x00000000, 0xffffffff, 0x00000000, 0xffffffff) }, /*  0 */
    {  0,  0, BCMDRD_PBMP_8(0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003) }, /*  1 */
    {  0,  3, BCMDRD_PBMP_8(0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003) }, /*  2 */
    {  0,  1, BCMDRD_PBMP_8(0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003) }  /*  3 */
};

/* Register array encodings for this chip */
static bcmdrd_numel_encoding_t _numel_encodings[] = {
    { { 5 } },
    { {  0, -1 } },
    { {  1, -1 } },
    { {  2, -1 } },
    { {  3, -1 } }
};

/* Variable register array info */
bcmdrd_numel_info_t bcm56960_a0_numel_info = {
    _numel_ranges,
    _numel_encodings
};

/* Chip information structure */
bcmdrd_chip_info_t bcm56960_a0_chip_info = {

    /* HMI block (typically CMIC block number). */
    CMIC_BLOCK,

    /* HMI instance (typically CMIC CMC instance). */
    0,

    /* Other (non-HMI) block types */
    13,
    bcm56960_a0_blktype_names,

    /* Other (non-HMI) blocks */
    47,
    bcm56960_a0_blocks,

    /* Valid ports for this chip */
    {
        /* Valid physical ports for this chip */
        BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000fb),
        /* Valid logical ports for this chip */
        BCMDRD_PBMP_5(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000ff),
        /* Valid MMU ports for this chip */
        BCMDRD_PBMP_8(0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003, 0xffffffff, 0x00000003)
    },
    /* Chip flags */
    0,

    /* Address calculation override */
    NULL,

#if BCMDRD_CONFIG_INCLUDE_CHIP_SYMBOLS == 1
    /* Use the static per-chip symbol tables */
    &bcm56960_a0_symbols,
#endif

    /* Variable register array info */
    &bcm56960_a0_numel_info,

    /* Port number domain */
    bcm56960_a0_port_num_domain,

    /* Configuration dependent memory max index */
    NULL,

    /* Pipe info */
    bcm56960_a0_pipe_info,

    /* Address decoder */
    NULL

};
