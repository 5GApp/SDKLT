#ifndef BCM56960_A0_CLPORT_DEFS_H
#define BCM56960_A0_CLPORT_DEFS_H
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: $
 * Copyright: (c) 2018 Broadcom. All Rights Reserved. "Broadcom" refers to 
 * Broadcom Limited and/or its subsidiaries.
 * 
 * Broadcom Switch Software License
 * 
 * This license governs the use of the accompanying Broadcom software. Your 
 * use of the software indicates your acceptance of the terms and conditions 
 * of this license. If you do not agree to the terms and conditions of this 
 * license, do not use the software.
 * 1. Definitions
 *    "Licensor" means any person or entity that distributes its Work.
 *    "Software" means the original work of authorship made available under 
 *    this license.
 *    "Work" means the Software and any additions to or derivative works of 
 *    the Software that are made available under this license.
 *    The terms "reproduce," "reproduction," "derivative works," and 
 *    "distribution" have the meaning as provided under U.S. copyright law.
 *    Works, including the Software, are "made available" under this license 
 *    by including in or with the Work either (a) a copyright notice 
 *    referencing the applicability of this license to the Work, or (b) a copy 
 *    of this license.
 * 2. Grant of Copyright License
 *    Subject to the terms and conditions of this license, each Licensor 
 *    grants to you a perpetual, worldwide, non-exclusive, and royalty-free 
 *    copyright license to reproduce, prepare derivative works of, publicly 
 *    display, publicly perform, sublicense and distribute its Work and any 
 *    resulting derivative works in any form.
 * 3. Grant of Patent License
 *    Subject to the terms and conditions of this license, each Licensor 
 *    grants to you a perpetual, worldwide, non-exclusive, and royalty-free 
 *    patent license to make, have made, use, offer to sell, sell, import, and 
 *    otherwise transfer its Work, in whole or in part. This patent license 
 *    applies only to the patent claims licensable by Licensor that would be 
 *    infringed by Licensor's Work (or portion thereof) individually and 
 *    excluding any combinations with any other materials or technology.
 *    If you institute patent litigation against any Licensor (including a 
 *    cross-claim or counterclaim in a lawsuit) to enforce any patents that 
 *    you allege are infringed by any Work, then your patent license from such 
 *    Licensor to the Work shall terminate as of the date such litigation is 
 *    filed.
 * 4. Redistribution
 *    You may reproduce or distribute the Work only if (a) you do so under 
 *    this License, (b) you include a complete copy of this License with your 
 *    distribution, and (c) you retain without modification any copyright, 
 *    patent, trademark, or attribution notices that are present in the Work.
 * 5. Derivative Works
 *    You may specify that additional or different terms apply to the use, 
 *    reproduction, and distribution of your derivative works of the Work 
 *    ("Your Terms") only if (a) Your Terms provide that the limitations of 
 *    Section 7 apply to your derivative works, and (b) you identify the 
 *    specific derivative works that are subject to Your Terms. 
 *    Notwithstanding Your Terms, this license (including the redistribution 
 *    requirements in Section 4) will continue to apply to the Work itself.
 * 6. Trademarks
 *    This license does not grant any rights to use any Licensor's or its 
 *    affiliates' names, logos, or trademarks, except as necessary to 
 *    reproduce the notices described in this license.
 * 7. Limitations
 *    Platform. The Work and any derivative works thereof may only be used, or 
 *    intended for use, with a Broadcom switch integrated circuit.
 *    No Reverse Engineering. You will not use the Work to disassemble, 
 *    reverse engineer, decompile, or attempt to ascertain the underlying 
 *    technology of a Broadcom switch integrated circuit.
 * 8. Termination
 *    If you violate any term of this license, then your rights under this 
 *    license (including the license grants of Sections 2 and 3) will 
 *    terminate immediately.
 * 9. Disclaimer of Warranty
 *    THE WORK IS PROVIDED "AS IS" WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 *    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WARRANTIES OR CONDITIONS OF 
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR 
 *    NON-INFRINGEMENT. YOU BEAR THE RISK OF UNDERTAKING ANY ACTIVITIES UNDER 
 *    THIS LICENSE. SOME STATES' CONSUMER LAWS DO NOT ALLOW EXCLUSION OF AN 
 *    IMPLIED WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO YOU.
 * 10. Limitation of Liability
 *    EXCEPT AS PROHIBITED BY APPLICABLE LAW, IN NO EVENT AND UNDER NO LEGAL 
 *    THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE 
 *    SHALL ANY LICENSOR BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY DIRECT, 
 *    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF 
 *    OR RELATED TO THIS LICENSE, THE USE OR INABILITY TO USE THE WORK 
 *    (INCLUDING BUT NOT LIMITED TO LOSS OF GOODWILL, BUSINESS INTERRUPTION, 
 *    LOST PROFITS OR DATA, COMPUTER FAILURE OR MALFUNCTION, OR ANY OTHER 
 *    COMMERCIAL DAMAGES OR LOSSES), EVEN IF THE LICENSOR HAS BEEN ADVISED OF 
 *    THE POSSIBILITY OF SUCH DAMAGES.
 * 
 * 
 *
 * Definition file for the BCM56960_A0.
 */

#include <sal/sal_libc.h>

/*******************************************************************************
 * REGISTER:  CLMAC_CLEAR_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_CLEAR_ECC_STATUSr_OFFSET 0x10063400

#define CLMAC_CLEAR_ECC_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_CLEAR_ECC_STATUS.
 */
typedef union CLMAC_CLEAR_ECC_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_clear_ecc_status[2];
	uint32_t _clmac_clear_ecc_status;
} CLMAC_CLEAR_ECC_STATUSr_t;

#define CLMAC_CLEAR_ECC_STATUSr_CLR(r) sal_memset(&((r)._clmac_clear_ecc_status), 0, sizeof(CLMAC_CLEAR_ECC_STATUSr_t))
#define CLMAC_CLEAR_ECC_STATUSr_SET(r,i,d) (r).clmac_clear_ecc_status[i] = d
#define CLMAC_CLEAR_ECC_STATUSr_GET(r,i) (r).clmac_clear_ecc_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_SINGLE_BIT_ERRf_GET(r) (((r).clmac_clear_ecc_status[0]) & 0x1)
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_clear_ecc_status[0]=(((r).clmac_clear_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_clear_ecc_status[0]) >> 1) & 0x1)
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_clear_ecc_status[0]=(((r).clmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_SINGLE_BIT_ERRf_GET(r) ((((r).clmac_clear_ecc_status[0]) >> 2) & 0x1)
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_clear_ecc_status[0]=(((r).clmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_clear_ecc_status[0]) >> 3) & 0x1)
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_clear_ecc_status[0]=(((r).clmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_TS_MEM_SINGLE_BIT_ERRf_GET(r) ((((r).clmac_clear_ecc_status[0]) >> 4) & 0x1)
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_TS_MEM_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_clear_ecc_status[0]=(((r).clmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_TS_MEM_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_clear_ecc_status[0]) >> 5) & 0x1)
#define CLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_TS_MEM_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_clear_ecc_status[0]=(((r).clmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access CLMAC_CLEAR_ECC_STATUS.
 */
#define READ_CLMAC_CLEAR_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_CLEAR_ECC_STATUSr_OFFSET,0,CLMAC_CLEAR_ECC_STATUSr_SIZE,(r._clmac_clear_ecc_status))
#define WRITE_CLMAC_CLEAR_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_CLEAR_ECC_STATUSr_OFFSET,0,CLMAC_CLEAR_ECC_STATUSr_SIZE,&(r._clmac_clear_ecc_status))

/*******************************************************************************
 * End of 'CLMAC_CLEAR_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_CLEAR_FIFO_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_CLEAR_FIFO_STATUSr_OFFSET 0x10061800

#define CLMAC_CLEAR_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_CLEAR_FIFO_STATUS.
 */
typedef union CLMAC_CLEAR_FIFO_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_clear_fifo_status[2];
	uint32_t _clmac_clear_fifo_status;
} CLMAC_CLEAR_FIFO_STATUSr_t;

#define CLMAC_CLEAR_FIFO_STATUSr_CLR(r) sal_memset(&((r)._clmac_clear_fifo_status), 0, sizeof(CLMAC_CLEAR_FIFO_STATUSr_t))
#define CLMAC_CLEAR_FIFO_STATUSr_SET(r,i,d) (r).clmac_clear_fifo_status[i] = d
#define CLMAC_CLEAR_FIFO_STATUSr_GET(r,i) (r).clmac_clear_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_CLEAR_FIFO_STATUSr_RSVD_1f_GET(r) (((r).clmac_clear_fifo_status[0]) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_RSVD_1f_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_MSG_OVERFLOWf_GET(r) ((((r).clmac_clear_fifo_status[0]) >> 1) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_MSG_OVERFLOWf_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_UNDERFLOWf_GET(r) ((((r).clmac_clear_fifo_status[0]) >> 2) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_UNDERFLOWf_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_OVERFLOWf_GET(r) ((((r).clmac_clear_fifo_status[0]) >> 3) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_OVERFLOWf_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_CLEAR_FIFO_STATUSr_RSVD_2f_GET(r) ((((r).clmac_clear_fifo_status[0]) >> 4) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_RSVD_2f_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_LLFC_MSG_OVERFLOWf_GET(r) ((((r).clmac_clear_fifo_status[0]) >> 5) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_LLFC_MSG_OVERFLOWf_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_TS_FIFO_OVERFLOWf_GET(r) ((((r).clmac_clear_fifo_status[0]) >> 6) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_TS_FIFO_OVERFLOWf_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_PKT_OVERFLOWf_GET(r) ((((r).clmac_clear_fifo_status[0]) >> 7) & 0x1)
#define CLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_PKT_OVERFLOWf_SET(r,f) (r).clmac_clear_fifo_status[0]=(((r).clmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CLMAC_CLEAR_FIFO_STATUS.
 */
#define READ_CLMAC_CLEAR_FIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_CLEAR_FIFO_STATUSr_OFFSET,0,CLMAC_CLEAR_FIFO_STATUSr_SIZE,(r._clmac_clear_fifo_status))
#define WRITE_CLMAC_CLEAR_FIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_CLEAR_FIFO_STATUSr_OFFSET,0,CLMAC_CLEAR_FIFO_STATUSr_SIZE,&(r._clmac_clear_fifo_status))

/*******************************************************************************
 * End of 'CLMAC_CLEAR_FIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_CLEAR_RX_LSS_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_CLEAR_RX_LSS_STATUSr_OFFSET 0x10060c00

#define CLMAC_CLEAR_RX_LSS_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_CLEAR_RX_LSS_STATUS.
 */
typedef union CLMAC_CLEAR_RX_LSS_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_clear_rx_lss_status[2];
	uint32_t _clmac_clear_rx_lss_status;
} CLMAC_CLEAR_RX_LSS_STATUSr_t;

#define CLMAC_CLEAR_RX_LSS_STATUSr_CLR(r) sal_memset(&((r)._clmac_clear_rx_lss_status), 0, sizeof(CLMAC_CLEAR_RX_LSS_STATUSr_t))
#define CLMAC_CLEAR_RX_LSS_STATUSr_SET(r,i,d) (r).clmac_clear_rx_lss_status[i] = d
#define CLMAC_CLEAR_RX_LSS_STATUSr_GET(r,i) (r).clmac_clear_rx_lss_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LOCAL_FAULT_STATUSf_GET(r) (((r).clmac_clear_rx_lss_status[0]) & 0x1)
#define CLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LOCAL_FAULT_STATUSf_SET(r,f) (r).clmac_clear_rx_lss_status[0]=(((r).clmac_clear_rx_lss_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_REMOTE_FAULT_STATUSf_GET(r) ((((r).clmac_clear_rx_lss_status[0]) >> 1) & 0x1)
#define CLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_REMOTE_FAULT_STATUSf_SET(r,f) (r).clmac_clear_rx_lss_status[0]=(((r).clmac_clear_rx_lss_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).clmac_clear_rx_lss_status[0]) >> 2) & 0x1)
#define CLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).clmac_clear_rx_lss_status[0]=(((r).clmac_clear_rx_lss_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CLMAC_CLEAR_RX_LSS_STATUS.
 */
#define READ_CLMAC_CLEAR_RX_LSS_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_CLEAR_RX_LSS_STATUSr_OFFSET,0,CLMAC_CLEAR_RX_LSS_STATUSr_SIZE,(r._clmac_clear_rx_lss_status))
#define WRITE_CLMAC_CLEAR_RX_LSS_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_CLEAR_RX_LSS_STATUSr_OFFSET,0,CLMAC_CLEAR_RX_LSS_STATUSr_SIZE,&(r._clmac_clear_rx_lss_status))

/*******************************************************************************
 * End of 'CLMAC_CLEAR_RX_LSS_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_CTRLr_OFFSET 0x10060000

#define CLMAC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_CTRL.
 */
typedef union CLMAC_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_ctrl[2];
	uint32_t _clmac_ctrl;
} CLMAC_CTRLr_t;

#define CLMAC_CTRLr_CLR(r) sal_memset(&((r)._clmac_ctrl), 0, sizeof(CLMAC_CTRLr_t))
#define CLMAC_CTRLr_SET(r,i,d) (r).clmac_ctrl[i] = d
#define CLMAC_CTRLr_GET(r,i) (r).clmac_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_CTRLr_TX_ENf_GET(r) (((r).clmac_ctrl[0]) & 0x1)
#define CLMAC_CTRLr_TX_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_CTRLr_RX_ENf_GET(r) ((((r).clmac_ctrl[0]) >> 1) & 0x1)
#define CLMAC_CTRLr_RX_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_CTRLr_LOCAL_LPBKf_GET(r) ((((r).clmac_ctrl[0]) >> 2) & 0x1)
#define CLMAC_CTRLr_LOCAL_LPBKf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_CTRLr_RSVD_1f_GET(r) ((((r).clmac_ctrl[0]) >> 3) & 0x1)
#define CLMAC_CTRLr_RSVD_1f_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_GET(r) ((((r).clmac_ctrl[0]) >> 4) & 0x1)
#define CLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_CTRLr_LAG_FAILOVER_ENf_GET(r) ((((r).clmac_ctrl[0]) >> 5) & 0x1)
#define CLMAC_CTRLr_LAG_FAILOVER_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLMAC_CTRLr_SOFT_RESETf_GET(r) ((((r).clmac_ctrl[0]) >> 6) & 0x1)
#define CLMAC_CTRLr_SOFT_RESETf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CLMAC_CTRLr_RSVD_4f_GET(r) ((((r).clmac_ctrl[0]) >> 7) & 0x1)
#define CLMAC_CTRLr_RSVD_4f_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_GET(r) ((((r).clmac_ctrl[0]) >> 8) & 0x1)
#define CLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CLMAC_CTRLr_RSVD_5f_GET(r) ((((r).clmac_ctrl[0]) >> 9) & 0x1)
#define CLMAC_CTRLr_RSVD_5f_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CLMAC_CTRLr_RS_SOFT_RESETf_GET(r) ((((r).clmac_ctrl[0]) >> 10) & 0x1)
#define CLMAC_CTRLr_RS_SOFT_RESETf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_GET(r) ((((r).clmac_ctrl[0]) >> 11) & 0x1)
#define CLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CLMAC_CTRLr_SW_LINK_STATUSf_GET(r) ((((r).clmac_ctrl[0]) >> 12) & 0x1)
#define CLMAC_CTRLr_SW_LINK_STATUSf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define CLMAC_CTRLr_LINK_STATUS_SELECTf_GET(r) ((((r).clmac_ctrl[0]) >> 13) & 0x1)
#define CLMAC_CTRLr_LINK_STATUS_SELECTf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define CLMAC_CTRLr_ALLOW_40B_AND_GREATER_PKTSf_GET(r) ((((r).clmac_ctrl[0]) >> 14) & 0x1)
#define CLMAC_CTRLr_ALLOW_40B_AND_GREATER_PKTSf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define CLMAC_CTRLr_EXTENDED_HIG2_ENf_GET(r) ((((r).clmac_ctrl[0]) >> 15) & 0x1)
#define CLMAC_CTRLr_EXTENDED_HIG2_ENf_SET(r,f) (r).clmac_ctrl[0]=(((r).clmac_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access CLMAC_CTRL.
 */
#define READ_CLMAC_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_CTRLr_OFFSET,0,CLMAC_CTRLr_SIZE,(r._clmac_ctrl))
#define WRITE_CLMAC_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_CTRLr_OFFSET,0,CLMAC_CTRLr_SIZE,&(r._clmac_ctrl))

/*******************************************************************************
 * End of 'CLMAC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2ECC_DATA_HDR_0
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2ECC_DATA_HDR_0r_OFFSET 0x10062500

#define CLMAC_E2ECC_DATA_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2ECC_DATA_HDR_0.
 */
typedef union CLMAC_E2ECC_DATA_HDR_0r_s {
	uint32_t v[2];
	uint32_t clmac_e2ecc_data_hdr_0[2];
	uint32_t _clmac_e2ecc_data_hdr_0;
} CLMAC_E2ECC_DATA_HDR_0r_t;

#define CLMAC_E2ECC_DATA_HDR_0r_CLR(r) sal_memset(&((r)._clmac_e2ecc_data_hdr_0), 0, sizeof(CLMAC_E2ECC_DATA_HDR_0r_t))
#define CLMAC_E2ECC_DATA_HDR_0r_SET(r,i,d) (r).clmac_e2ecc_data_hdr_0[i] = d
#define CLMAC_E2ECC_DATA_HDR_0r_GET(r,i) (r).clmac_e2ecc_data_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0f_GET(r,a) bcmpmac_field_get((r).clmac_e2ecc_data_hdr_0,0,63,a)
#define CLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0f_SET(r,a) bcmpmac_field_set((r).clmac_e2ecc_data_hdr_0,0,63,a)
#define CLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_LOf_GET(r) ((r).clmac_e2ecc_data_hdr_0[0])
#define CLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_LOf_SET(r,f) (r).clmac_e2ecc_data_hdr_0[0]=((uint32_t)f)
#define CLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_HIf_GET(r) ((r).clmac_e2ecc_data_hdr_0[1])
#define CLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_HIf_SET(r,f) (r).clmac_e2ecc_data_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2ECC_DATA_HDR_0.
 */
#define READ_CLMAC_E2ECC_DATA_HDR_0r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2ECC_DATA_HDR_0r_OFFSET,0,CLMAC_E2ECC_DATA_HDR_0r_SIZE,(r._clmac_e2ecc_data_hdr_0))
#define WRITE_CLMAC_E2ECC_DATA_HDR_0r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2ECC_DATA_HDR_0r_OFFSET,0,CLMAC_E2ECC_DATA_HDR_0r_SIZE,&(r._clmac_e2ecc_data_hdr_0))

/*******************************************************************************
 * End of 'CLMAC_E2ECC_DATA_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2ECC_DATA_HDR_1
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2ECC_DATA_HDR_1r_OFFSET 0x10062600

#define CLMAC_E2ECC_DATA_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2ECC_DATA_HDR_1.
 */
typedef union CLMAC_E2ECC_DATA_HDR_1r_s {
	uint32_t v[2];
	uint32_t clmac_e2ecc_data_hdr_1[2];
	uint32_t _clmac_e2ecc_data_hdr_1;
} CLMAC_E2ECC_DATA_HDR_1r_t;

#define CLMAC_E2ECC_DATA_HDR_1r_CLR(r) sal_memset(&((r)._clmac_e2ecc_data_hdr_1), 0, sizeof(CLMAC_E2ECC_DATA_HDR_1r_t))
#define CLMAC_E2ECC_DATA_HDR_1r_SET(r,i,d) (r).clmac_e2ecc_data_hdr_1[i] = d
#define CLMAC_E2ECC_DATA_HDR_1r_GET(r,i) (r).clmac_e2ecc_data_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1f_GET(r,a) bcmpmac_field_get((r).clmac_e2ecc_data_hdr_1,0,63,a)
#define CLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1f_SET(r,a) bcmpmac_field_set((r).clmac_e2ecc_data_hdr_1,0,63,a)
#define CLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_LOf_GET(r) ((r).clmac_e2ecc_data_hdr_1[0])
#define CLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_LOf_SET(r,f) (r).clmac_e2ecc_data_hdr_1[0]=((uint32_t)f)
#define CLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_HIf_GET(r) ((r).clmac_e2ecc_data_hdr_1[1])
#define CLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_HIf_SET(r,f) (r).clmac_e2ecc_data_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2ECC_DATA_HDR_1.
 */
#define READ_CLMAC_E2ECC_DATA_HDR_1r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2ECC_DATA_HDR_1r_OFFSET,0,CLMAC_E2ECC_DATA_HDR_1r_SIZE,(r._clmac_e2ecc_data_hdr_1))
#define WRITE_CLMAC_E2ECC_DATA_HDR_1r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2ECC_DATA_HDR_1r_OFFSET,0,CLMAC_E2ECC_DATA_HDR_1r_SIZE,&(r._clmac_e2ecc_data_hdr_1))

/*******************************************************************************
 * End of 'CLMAC_E2ECC_DATA_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2ECC_MODULE_HDR_0
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2ECC_MODULE_HDR_0r_OFFSET 0x10062300

#define CLMAC_E2ECC_MODULE_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2ECC_MODULE_HDR_0.
 */
typedef union CLMAC_E2ECC_MODULE_HDR_0r_s {
	uint32_t v[2];
	uint32_t clmac_e2ecc_module_hdr_0[2];
	uint32_t _clmac_e2ecc_module_hdr_0;
} CLMAC_E2ECC_MODULE_HDR_0r_t;

#define CLMAC_E2ECC_MODULE_HDR_0r_CLR(r) sal_memset(&((r)._clmac_e2ecc_module_hdr_0), 0, sizeof(CLMAC_E2ECC_MODULE_HDR_0r_t))
#define CLMAC_E2ECC_MODULE_HDR_0r_SET(r,i,d) (r).clmac_e2ecc_module_hdr_0[i] = d
#define CLMAC_E2ECC_MODULE_HDR_0r_GET(r,i) (r).clmac_e2ecc_module_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0f_GET(r,a) bcmpmac_field_get((r).clmac_e2ecc_module_hdr_0,0,63,a)
#define CLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0f_SET(r,a) bcmpmac_field_set((r).clmac_e2ecc_module_hdr_0,0,63,a)
#define CLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_LOf_GET(r) ((r).clmac_e2ecc_module_hdr_0[0])
#define CLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_LOf_SET(r,f) (r).clmac_e2ecc_module_hdr_0[0]=((uint32_t)f)
#define CLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_HIf_GET(r) ((r).clmac_e2ecc_module_hdr_0[1])
#define CLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_HIf_SET(r,f) (r).clmac_e2ecc_module_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2ECC_MODULE_HDR_0.
 */
#define READ_CLMAC_E2ECC_MODULE_HDR_0r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2ECC_MODULE_HDR_0r_OFFSET,0,CLMAC_E2ECC_MODULE_HDR_0r_SIZE,(r._clmac_e2ecc_module_hdr_0))
#define WRITE_CLMAC_E2ECC_MODULE_HDR_0r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2ECC_MODULE_HDR_0r_OFFSET,0,CLMAC_E2ECC_MODULE_HDR_0r_SIZE,&(r._clmac_e2ecc_module_hdr_0))

/*******************************************************************************
 * End of 'CLMAC_E2ECC_MODULE_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2ECC_MODULE_HDR_1
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2ECC_MODULE_HDR_1r_OFFSET 0x10062400

#define CLMAC_E2ECC_MODULE_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2ECC_MODULE_HDR_1.
 */
typedef union CLMAC_E2ECC_MODULE_HDR_1r_s {
	uint32_t v[2];
	uint32_t clmac_e2ecc_module_hdr_1[2];
	uint32_t _clmac_e2ecc_module_hdr_1;
} CLMAC_E2ECC_MODULE_HDR_1r_t;

#define CLMAC_E2ECC_MODULE_HDR_1r_CLR(r) sal_memset(&((r)._clmac_e2ecc_module_hdr_1), 0, sizeof(CLMAC_E2ECC_MODULE_HDR_1r_t))
#define CLMAC_E2ECC_MODULE_HDR_1r_SET(r,i,d) (r).clmac_e2ecc_module_hdr_1[i] = d
#define CLMAC_E2ECC_MODULE_HDR_1r_GET(r,i) (r).clmac_e2ecc_module_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1f_GET(r,a) bcmpmac_field_get((r).clmac_e2ecc_module_hdr_1,0,63,a)
#define CLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1f_SET(r,a) bcmpmac_field_set((r).clmac_e2ecc_module_hdr_1,0,63,a)
#define CLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_LOf_GET(r) ((r).clmac_e2ecc_module_hdr_1[0])
#define CLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_LOf_SET(r,f) (r).clmac_e2ecc_module_hdr_1[0]=((uint32_t)f)
#define CLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_HIf_GET(r) ((r).clmac_e2ecc_module_hdr_1[1])
#define CLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_HIf_SET(r,f) (r).clmac_e2ecc_module_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2ECC_MODULE_HDR_1.
 */
#define READ_CLMAC_E2ECC_MODULE_HDR_1r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2ECC_MODULE_HDR_1r_OFFSET,0,CLMAC_E2ECC_MODULE_HDR_1r_SIZE,(r._clmac_e2ecc_module_hdr_1))
#define WRITE_CLMAC_E2ECC_MODULE_HDR_1r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2ECC_MODULE_HDR_1r_OFFSET,0,CLMAC_E2ECC_MODULE_HDR_1r_SIZE,&(r._clmac_e2ecc_module_hdr_1))

/*******************************************************************************
 * End of 'CLMAC_E2ECC_MODULE_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2EFC_DATA_HDR_0
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2EFC_DATA_HDR_0r_OFFSET 0x10062900

#define CLMAC_E2EFC_DATA_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2EFC_DATA_HDR_0.
 */
typedef union CLMAC_E2EFC_DATA_HDR_0r_s {
	uint32_t v[2];
	uint32_t clmac_e2efc_data_hdr_0[2];
	uint32_t _clmac_e2efc_data_hdr_0;
} CLMAC_E2EFC_DATA_HDR_0r_t;

#define CLMAC_E2EFC_DATA_HDR_0r_CLR(r) sal_memset(&((r)._clmac_e2efc_data_hdr_0), 0, sizeof(CLMAC_E2EFC_DATA_HDR_0r_t))
#define CLMAC_E2EFC_DATA_HDR_0r_SET(r,i,d) (r).clmac_e2efc_data_hdr_0[i] = d
#define CLMAC_E2EFC_DATA_HDR_0r_GET(r,i) (r).clmac_e2efc_data_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0f_GET(r,a) bcmpmac_field_get((r).clmac_e2efc_data_hdr_0,0,63,a)
#define CLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0f_SET(r,a) bcmpmac_field_set((r).clmac_e2efc_data_hdr_0,0,63,a)
#define CLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_LOf_GET(r) ((r).clmac_e2efc_data_hdr_0[0])
#define CLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_LOf_SET(r,f) (r).clmac_e2efc_data_hdr_0[0]=((uint32_t)f)
#define CLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_HIf_GET(r) ((r).clmac_e2efc_data_hdr_0[1])
#define CLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_HIf_SET(r,f) (r).clmac_e2efc_data_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2EFC_DATA_HDR_0.
 */
#define READ_CLMAC_E2EFC_DATA_HDR_0r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2EFC_DATA_HDR_0r_OFFSET,0,CLMAC_E2EFC_DATA_HDR_0r_SIZE,(r._clmac_e2efc_data_hdr_0))
#define WRITE_CLMAC_E2EFC_DATA_HDR_0r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2EFC_DATA_HDR_0r_OFFSET,0,CLMAC_E2EFC_DATA_HDR_0r_SIZE,&(r._clmac_e2efc_data_hdr_0))

/*******************************************************************************
 * End of 'CLMAC_E2EFC_DATA_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2EFC_DATA_HDR_1
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2EFC_DATA_HDR_1r_OFFSET 0x10062a00

#define CLMAC_E2EFC_DATA_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2EFC_DATA_HDR_1.
 */
typedef union CLMAC_E2EFC_DATA_HDR_1r_s {
	uint32_t v[2];
	uint32_t clmac_e2efc_data_hdr_1[2];
	uint32_t _clmac_e2efc_data_hdr_1;
} CLMAC_E2EFC_DATA_HDR_1r_t;

#define CLMAC_E2EFC_DATA_HDR_1r_CLR(r) sal_memset(&((r)._clmac_e2efc_data_hdr_1), 0, sizeof(CLMAC_E2EFC_DATA_HDR_1r_t))
#define CLMAC_E2EFC_DATA_HDR_1r_SET(r,i,d) (r).clmac_e2efc_data_hdr_1[i] = d
#define CLMAC_E2EFC_DATA_HDR_1r_GET(r,i) (r).clmac_e2efc_data_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1f_GET(r,a) bcmpmac_field_get((r).clmac_e2efc_data_hdr_1,0,63,a)
#define CLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1f_SET(r,a) bcmpmac_field_set((r).clmac_e2efc_data_hdr_1,0,63,a)
#define CLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_LOf_GET(r) ((r).clmac_e2efc_data_hdr_1[0])
#define CLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_LOf_SET(r,f) (r).clmac_e2efc_data_hdr_1[0]=((uint32_t)f)
#define CLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_HIf_GET(r) ((r).clmac_e2efc_data_hdr_1[1])
#define CLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_HIf_SET(r,f) (r).clmac_e2efc_data_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2EFC_DATA_HDR_1.
 */
#define READ_CLMAC_E2EFC_DATA_HDR_1r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2EFC_DATA_HDR_1r_OFFSET,0,CLMAC_E2EFC_DATA_HDR_1r_SIZE,(r._clmac_e2efc_data_hdr_1))
#define WRITE_CLMAC_E2EFC_DATA_HDR_1r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2EFC_DATA_HDR_1r_OFFSET,0,CLMAC_E2EFC_DATA_HDR_1r_SIZE,&(r._clmac_e2efc_data_hdr_1))

/*******************************************************************************
 * End of 'CLMAC_E2EFC_DATA_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2EFC_MODULE_HDR_0
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2EFC_MODULE_HDR_0r_OFFSET 0x10062700

#define CLMAC_E2EFC_MODULE_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2EFC_MODULE_HDR_0.
 */
typedef union CLMAC_E2EFC_MODULE_HDR_0r_s {
	uint32_t v[2];
	uint32_t clmac_e2efc_module_hdr_0[2];
	uint32_t _clmac_e2efc_module_hdr_0;
} CLMAC_E2EFC_MODULE_HDR_0r_t;

#define CLMAC_E2EFC_MODULE_HDR_0r_CLR(r) sal_memset(&((r)._clmac_e2efc_module_hdr_0), 0, sizeof(CLMAC_E2EFC_MODULE_HDR_0r_t))
#define CLMAC_E2EFC_MODULE_HDR_0r_SET(r,i,d) (r).clmac_e2efc_module_hdr_0[i] = d
#define CLMAC_E2EFC_MODULE_HDR_0r_GET(r,i) (r).clmac_e2efc_module_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0f_GET(r,a) bcmpmac_field_get((r).clmac_e2efc_module_hdr_0,0,63,a)
#define CLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0f_SET(r,a) bcmpmac_field_set((r).clmac_e2efc_module_hdr_0,0,63,a)
#define CLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_LOf_GET(r) ((r).clmac_e2efc_module_hdr_0[0])
#define CLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_LOf_SET(r,f) (r).clmac_e2efc_module_hdr_0[0]=((uint32_t)f)
#define CLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_HIf_GET(r) ((r).clmac_e2efc_module_hdr_0[1])
#define CLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_HIf_SET(r,f) (r).clmac_e2efc_module_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2EFC_MODULE_HDR_0.
 */
#define READ_CLMAC_E2EFC_MODULE_HDR_0r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2EFC_MODULE_HDR_0r_OFFSET,0,CLMAC_E2EFC_MODULE_HDR_0r_SIZE,(r._clmac_e2efc_module_hdr_0))
#define WRITE_CLMAC_E2EFC_MODULE_HDR_0r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2EFC_MODULE_HDR_0r_OFFSET,0,CLMAC_E2EFC_MODULE_HDR_0r_SIZE,&(r._clmac_e2efc_module_hdr_0))

/*******************************************************************************
 * End of 'CLMAC_E2EFC_MODULE_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2EFC_MODULE_HDR_1
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2EFC_MODULE_HDR_1r_OFFSET 0x10062800

#define CLMAC_E2EFC_MODULE_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2EFC_MODULE_HDR_1.
 */
typedef union CLMAC_E2EFC_MODULE_HDR_1r_s {
	uint32_t v[2];
	uint32_t clmac_e2efc_module_hdr_1[2];
	uint32_t _clmac_e2efc_module_hdr_1;
} CLMAC_E2EFC_MODULE_HDR_1r_t;

#define CLMAC_E2EFC_MODULE_HDR_1r_CLR(r) sal_memset(&((r)._clmac_e2efc_module_hdr_1), 0, sizeof(CLMAC_E2EFC_MODULE_HDR_1r_t))
#define CLMAC_E2EFC_MODULE_HDR_1r_SET(r,i,d) (r).clmac_e2efc_module_hdr_1[i] = d
#define CLMAC_E2EFC_MODULE_HDR_1r_GET(r,i) (r).clmac_e2efc_module_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1f_GET(r,a) bcmpmac_field_get((r).clmac_e2efc_module_hdr_1,0,63,a)
#define CLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1f_SET(r,a) bcmpmac_field_set((r).clmac_e2efc_module_hdr_1,0,63,a)
#define CLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_LOf_GET(r) ((r).clmac_e2efc_module_hdr_1[0])
#define CLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_LOf_SET(r,f) (r).clmac_e2efc_module_hdr_1[0]=((uint32_t)f)
#define CLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_HIf_GET(r) ((r).clmac_e2efc_module_hdr_1[1])
#define CLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_HIf_SET(r,f) (r).clmac_e2efc_module_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_E2EFC_MODULE_HDR_1.
 */
#define READ_CLMAC_E2EFC_MODULE_HDR_1r(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2EFC_MODULE_HDR_1r_OFFSET,0,CLMAC_E2EFC_MODULE_HDR_1r_SIZE,(r._clmac_e2efc_module_hdr_1))
#define WRITE_CLMAC_E2EFC_MODULE_HDR_1r(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2EFC_MODULE_HDR_1r_OFFSET,0,CLMAC_E2EFC_MODULE_HDR_1r_SIZE,&(r._clmac_e2efc_module_hdr_1))

/*******************************************************************************
 * End of 'CLMAC_E2EFC_MODULE_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_E2E_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_E2E_CTRLr_OFFSET 0x10062200

#define CLMAC_E2E_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_E2E_CTRL.
 */
typedef union CLMAC_E2E_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_e2e_ctrl[2];
	uint32_t _clmac_e2e_ctrl;
} CLMAC_E2E_CTRLr_t;

#define CLMAC_E2E_CTRLr_CLR(r) sal_memset(&((r)._clmac_e2e_ctrl), 0, sizeof(CLMAC_E2E_CTRLr_t))
#define CLMAC_E2E_CTRLr_SET(r,i,d) (r).clmac_e2e_ctrl[i] = d
#define CLMAC_E2E_CTRLr_GET(r,i) (r).clmac_e2e_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_E2E_CTRLr_E2E_ENABLEf_GET(r) (((r).clmac_e2e_ctrl[0]) & 0x1)
#define CLMAC_E2E_CTRLr_E2E_ENABLEf_SET(r,f) (r).clmac_e2e_ctrl[0]=(((r).clmac_e2e_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_E2E_CTRLr_HONOR_PAUSE_FOR_E2Ef_GET(r) ((((r).clmac_e2e_ctrl[0]) >> 1) & 0x1)
#define CLMAC_E2E_CTRLr_HONOR_PAUSE_FOR_E2Ef_SET(r,f) (r).clmac_e2e_ctrl[0]=(((r).clmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_E2E_CTRLr_E2ECC_DUAL_MODID_ENf_GET(r) ((((r).clmac_e2e_ctrl[0]) >> 2) & 0x1)
#define CLMAC_E2E_CTRLr_E2ECC_DUAL_MODID_ENf_SET(r,f) (r).clmac_e2e_ctrl[0]=(((r).clmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_E2E_CTRLr_E2ECC_LEGACY_IMP_ENf_GET(r) ((((r).clmac_e2e_ctrl[0]) >> 3) & 0x1)
#define CLMAC_E2E_CTRLr_E2ECC_LEGACY_IMP_ENf_SET(r,f) (r).clmac_e2e_ctrl[0]=(((r).clmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_E2E_CTRLr_E2EFC_DUAL_MODID_ENf_GET(r) ((((r).clmac_e2e_ctrl[0]) >> 4) & 0x1)
#define CLMAC_E2E_CTRLr_E2EFC_DUAL_MODID_ENf_SET(r,f) (r).clmac_e2e_ctrl[0]=(((r).clmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CLMAC_E2E_CTRL.
 */
#define READ_CLMAC_E2E_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_E2E_CTRLr_OFFSET,0,CLMAC_E2E_CTRLr_SIZE,(r._clmac_e2e_ctrl))
#define WRITE_CLMAC_E2E_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_E2E_CTRLr_OFFSET,0,CLMAC_E2E_CTRLr_SIZE,&(r._clmac_e2e_ctrl))

/*******************************************************************************
 * End of 'CLMAC_E2E_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_ECC_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_ECC_CTRLr_OFFSET 0x10062e00

#define CLMAC_ECC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_ECC_CTRL.
 */
typedef union CLMAC_ECC_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_ecc_ctrl[2];
	uint32_t _clmac_ecc_ctrl;
} CLMAC_ECC_CTRLr_t;

#define CLMAC_ECC_CTRLr_CLR(r) sal_memset(&((r)._clmac_ecc_ctrl), 0, sizeof(CLMAC_ECC_CTRLr_t))
#define CLMAC_ECC_CTRLr_SET(r,i,d) (r).clmac_ecc_ctrl[i] = d
#define CLMAC_ECC_CTRLr_GET(r,i) (r).clmac_ecc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_ECC_CTRLr_RX_CDC_ECC_CTRL_ENf_GET(r) (((r).clmac_ecc_ctrl[0]) & 0x1)
#define CLMAC_ECC_CTRLr_RX_CDC_ECC_CTRL_ENf_SET(r,f) (r).clmac_ecc_ctrl[0]=(((r).clmac_ecc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_ECC_CTRLr_TX_CDC_ECC_CTRL_ENf_GET(r) ((((r).clmac_ecc_ctrl[0]) >> 1) & 0x1)
#define CLMAC_ECC_CTRLr_TX_CDC_ECC_CTRL_ENf_SET(r,f) (r).clmac_ecc_ctrl[0]=(((r).clmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_ECC_CTRLr_RX_TS_MEM_ECC_CTRL_ENf_GET(r) ((((r).clmac_ecc_ctrl[0]) >> 2) & 0x1)
#define CLMAC_ECC_CTRLr_RX_TS_MEM_ECC_CTRL_ENf_SET(r,f) (r).clmac_ecc_ctrl[0]=(((r).clmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CLMAC_ECC_CTRL.
 */
#define READ_CLMAC_ECC_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_ECC_CTRLr_OFFSET,0,CLMAC_ECC_CTRLr_SIZE,(r._clmac_ecc_ctrl))
#define WRITE_CLMAC_ECC_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_ECC_CTRLr_OFFSET,0,CLMAC_ECC_CTRLr_SIZE,&(r._clmac_ecc_ctrl))

/*******************************************************************************
 * End of 'CLMAC_ECC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_ECC_FORCE_DOUBLE_BIT_ERR
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_OFFSET 0x10062f00

#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_ECC_FORCE_DOUBLE_BIT_ERR.
 */
typedef union CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_s {
	uint32_t v[2];
	uint32_t clmac_ecc_force_double_bit_err[2];
	uint32_t _clmac_ecc_force_double_bit_err;
} CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_t;

#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_CLR(r) sal_memset(&((r)._clmac_ecc_force_double_bit_err), 0, sizeof(CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_t))
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SET(r,i,d) (r).clmac_ecc_force_double_bit_err[i] = d
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_GET(r,i) (r).clmac_ecc_force_double_bit_err[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_RX_CDC_FORCE_DOUBLE_BIT_ERRf_GET(r) (((r).clmac_ecc_force_double_bit_err[0]) & 0x1)
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_RX_CDC_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_ecc_force_double_bit_err[0]=(((r).clmac_ecc_force_double_bit_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_TX_CDC_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_ecc_force_double_bit_err[0]) >> 1) & 0x1)
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_TX_CDC_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_ecc_force_double_bit_err[0]=(((r).clmac_ecc_force_double_bit_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_RX_TS_MEM_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_ecc_force_double_bit_err[0]) >> 2) & 0x1)
#define CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_RX_TS_MEM_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_ecc_force_double_bit_err[0]=(((r).clmac_ecc_force_double_bit_err[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CLMAC_ECC_FORCE_DOUBLE_BIT_ERR.
 */
#define READ_CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr(pa,p,r) bcmpmac_read(pa,p,CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_OFFSET,0,CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SIZE,(r._clmac_ecc_force_double_bit_err))
#define WRITE_CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr(pa,p,r) bcmpmac_write(pa,p,CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_OFFSET,0,CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SIZE,&(r._clmac_ecc_force_double_bit_err))

/*******************************************************************************
 * End of 'CLMAC_ECC_FORCE_DOUBLE_BIT_ERRr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_ECC_FORCE_SINGLE_BIT_ERR
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_OFFSET 0x10063000

#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_ECC_FORCE_SINGLE_BIT_ERR.
 */
typedef union CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_s {
	uint32_t v[2];
	uint32_t clmac_ecc_force_single_bit_err[2];
	uint32_t _clmac_ecc_force_single_bit_err;
} CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_t;

#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_CLR(r) sal_memset(&((r)._clmac_ecc_force_single_bit_err), 0, sizeof(CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_t))
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SET(r,i,d) (r).clmac_ecc_force_single_bit_err[i] = d
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_GET(r,i) (r).clmac_ecc_force_single_bit_err[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_RX_CDC_FORCE_SINGLE_BIT_ERRf_GET(r) (((r).clmac_ecc_force_single_bit_err[0]) & 0x1)
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_RX_CDC_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_ecc_force_single_bit_err[0]=(((r).clmac_ecc_force_single_bit_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_TX_CDC_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).clmac_ecc_force_single_bit_err[0]) >> 1) & 0x1)
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_TX_CDC_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_ecc_force_single_bit_err[0]=(((r).clmac_ecc_force_single_bit_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_RX_TS_MEM_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).clmac_ecc_force_single_bit_err[0]) >> 2) & 0x1)
#define CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_RX_TS_MEM_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_ecc_force_single_bit_err[0]=(((r).clmac_ecc_force_single_bit_err[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CLMAC_ECC_FORCE_SINGLE_BIT_ERR.
 */
#define READ_CLMAC_ECC_FORCE_SINGLE_BIT_ERRr(pa,p,r) bcmpmac_read(pa,p,CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_OFFSET,0,CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SIZE,(r._clmac_ecc_force_single_bit_err))
#define WRITE_CLMAC_ECC_FORCE_SINGLE_BIT_ERRr(pa,p,r) bcmpmac_write(pa,p,CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_OFFSET,0,CLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SIZE,&(r._clmac_ecc_force_single_bit_err))

/*******************************************************************************
 * End of 'CLMAC_ECC_FORCE_SINGLE_BIT_ERRr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_EEE_1_SEC_LINK_STATUS_TIMER
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_OFFSET 0x10061c00

#define CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_EEE_1_SEC_LINK_STATUS_TIMER.
 */
typedef union CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_s {
	uint32_t v[2];
	uint32_t clmac_eee_1_sec_link_status_timer[2];
	uint32_t _clmac_eee_1_sec_link_status_timer;
} CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_t;

#define CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_CLR(r) sal_memset(&((r)._clmac_eee_1_sec_link_status_timer), 0, sizeof(CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_t))
#define CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SET(r,i,d) (r).clmac_eee_1_sec_link_status_timer[i] = d
#define CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_GET(r,i) (r).clmac_eee_1_sec_link_status_timer[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_ONE_SECOND_TIMERf_GET(r) (((r).clmac_eee_1_sec_link_status_timer[0]) & 0xffffff)
#define CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_ONE_SECOND_TIMERf_SET(r,f) (r).clmac_eee_1_sec_link_status_timer[0]=(((r).clmac_eee_1_sec_link_status_timer[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access CLMAC_EEE_1_SEC_LINK_STATUS_TIMER.
 */
#define READ_CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr(pa,p,r) bcmpmac_read(pa,p,CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_OFFSET,0,CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SIZE,(r._clmac_eee_1_sec_link_status_timer))
#define WRITE_CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr(pa,p,r) bcmpmac_write(pa,p,CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_OFFSET,0,CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SIZE,&(r._clmac_eee_1_sec_link_status_timer))

/*******************************************************************************
 * End of 'CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_EEE_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_EEE_CTRLr_OFFSET 0x10061a00

#define CLMAC_EEE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_EEE_CTRL.
 */
typedef union CLMAC_EEE_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_eee_ctrl[2];
	uint32_t _clmac_eee_ctrl;
} CLMAC_EEE_CTRLr_t;

#define CLMAC_EEE_CTRLr_CLR(r) sal_memset(&((r)._clmac_eee_ctrl), 0, sizeof(CLMAC_EEE_CTRLr_t))
#define CLMAC_EEE_CTRLr_SET(r,i,d) (r).clmac_eee_ctrl[i] = d
#define CLMAC_EEE_CTRLr_GET(r,i) (r).clmac_eee_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_EEE_CTRLr_EEE_ENf_GET(r) (((r).clmac_eee_ctrl[0]) & 0x1)
#define CLMAC_EEE_CTRLr_EEE_ENf_SET(r,f) (r).clmac_eee_ctrl[0]=(((r).clmac_eee_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_EEE_CTRLr_RSVDf_GET(r) ((((r).clmac_eee_ctrl[0]) >> 1) & 0x1)
#define CLMAC_EEE_CTRLr_RSVDf_SET(r,f) (r).clmac_eee_ctrl[0]=(((r).clmac_eee_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLMAC_EEE_CTRL.
 */
#define READ_CLMAC_EEE_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_EEE_CTRLr_OFFSET,0,CLMAC_EEE_CTRLr_SIZE,(r._clmac_eee_ctrl))
#define WRITE_CLMAC_EEE_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_EEE_CTRLr_OFFSET,0,CLMAC_EEE_CTRLr_SIZE,&(r._clmac_eee_ctrl))

/*******************************************************************************
 * End of 'CLMAC_EEE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_EEE_TIMERS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_EEE_TIMERSr_OFFSET 0x10061b00

#define CLMAC_EEE_TIMERSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_EEE_TIMERS.
 */
typedef union CLMAC_EEE_TIMERSr_s {
	uint32_t v[2];
	uint32_t clmac_eee_timers[2];
	uint32_t _clmac_eee_timers;
} CLMAC_EEE_TIMERSr_t;

#define CLMAC_EEE_TIMERSr_CLR(r) sal_memset(&((r)._clmac_eee_timers), 0, sizeof(CLMAC_EEE_TIMERSr_t))
#define CLMAC_EEE_TIMERSr_SET(r,i,d) (r).clmac_eee_timers[i] = d
#define CLMAC_EEE_TIMERSr_GET(r,i) (r).clmac_eee_timers[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_LOf_GET(r) ((r).clmac_eee_timers[0])
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_LOf_SET(r,f) (r).clmac_eee_timers[0]=((uint32_t)f)
#define CLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_GET(r) ((r).clmac_eee_timers[0])
#define CLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_SET(r,f) (r).clmac_eee_timers[0]=((uint32_t)f)
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_HIf_GET(r) ((r).clmac_eee_timers[1])
#define CLMAC_EEE_TIMERSr_CLMAC_EEE_TIMERS_HIf_SET(r,f) (r).clmac_eee_timers[1]=((uint32_t)f)
#define CLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_GET(r) (((r).clmac_eee_timers[1]) & 0xffff)
#define CLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_SET(r,f) (r).clmac_eee_timers[1]=(((r).clmac_eee_timers[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CLMAC_EEE_TIMERSr_EEE_REF_COUNTf_GET(r) ((((r).clmac_eee_timers[1]) >> 16) & 0xffff)
#define CLMAC_EEE_TIMERSr_EEE_REF_COUNTf_SET(r,f) (r).clmac_eee_timers[1]=(((r).clmac_eee_timers[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CLMAC_EEE_TIMERS.
 */
#define READ_CLMAC_EEE_TIMERSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_EEE_TIMERSr_OFFSET,0,CLMAC_EEE_TIMERSr_SIZE,(r._clmac_eee_timers))
#define WRITE_CLMAC_EEE_TIMERSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_EEE_TIMERSr_OFFSET,0,CLMAC_EEE_TIMERSr_SIZE,&(r._clmac_eee_timers))

/*******************************************************************************
 * End of 'CLMAC_EEE_TIMERSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_FIFO_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_FIFO_STATUSr_OFFSET 0x10061700

#define CLMAC_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_FIFO_STATUS.
 */
typedef union CLMAC_FIFO_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_fifo_status[2];
	uint32_t _clmac_fifo_status;
} CLMAC_FIFO_STATUSr_t;

#define CLMAC_FIFO_STATUSr_CLR(r) sal_memset(&((r)._clmac_fifo_status), 0, sizeof(CLMAC_FIFO_STATUSr_t))
#define CLMAC_FIFO_STATUSr_SET(r,i,d) (r).clmac_fifo_status[i] = d
#define CLMAC_FIFO_STATUSr_GET(r,i) (r).clmac_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_FIFO_STATUSr_RSVD_1f_GET(r) (((r).clmac_fifo_status[0]) & 0x1)
#define CLMAC_FIFO_STATUSr_RSVD_1f_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_FIFO_STATUSr_RX_MSG_OVERFLOWf_GET(r) ((((r).clmac_fifo_status[0]) >> 1) & 0x1)
#define CLMAC_FIFO_STATUSr_RX_MSG_OVERFLOWf_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_FIFO_STATUSr_TX_PKT_UNDERFLOWf_GET(r) ((((r).clmac_fifo_status[0]) >> 2) & 0x1)
#define CLMAC_FIFO_STATUSr_TX_PKT_UNDERFLOWf_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_FIFO_STATUSr_TX_PKT_OVERFLOWf_GET(r) ((((r).clmac_fifo_status[0]) >> 3) & 0x1)
#define CLMAC_FIFO_STATUSr_TX_PKT_OVERFLOWf_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_FIFO_STATUSr_RSVD_2f_GET(r) ((((r).clmac_fifo_status[0]) >> 4) & 0x1)
#define CLMAC_FIFO_STATUSr_RSVD_2f_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_FIFO_STATUSr_TX_LLFC_MSG_OVERFLOWf_GET(r) ((((r).clmac_fifo_status[0]) >> 5) & 0x1)
#define CLMAC_FIFO_STATUSr_TX_LLFC_MSG_OVERFLOWf_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLMAC_FIFO_STATUSr_TX_TS_FIFO_OVERFLOWf_GET(r) ((((r).clmac_fifo_status[0]) >> 6) & 0x1)
#define CLMAC_FIFO_STATUSr_TX_TS_FIFO_OVERFLOWf_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CLMAC_FIFO_STATUSr_RX_PKT_OVERFLOWf_GET(r) ((((r).clmac_fifo_status[0]) >> 7) & 0x1)
#define CLMAC_FIFO_STATUSr_RX_PKT_OVERFLOWf_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CLMAC_FIFO_STATUSr_LINK_STATUSf_GET(r) ((((r).clmac_fifo_status[0]) >> 8) & 0x1)
#define CLMAC_FIFO_STATUSr_LINK_STATUSf_SET(r,f) (r).clmac_fifo_status[0]=(((r).clmac_fifo_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CLMAC_FIFO_STATUS.
 */
#define READ_CLMAC_FIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_FIFO_STATUSr_OFFSET,0,CLMAC_FIFO_STATUSr_SIZE,(r._clmac_fifo_status))
#define WRITE_CLMAC_FIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_FIFO_STATUSr_OFFSET,0,CLMAC_FIFO_STATUSr_SIZE,&(r._clmac_fifo_status))

/*******************************************************************************
 * End of 'CLMAC_FIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_GMII_EEE_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_GMII_EEE_CTRLr_OFFSET 0x10061f00

#define CLMAC_GMII_EEE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_GMII_EEE_CTRL.
 */
typedef union CLMAC_GMII_EEE_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_gmii_eee_ctrl[2];
	uint32_t _clmac_gmii_eee_ctrl;
} CLMAC_GMII_EEE_CTRLr_t;

#define CLMAC_GMII_EEE_CTRLr_CLR(r) sal_memset(&((r)._clmac_gmii_eee_ctrl), 0, sizeof(CLMAC_GMII_EEE_CTRLr_t))
#define CLMAC_GMII_EEE_CTRLr_SET(r,i,d) (r).clmac_gmii_eee_ctrl[i] = d
#define CLMAC_GMII_EEE_CTRLr_GET(r,i) (r).clmac_gmii_eee_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_THRESHOLDf_GET(r) (((r).clmac_gmii_eee_ctrl[0]) & 0xffff)
#define CLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_THRESHOLDf_SET(r,f) (r).clmac_gmii_eee_ctrl[0]=(((r).clmac_gmii_eee_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_MODE_ENf_GET(r) ((((r).clmac_gmii_eee_ctrl[0]) >> 16) & 0x1)
#define CLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_MODE_ENf_SET(r,f) (r).clmac_gmii_eee_ctrl[0]=(((r).clmac_gmii_eee_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access CLMAC_GMII_EEE_CTRL.
 */
#define READ_CLMAC_GMII_EEE_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_GMII_EEE_CTRLr_OFFSET,0,CLMAC_GMII_EEE_CTRLr_SIZE,(r._clmac_gmii_eee_ctrl))
#define WRITE_CLMAC_GMII_EEE_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_GMII_EEE_CTRLr_OFFSET,0,CLMAC_GMII_EEE_CTRLr_SIZE,&(r._clmac_gmii_eee_ctrl))

/*******************************************************************************
 * End of 'CLMAC_GMII_EEE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_HIGIG_HDR_0
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_HIGIG_HDR_0r_OFFSET 0x10061d00

#define CLMAC_HIGIG_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_HIGIG_HDR_0.
 */
typedef union CLMAC_HIGIG_HDR_0r_s {
	uint32_t v[2];
	uint32_t clmac_higig_hdr_0[2];
	uint32_t _clmac_higig_hdr_0;
} CLMAC_HIGIG_HDR_0r_t;

#define CLMAC_HIGIG_HDR_0r_CLR(r) sal_memset(&((r)._clmac_higig_hdr_0), 0, sizeof(CLMAC_HIGIG_HDR_0r_t))
#define CLMAC_HIGIG_HDR_0r_SET(r,i,d) (r).clmac_higig_hdr_0[i] = d
#define CLMAC_HIGIG_HDR_0r_GET(r,i) (r).clmac_higig_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_HIGIG_HDR_0r_HIGIG_HDR_0f_GET(r,a) bcmpmac_field_get((r).clmac_higig_hdr_0,0,63,a)
#define CLMAC_HIGIG_HDR_0r_HIGIG_HDR_0f_SET(r,a) bcmpmac_field_set((r).clmac_higig_hdr_0,0,63,a)
#define CLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_LOf_GET(r) ((r).clmac_higig_hdr_0[0])
#define CLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_LOf_SET(r,f) (r).clmac_higig_hdr_0[0]=((uint32_t)f)
#define CLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_HIf_GET(r) ((r).clmac_higig_hdr_0[1])
#define CLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_HIf_SET(r,f) (r).clmac_higig_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_HIGIG_HDR_0.
 */
#define READ_CLMAC_HIGIG_HDR_0r(pa,p,r) bcmpmac_read(pa,p,CLMAC_HIGIG_HDR_0r_OFFSET,0,CLMAC_HIGIG_HDR_0r_SIZE,(r._clmac_higig_hdr_0))
#define WRITE_CLMAC_HIGIG_HDR_0r(pa,p,r) bcmpmac_write(pa,p,CLMAC_HIGIG_HDR_0r_OFFSET,0,CLMAC_HIGIG_HDR_0r_SIZE,&(r._clmac_higig_hdr_0))

/*******************************************************************************
 * End of 'CLMAC_HIGIG_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_HIGIG_HDR_1
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_HIGIG_HDR_1r_OFFSET 0x10061e00

#define CLMAC_HIGIG_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_HIGIG_HDR_1.
 */
typedef union CLMAC_HIGIG_HDR_1r_s {
	uint32_t v[2];
	uint32_t clmac_higig_hdr_1[2];
	uint32_t _clmac_higig_hdr_1;
} CLMAC_HIGIG_HDR_1r_t;

#define CLMAC_HIGIG_HDR_1r_CLR(r) sal_memset(&((r)._clmac_higig_hdr_1), 0, sizeof(CLMAC_HIGIG_HDR_1r_t))
#define CLMAC_HIGIG_HDR_1r_SET(r,i,d) (r).clmac_higig_hdr_1[i] = d
#define CLMAC_HIGIG_HDR_1r_GET(r,i) (r).clmac_higig_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_HIGIG_HDR_1r_HIGIG_HDR_1f_GET(r,a) bcmpmac_field_get((r).clmac_higig_hdr_1,0,63,a)
#define CLMAC_HIGIG_HDR_1r_HIGIG_HDR_1f_SET(r,a) bcmpmac_field_set((r).clmac_higig_hdr_1,0,63,a)
#define CLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_LOf_GET(r) ((r).clmac_higig_hdr_1[0])
#define CLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_LOf_SET(r,f) (r).clmac_higig_hdr_1[0]=((uint32_t)f)
#define CLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_HIf_GET(r) ((r).clmac_higig_hdr_1[1])
#define CLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_HIf_SET(r,f) (r).clmac_higig_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access CLMAC_HIGIG_HDR_1.
 */
#define READ_CLMAC_HIGIG_HDR_1r(pa,p,r) bcmpmac_read(pa,p,CLMAC_HIGIG_HDR_1r_OFFSET,0,CLMAC_HIGIG_HDR_1r_SIZE,(r._clmac_higig_hdr_1))
#define WRITE_CLMAC_HIGIG_HDR_1r(pa,p,r) bcmpmac_write(pa,p,CLMAC_HIGIG_HDR_1r_OFFSET,0,CLMAC_HIGIG_HDR_1r_SIZE,&(r._clmac_higig_hdr_1))

/*******************************************************************************
 * End of 'CLMAC_HIGIG_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_LAG_FAILOVER_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_LAG_FAILOVER_STATUSr_OFFSET 0x10061900

#define CLMAC_LAG_FAILOVER_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_LAG_FAILOVER_STATUS.
 */
typedef union CLMAC_LAG_FAILOVER_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_lag_failover_status[2];
	uint32_t _clmac_lag_failover_status;
} CLMAC_LAG_FAILOVER_STATUSr_t;

#define CLMAC_LAG_FAILOVER_STATUSr_CLR(r) sal_memset(&((r)._clmac_lag_failover_status), 0, sizeof(CLMAC_LAG_FAILOVER_STATUSr_t))
#define CLMAC_LAG_FAILOVER_STATUSr_SET(r,i,d) (r).clmac_lag_failover_status[i] = d
#define CLMAC_LAG_FAILOVER_STATUSr_GET(r,i) (r).clmac_lag_failover_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_GET(r) (((r).clmac_lag_failover_status[0]) & 0x1)
#define CLMAC_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_SET(r,f) (r).clmac_lag_failover_status[0]=(((r).clmac_lag_failover_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_LAG_FAILOVER_STATUSr_RSVDf_GET(r) ((((r).clmac_lag_failover_status[0]) >> 1) & 0x1)
#define CLMAC_LAG_FAILOVER_STATUSr_RSVDf_SET(r,f) (r).clmac_lag_failover_status[0]=(((r).clmac_lag_failover_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLMAC_LAG_FAILOVER_STATUS.
 */
#define READ_CLMAC_LAG_FAILOVER_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_LAG_FAILOVER_STATUSr_OFFSET,0,CLMAC_LAG_FAILOVER_STATUSr_SIZE,(r._clmac_lag_failover_status))
#define WRITE_CLMAC_LAG_FAILOVER_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_LAG_FAILOVER_STATUSr_OFFSET,0,CLMAC_LAG_FAILOVER_STATUSr_SIZE,&(r._clmac_lag_failover_status))

/*******************************************************************************
 * End of 'CLMAC_LAG_FAILOVER_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_LLFC_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_LLFC_CTRLr_OFFSET 0x10061200

#define CLMAC_LLFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_LLFC_CTRL.
 */
typedef union CLMAC_LLFC_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_llfc_ctrl[2];
	uint32_t _clmac_llfc_ctrl;
} CLMAC_LLFC_CTRLr_t;

#define CLMAC_LLFC_CTRLr_CLR(r) sal_memset(&((r)._clmac_llfc_ctrl), 0, sizeof(CLMAC_LLFC_CTRLr_t))
#define CLMAC_LLFC_CTRLr_SET(r,i,d) (r).clmac_llfc_ctrl[i] = d
#define CLMAC_LLFC_CTRLr_GET(r,i) (r).clmac_llfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_LLFC_CTRLr_TX_LLFC_ENf_GET(r) (((r).clmac_llfc_ctrl[0]) & 0x1)
#define CLMAC_LLFC_CTRLr_TX_LLFC_ENf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_LLFC_CTRLr_RX_LLFC_ENf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 1) & 0x1)
#define CLMAC_LLFC_CTRLr_RX_LLFC_ENf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 2) & 0x1)
#define CLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 3) & 0x1)
#define CLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 4) & 0x1)
#define CLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 5) & 0x1)
#define CLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLMAC_LLFC_CTRLr_LLFC_IMGf_GET(r) ((((r).clmac_llfc_ctrl[0]) >> 6) & 0xff)
#define CLMAC_LLFC_CTRLr_LLFC_IMGf_SET(r,f) (r).clmac_llfc_ctrl[0]=(((r).clmac_llfc_ctrl[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))

/*
 * These macros can be used to access CLMAC_LLFC_CTRL.
 */
#define READ_CLMAC_LLFC_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_LLFC_CTRLr_OFFSET,0,CLMAC_LLFC_CTRLr_SIZE,(r._clmac_llfc_ctrl))
#define WRITE_CLMAC_LLFC_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_LLFC_CTRLr_OFFSET,0,CLMAC_LLFC_CTRLr_SIZE,&(r._clmac_llfc_ctrl))

/*******************************************************************************
 * End of 'CLMAC_LLFC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_MEM_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_MEM_CTRLr_OFFSET 0x10062d00

#define CLMAC_MEM_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_MEM_CTRL.
 */
typedef union CLMAC_MEM_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_mem_ctrl[2];
	uint32_t _clmac_mem_ctrl;
} CLMAC_MEM_CTRLr_t;

#define CLMAC_MEM_CTRLr_CLR(r) sal_memset(&((r)._clmac_mem_ctrl), 0, sizeof(CLMAC_MEM_CTRLr_t))
#define CLMAC_MEM_CTRLr_SET(r,i,d) (r).clmac_mem_ctrl[i] = d
#define CLMAC_MEM_CTRLr_GET(r,i) (r).clmac_mem_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_MEM_CTRLr_CLMAC_MEM_CTRL_LOf_GET(r) ((r).clmac_mem_ctrl[0])
#define CLMAC_MEM_CTRLr_CLMAC_MEM_CTRL_LOf_SET(r,f) (r).clmac_mem_ctrl[0]=((uint32_t)f)
#define CLMAC_MEM_CTRLr_RX_TS_MEM_CTRL_TMf_GET(r) (((r).clmac_mem_ctrl[0]) & 0xfff)
#define CLMAC_MEM_CTRLr_RX_TS_MEM_CTRL_TMf_SET(r,f) (r).clmac_mem_ctrl[0]=(((r).clmac_mem_ctrl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define CLMAC_MEM_CTRLr_RX_CDC_MEM_CTRL_TMf_GET(r) ((((r).clmac_mem_ctrl[0]) >> 12) & 0xfff)
#define CLMAC_MEM_CTRLr_RX_CDC_MEM_CTRL_TMf_SET(r,f) (r).clmac_mem_ctrl[0]=(((r).clmac_mem_ctrl[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define CLMAC_MEM_CTRLr_TX_CDC_MEM_CTRL_TMf_GET(r) bcmpmac_field32_get((r).clmac_mem_ctrl,24,35)
#define CLMAC_MEM_CTRLr_TX_CDC_MEM_CTRL_TMf_SET(r,f) bcmpmac_field32_set((r).clmac_mem_ctrl,24,35,f)
#define CLMAC_MEM_CTRLr_CLMAC_MEM_CTRL_HIf_GET(r) (((r).clmac_mem_ctrl[1]) & 0xf)
#define CLMAC_MEM_CTRLr_CLMAC_MEM_CTRL_HIf_SET(r,f) (r).clmac_mem_ctrl[1]=(((r).clmac_mem_ctrl[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CLMAC_MEM_CTRL.
 */
#define READ_CLMAC_MEM_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_MEM_CTRLr_OFFSET,0,CLMAC_MEM_CTRLr_SIZE,(r._clmac_mem_ctrl))
#define WRITE_CLMAC_MEM_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_MEM_CTRLr_OFFSET,0,CLMAC_MEM_CTRLr_SIZE,&(r._clmac_mem_ctrl))

/*******************************************************************************
 * End of 'CLMAC_MEM_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_MODE
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_MODEr_OFFSET 0x10060100

#define CLMAC_MODEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_MODE.
 */
typedef union CLMAC_MODEr_s {
	uint32_t v[2];
	uint32_t clmac_mode[2];
	uint32_t _clmac_mode;
} CLMAC_MODEr_t;

#define CLMAC_MODEr_CLR(r) sal_memset(&((r)._clmac_mode), 0, sizeof(CLMAC_MODEr_t))
#define CLMAC_MODEr_SET(r,i,d) (r).clmac_mode[i] = d
#define CLMAC_MODEr_GET(r,i) (r).clmac_mode[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_MODEr_HDR_MODEf_GET(r) (((r).clmac_mode[0]) & 0x7)
#define CLMAC_MODEr_HDR_MODEf_SET(r,f) (r).clmac_mode[0]=(((r).clmac_mode[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define CLMAC_MODEr_NO_SOP_FOR_CRC_HGf_GET(r) ((((r).clmac_mode[0]) >> 3) & 0x1)
#define CLMAC_MODEr_NO_SOP_FOR_CRC_HGf_SET(r,f) (r).clmac_mode[0]=(((r).clmac_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_MODEr_SPEED_MODEf_GET(r) ((((r).clmac_mode[0]) >> 4) & 0x7)
#define CLMAC_MODEr_SPEED_MODEf_SET(r,f) (r).clmac_mode[0]=(((r).clmac_mode[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))

/*
 * These macros can be used to access CLMAC_MODE.
 */
#define READ_CLMAC_MODEr(pa,p,r) bcmpmac_read(pa,p,CLMAC_MODEr_OFFSET,0,CLMAC_MODEr_SIZE,(r._clmac_mode))
#define WRITE_CLMAC_MODEr(pa,p,r) bcmpmac_write(pa,p,CLMAC_MODEr_OFFSET,0,CLMAC_MODEr_SIZE,&(r._clmac_mode))

/*******************************************************************************
 * End of 'CLMAC_MODEr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_PAUSE_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_PAUSE_CTRLr_OFFSET 0x10060d00

#define CLMAC_PAUSE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PAUSE_CTRL.
 */
typedef union CLMAC_PAUSE_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_pause_ctrl[2];
	uint32_t _clmac_pause_ctrl;
} CLMAC_PAUSE_CTRLr_t;

#define CLMAC_PAUSE_CTRLr_CLR(r) sal_memset(&((r)._clmac_pause_ctrl), 0, sizeof(CLMAC_PAUSE_CTRLr_t))
#define CLMAC_PAUSE_CTRLr_SET(r,i,d) (r).clmac_pause_ctrl[i] = d
#define CLMAC_PAUSE_CTRLr_GET(r,i) (r).clmac_pause_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_LOf_GET(r) ((r).clmac_pause_ctrl[0])
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_LOf_SET(r,f) (r).clmac_pause_ctrl[0]=((uint32_t)f)
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_GET(r) (((r).clmac_pause_ctrl[0]) & 0xffff)
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_GET(r) ((((r).clmac_pause_ctrl[0]) >> 16) & 0x1)
#define CLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define CLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_GET(r) ((((r).clmac_pause_ctrl[0]) >> 17) & 0x1)
#define CLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define CLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_GET(r) ((((r).clmac_pause_ctrl[0]) >> 18) & 0x1)
#define CLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define CLMAC_PAUSE_CTRLr_RSVD_1f_GET(r) ((((r).clmac_pause_ctrl[0]) >> 19) & 0x1)
#define CLMAC_PAUSE_CTRLr_RSVD_1f_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define CLMAC_PAUSE_CTRLr_RSVD_2f_GET(r) ((((r).clmac_pause_ctrl[0]) >> 20) & 0x1)
#define CLMAC_PAUSE_CTRLr_RSVD_2f_SET(r,f) (r).clmac_pause_ctrl[0]=(((r).clmac_pause_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define CLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_GET(r) bcmpmac_field32_get((r).clmac_pause_ctrl,21,36)
#define CLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_SET(r,f) bcmpmac_field32_set((r).clmac_pause_ctrl,21,36,f)
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_HIf_GET(r) (((r).clmac_pause_ctrl[1]) & 0x1f)
#define CLMAC_PAUSE_CTRLr_CLMAC_PAUSE_CTRL_HIf_SET(r,f) (r).clmac_pause_ctrl[1]=(((r).clmac_pause_ctrl[1] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access CLMAC_PAUSE_CTRL.
 */
#define READ_CLMAC_PAUSE_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_PAUSE_CTRLr_OFFSET,0,CLMAC_PAUSE_CTRLr_SIZE,(r._clmac_pause_ctrl))
#define WRITE_CLMAC_PAUSE_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_PAUSE_CTRLr_OFFSET,0,CLMAC_PAUSE_CTRLr_SIZE,&(r._clmac_pause_ctrl))

/*******************************************************************************
 * End of 'CLMAC_PAUSE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_PFC_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_PFC_CTRLr_OFFSET 0x10060e00

#define CLMAC_PFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_CTRL.
 */
typedef union CLMAC_PFC_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_pfc_ctrl[2];
	uint32_t _clmac_pfc_ctrl;
} CLMAC_PFC_CTRLr_t;

#define CLMAC_PFC_CTRLr_CLR(r) sal_memset(&((r)._clmac_pfc_ctrl), 0, sizeof(CLMAC_PFC_CTRLr_t))
#define CLMAC_PFC_CTRLr_SET(r,i,d) (r).clmac_pfc_ctrl[i] = d
#define CLMAC_PFC_CTRLr_GET(r,i) (r).clmac_pfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_GET(r) (((r).clmac_pfc_ctrl[0]) & 0xffff)
#define CLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_SET(r,f) (r).clmac_pfc_ctrl[0]=(((r).clmac_pfc_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_GET(r) ((((r).clmac_pfc_ctrl[0]) >> 16) & 0xffff)
#define CLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_SET(r,f) (r).clmac_pfc_ctrl[0]=(((r).clmac_pfc_ctrl[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define CLMAC_PFC_CTRLr_PFC_REFRESH_ENf_GET(r) (((r).clmac_pfc_ctrl[1]) & 0x1)
#define CLMAC_PFC_CTRLr_PFC_REFRESH_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_PFC_CTRLr_FORCE_PFC_XONf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 1) & 0x1)
#define CLMAC_PFC_CTRLr_FORCE_PFC_XONf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_PFC_CTRLr_RSVDf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 2) & 0x1)
#define CLMAC_PFC_CTRLr_RSVDf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_PFC_CTRLr_PFC_STATS_ENf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 3) & 0x1)
#define CLMAC_PFC_CTRLr_PFC_STATS_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_PFC_CTRLr_RX_PFC_ENf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 4) & 0x1)
#define CLMAC_PFC_CTRLr_RX_PFC_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_PFC_CTRLr_TX_PFC_ENf_GET(r) ((((r).clmac_pfc_ctrl[1]) >> 5) & 0x1)
#define CLMAC_PFC_CTRLr_TX_PFC_ENf_SET(r,f) (r).clmac_pfc_ctrl[1]=(((r).clmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access CLMAC_PFC_CTRL.
 */
#define READ_CLMAC_PFC_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_PFC_CTRLr_OFFSET,0,CLMAC_PFC_CTRLr_SIZE,(r._clmac_pfc_ctrl))
#define WRITE_CLMAC_PFC_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_PFC_CTRLr_OFFSET,0,CLMAC_PFC_CTRLr_SIZE,&(r._clmac_pfc_ctrl))

/*******************************************************************************
 * End of 'CLMAC_PFC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_PFC_DA
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_PFC_DAr_OFFSET 0x10061100

#define CLMAC_PFC_DAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_DA.
 */
typedef union CLMAC_PFC_DAr_s {
	uint32_t v[2];
	uint32_t clmac_pfc_da[2];
	uint32_t _clmac_pfc_da;
} CLMAC_PFC_DAr_t;

#define CLMAC_PFC_DAr_CLR(r) sal_memset(&((r)._clmac_pfc_da), 0, sizeof(CLMAC_PFC_DAr_t))
#define CLMAC_PFC_DAr_SET(r,i,d) (r).clmac_pfc_da[i] = d
#define CLMAC_PFC_DAr_GET(r,i) (r).clmac_pfc_da[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_DAr_PFC_MACDAf_GET(r,a) bcmpmac_field_get((r).clmac_pfc_da,0,47,a)
#define CLMAC_PFC_DAr_PFC_MACDAf_SET(r,a) bcmpmac_field_set((r).clmac_pfc_da,0,47,a)
#define CLMAC_PFC_DAr_PFC_MACDA_LOf_GET(r) ((r).clmac_pfc_da[0])
#define CLMAC_PFC_DAr_PFC_MACDA_LOf_SET(r,f) (r).clmac_pfc_da[0]=((uint32_t)f)
#define CLMAC_PFC_DAr_PFC_MACDA_HIf_GET(r) (((r).clmac_pfc_da[1]) & 0xffff)
#define CLMAC_PFC_DAr_PFC_MACDA_HIf_SET(r,f) (r).clmac_pfc_da[1]=(((r).clmac_pfc_da[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_PFC_DA.
 */
#define READ_CLMAC_PFC_DAr(pa,p,r) bcmpmac_read(pa,p,CLMAC_PFC_DAr_OFFSET,0,CLMAC_PFC_DAr_SIZE,(r._clmac_pfc_da))
#define WRITE_CLMAC_PFC_DAr(pa,p,r) bcmpmac_write(pa,p,CLMAC_PFC_DAr_OFFSET,0,CLMAC_PFC_DAr_SIZE,&(r._clmac_pfc_da))

/*******************************************************************************
 * End of 'CLMAC_PFC_DAr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_PFC_OPCODE
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_PFC_OPCODEr_OFFSET 0x10061000

#define CLMAC_PFC_OPCODEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_OPCODE.
 */
typedef union CLMAC_PFC_OPCODEr_s {
	uint32_t v[2];
	uint32_t clmac_pfc_opcode[2];
	uint32_t _clmac_pfc_opcode;
} CLMAC_PFC_OPCODEr_t;

#define CLMAC_PFC_OPCODEr_CLR(r) sal_memset(&((r)._clmac_pfc_opcode), 0, sizeof(CLMAC_PFC_OPCODEr_t))
#define CLMAC_PFC_OPCODEr_SET(r,i,d) (r).clmac_pfc_opcode[i] = d
#define CLMAC_PFC_OPCODEr_GET(r,i) (r).clmac_pfc_opcode[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_OPCODEr_PFC_OPCODEf_GET(r) (((r).clmac_pfc_opcode[0]) & 0xffff)
#define CLMAC_PFC_OPCODEr_PFC_OPCODEf_SET(r,f) (r).clmac_pfc_opcode[0]=(((r).clmac_pfc_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_PFC_OPCODE.
 */
#define READ_CLMAC_PFC_OPCODEr(pa,p,r) bcmpmac_read(pa,p,CLMAC_PFC_OPCODEr_OFFSET,0,CLMAC_PFC_OPCODEr_SIZE,(r._clmac_pfc_opcode))
#define WRITE_CLMAC_PFC_OPCODEr(pa,p,r) bcmpmac_write(pa,p,CLMAC_PFC_OPCODEr_OFFSET,0,CLMAC_PFC_OPCODEr_SIZE,&(r._clmac_pfc_opcode))

/*******************************************************************************
 * End of 'CLMAC_PFC_OPCODEr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_PFC_TYPE
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_PFC_TYPEr_OFFSET 0x10060f00

#define CLMAC_PFC_TYPEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_PFC_TYPE.
 */
typedef union CLMAC_PFC_TYPEr_s {
	uint32_t v[2];
	uint32_t clmac_pfc_type[2];
	uint32_t _clmac_pfc_type;
} CLMAC_PFC_TYPEr_t;

#define CLMAC_PFC_TYPEr_CLR(r) sal_memset(&((r)._clmac_pfc_type), 0, sizeof(CLMAC_PFC_TYPEr_t))
#define CLMAC_PFC_TYPEr_SET(r,i,d) (r).clmac_pfc_type[i] = d
#define CLMAC_PFC_TYPEr_GET(r,i) (r).clmac_pfc_type[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_PFC_TYPEr_PFC_ETH_TYPEf_GET(r) (((r).clmac_pfc_type[0]) & 0xffff)
#define CLMAC_PFC_TYPEr_PFC_ETH_TYPEf_SET(r,f) (r).clmac_pfc_type[0]=(((r).clmac_pfc_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_PFC_TYPE.
 */
#define READ_CLMAC_PFC_TYPEr(pa,p,r) bcmpmac_read(pa,p,CLMAC_PFC_TYPEr_OFFSET,0,CLMAC_PFC_TYPEr_SIZE,(r._clmac_pfc_type))
#define WRITE_CLMAC_PFC_TYPEr(pa,p,r) bcmpmac_write(pa,p,CLMAC_PFC_TYPEr_OFFSET,0,CLMAC_PFC_TYPEr_SIZE,&(r._clmac_pfc_type))

/*******************************************************************************
 * End of 'CLMAC_PFC_TYPEr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_CDC_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_CDC_ECC_STATUSr_OFFSET 0x10063200

#define CLMAC_RX_CDC_ECC_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_CDC_ECC_STATUS.
 */
typedef union CLMAC_RX_CDC_ECC_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_rx_cdc_ecc_status[2];
	uint32_t _clmac_rx_cdc_ecc_status;
} CLMAC_RX_CDC_ECC_STATUSr_t;

#define CLMAC_RX_CDC_ECC_STATUSr_CLR(r) sal_memset(&((r)._clmac_rx_cdc_ecc_status), 0, sizeof(CLMAC_RX_CDC_ECC_STATUSr_t))
#define CLMAC_RX_CDC_ECC_STATUSr_SET(r,i,d) (r).clmac_rx_cdc_ecc_status[i] = d
#define CLMAC_RX_CDC_ECC_STATUSr_GET(r,i) (r).clmac_rx_cdc_ecc_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_CDC_ECC_STATUSr_RX_CDC_SINGLE_BIT_ERRf_GET(r) (((r).clmac_rx_cdc_ecc_status[0]) & 0x1)
#define CLMAC_RX_CDC_ECC_STATUSr_RX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_rx_cdc_ecc_status[0]=(((r).clmac_rx_cdc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_RX_CDC_ECC_STATUSr_RX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_rx_cdc_ecc_status[0]) >> 1) & 0x1)
#define CLMAC_RX_CDC_ECC_STATUSr_RX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_rx_cdc_ecc_status[0]=(((r).clmac_rx_cdc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLMAC_RX_CDC_ECC_STATUS.
 */
#define READ_CLMAC_RX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_CDC_ECC_STATUSr_OFFSET,0,CLMAC_RX_CDC_ECC_STATUSr_SIZE,(r._clmac_rx_cdc_ecc_status))
#define WRITE_CLMAC_RX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_CDC_ECC_STATUSr_OFFSET,0,CLMAC_RX_CDC_ECC_STATUSr_SIZE,&(r._clmac_rx_cdc_ecc_status))

/*******************************************************************************
 * End of 'CLMAC_RX_CDC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_CTRLr_OFFSET 0x10060600

#define CLMAC_RX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_CTRL.
 */
typedef union CLMAC_RX_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_rx_ctrl[2];
	uint32_t _clmac_rx_ctrl;
} CLMAC_RX_CTRLr_t;

#define CLMAC_RX_CTRLr_CLR(r) sal_memset(&((r)._clmac_rx_ctrl), 0, sizeof(CLMAC_RX_CTRLr_t))
#define CLMAC_RX_CTRLr_SET(r,i,d) (r).clmac_rx_ctrl[i] = d
#define CLMAC_RX_CTRLr_GET(r,i) (r).clmac_rx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_CTRLr_RSVD_1f_GET(r) (((r).clmac_rx_ctrl[0]) & 0x1)
#define CLMAC_RX_CTRLr_RSVD_1f_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_RX_CTRLr_RX_ANY_STARTf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 1) & 0x1)
#define CLMAC_RX_CTRLr_RX_ANY_STARTf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_RX_CTRLr_STRIP_CRCf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 2) & 0x1)
#define CLMAC_RX_CTRLr_STRIP_CRCf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_RX_CTRLr_STRICT_PREAMBLEf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 3) & 0x1)
#define CLMAC_RX_CTRLr_STRICT_PREAMBLEf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_RX_CTRLr_RUNT_THRESHOLDf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 4) & 0x7f)
#define CLMAC_RX_CTRLr_RUNT_THRESHOLDf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32_t)0x7f << 4)) | ((((uint32_t)f) & 0x7f) << 4))
#define CLMAC_RX_CTRLr_RSVD_2f_GET(r) ((((r).clmac_rx_ctrl[0]) >> 11) & 0x1)
#define CLMAC_RX_CTRLr_RSVD_2f_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CLMAC_RX_CTRLr_PROCESS_VARIABLE_PREAMBLEf_GET(r) ((((r).clmac_rx_ctrl[0]) >> 12) & 0x1)
#define CLMAC_RX_CTRLr_PROCESS_VARIABLE_PREAMBLEf_SET(r,f) (r).clmac_rx_ctrl[0]=(((r).clmac_rx_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access CLMAC_RX_CTRL.
 */
#define READ_CLMAC_RX_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_CTRLr_OFFSET,0,CLMAC_RX_CTRLr_SIZE,(r._clmac_rx_ctrl))
#define WRITE_CLMAC_RX_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_CTRLr_OFFSET,0,CLMAC_RX_CTRLr_SIZE,&(r._clmac_rx_ctrl))

/*******************************************************************************
 * End of 'CLMAC_RX_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_LLFC_MSG_FIELDS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_LLFC_MSG_FIELDSr_OFFSET 0x10061400

#define CLMAC_RX_LLFC_MSG_FIELDSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_LLFC_MSG_FIELDS.
 */
typedef union CLMAC_RX_LLFC_MSG_FIELDSr_s {
	uint32_t v[2];
	uint32_t clmac_rx_llfc_msg_fields[2];
	uint32_t _clmac_rx_llfc_msg_fields;
} CLMAC_RX_LLFC_MSG_FIELDSr_t;

#define CLMAC_RX_LLFC_MSG_FIELDSr_CLR(r) sal_memset(&((r)._clmac_rx_llfc_msg_fields), 0, sizeof(CLMAC_RX_LLFC_MSG_FIELDSr_t))
#define CLMAC_RX_LLFC_MSG_FIELDSr_SET(r,i,d) (r).clmac_rx_llfc_msg_fields[i] = d
#define CLMAC_RX_LLFC_MSG_FIELDSr_GET(r,i) (r).clmac_rx_llfc_msg_fields[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_LOGICALf_GET(r) (((r).clmac_rx_llfc_msg_fields[0]) & 0xff)
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_LOGICALf_SET(r,f) (r).clmac_rx_llfc_msg_fields[0]=(((r).clmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_LOGICALf_GET(r) ((((r).clmac_rx_llfc_msg_fields[0]) >> 8) & 0xf)
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_LOGICALf_SET(r,f) (r).clmac_rx_llfc_msg_fields[0]=(((r).clmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_PHYSICALf_GET(r) ((((r).clmac_rx_llfc_msg_fields[0]) >> 12) & 0xff)
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_PHYSICALf_SET(r,f) (r).clmac_rx_llfc_msg_fields[0]=(((r).clmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xff << 12)) | ((((uint32_t)f) & 0xff) << 12))
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_PHYSICALf_GET(r) ((((r).clmac_rx_llfc_msg_fields[0]) >> 20) & 0xf)
#define CLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_PHYSICALf_SET(r,f) (r).clmac_rx_llfc_msg_fields[0]=(((r).clmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))

/*
 * These macros can be used to access CLMAC_RX_LLFC_MSG_FIELDS.
 */
#define READ_CLMAC_RX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_LLFC_MSG_FIELDSr_OFFSET,0,CLMAC_RX_LLFC_MSG_FIELDSr_SIZE,(r._clmac_rx_llfc_msg_fields))
#define WRITE_CLMAC_RX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_LLFC_MSG_FIELDSr_OFFSET,0,CLMAC_RX_LLFC_MSG_FIELDSr_SIZE,&(r._clmac_rx_llfc_msg_fields))

/*******************************************************************************
 * End of 'CLMAC_RX_LLFC_MSG_FIELDSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_LSS_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_LSS_CTRLr_OFFSET 0x10060a00

#define CLMAC_RX_LSS_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_LSS_CTRL.
 */
typedef union CLMAC_RX_LSS_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_rx_lss_ctrl[2];
	uint32_t _clmac_rx_lss_ctrl;
} CLMAC_RX_LSS_CTRLr_t;

#define CLMAC_RX_LSS_CTRLr_CLR(r) sal_memset(&((r)._clmac_rx_lss_ctrl), 0, sizeof(CLMAC_RX_LSS_CTRLr_t))
#define CLMAC_RX_LSS_CTRLr_SET(r,i,d) (r).clmac_rx_lss_ctrl[i] = d
#define CLMAC_RX_LSS_CTRLr_GET(r,i) (r).clmac_rx_lss_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_GET(r) (((r).clmac_rx_lss_ctrl[0]) & 0x1)
#define CLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 1) & 0x1)
#define CLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_RX_LSS_CTRLr_USE_EXTERNAL_FAULTS_FOR_TXf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 2) & 0x1)
#define CLMAC_RX_LSS_CTRLr_USE_EXTERNAL_FAULTS_FOR_TXf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 3) & 0x1)
#define CLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 4) & 0x1)
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 5) & 0x1)
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 6) & 0x1)
#define CLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_GET(r) ((((r).clmac_rx_lss_ctrl[0]) >> 7) & 0x1)
#define CLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_SET(r,f) (r).clmac_rx_lss_ctrl[0]=(((r).clmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CLMAC_RX_LSS_CTRL.
 */
#define READ_CLMAC_RX_LSS_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_LSS_CTRLr_OFFSET,0,CLMAC_RX_LSS_CTRLr_SIZE,(r._clmac_rx_lss_ctrl))
#define WRITE_CLMAC_RX_LSS_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_LSS_CTRLr_OFFSET,0,CLMAC_RX_LSS_CTRLr_SIZE,&(r._clmac_rx_lss_ctrl))

/*******************************************************************************
 * End of 'CLMAC_RX_LSS_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_LSS_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_LSS_STATUSr_OFFSET 0x10060b00

#define CLMAC_RX_LSS_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_LSS_STATUS.
 */
typedef union CLMAC_RX_LSS_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_rx_lss_status[2];
	uint32_t _clmac_rx_lss_status;
} CLMAC_RX_LSS_STATUSr_t;

#define CLMAC_RX_LSS_STATUSr_CLR(r) sal_memset(&((r)._clmac_rx_lss_status), 0, sizeof(CLMAC_RX_LSS_STATUSr_t))
#define CLMAC_RX_LSS_STATUSr_SET(r,i,d) (r).clmac_rx_lss_status[i] = d
#define CLMAC_RX_LSS_STATUSr_GET(r,i) (r).clmac_rx_lss_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_GET(r) (((r).clmac_rx_lss_status[0]) & 0x1)
#define CLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_SET(r,f) (r).clmac_rx_lss_status[0]=(((r).clmac_rx_lss_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_GET(r) ((((r).clmac_rx_lss_status[0]) >> 1) & 0x1)
#define CLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_SET(r,f) (r).clmac_rx_lss_status[0]=(((r).clmac_rx_lss_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).clmac_rx_lss_status[0]) >> 2) & 0x1)
#define CLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).clmac_rx_lss_status[0]=(((r).clmac_rx_lss_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CLMAC_RX_LSS_STATUS.
 */
#define READ_CLMAC_RX_LSS_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_LSS_STATUSr_OFFSET,0,CLMAC_RX_LSS_STATUSr_SIZE,(r._clmac_rx_lss_status))
#define WRITE_CLMAC_RX_LSS_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_LSS_STATUSr_OFFSET,0,CLMAC_RX_LSS_STATUSr_SIZE,&(r._clmac_rx_lss_status))

/*******************************************************************************
 * End of 'CLMAC_RX_LSS_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_MAC_SA
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_MAC_SAr_OFFSET 0x10060700

#define CLMAC_RX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_MAC_SA.
 */
typedef union CLMAC_RX_MAC_SAr_s {
	uint32_t v[2];
	uint32_t clmac_rx_mac_sa[2];
	uint32_t _clmac_rx_mac_sa;
} CLMAC_RX_MAC_SAr_t;

#define CLMAC_RX_MAC_SAr_CLR(r) sal_memset(&((r)._clmac_rx_mac_sa), 0, sizeof(CLMAC_RX_MAC_SAr_t))
#define CLMAC_RX_MAC_SAr_SET(r,i,d) (r).clmac_rx_mac_sa[i] = d
#define CLMAC_RX_MAC_SAr_GET(r,i) (r).clmac_rx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_MAC_SAr_RX_SAf_GET(r,a) bcmpmac_field_get((r).clmac_rx_mac_sa,0,47,a)
#define CLMAC_RX_MAC_SAr_RX_SAf_SET(r,a) bcmpmac_field_set((r).clmac_rx_mac_sa,0,47,a)
#define CLMAC_RX_MAC_SAr_SA_LOf_GET(r) ((r).clmac_rx_mac_sa[0])
#define CLMAC_RX_MAC_SAr_SA_LOf_SET(r,f) (r).clmac_rx_mac_sa[0]=((uint32_t)f)
#define CLMAC_RX_MAC_SAr_SA_HIf_GET(r) (((r).clmac_rx_mac_sa[1]) & 0xffff)
#define CLMAC_RX_MAC_SAr_SA_HIf_SET(r,f) (r).clmac_rx_mac_sa[1]=(((r).clmac_rx_mac_sa[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_RX_MAC_SA.
 */
#define READ_CLMAC_RX_MAC_SAr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_MAC_SAr_OFFSET,0,CLMAC_RX_MAC_SAr_SIZE,(r._clmac_rx_mac_sa))
#define WRITE_CLMAC_RX_MAC_SAr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_MAC_SAr_OFFSET,0,CLMAC_RX_MAC_SAr_SIZE,&(r._clmac_rx_mac_sa))

/*******************************************************************************
 * End of 'CLMAC_RX_MAC_SAr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_MAX_SIZE
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_MAX_SIZEr_OFFSET 0x10060800

#define CLMAC_RX_MAX_SIZEr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_MAX_SIZE.
 */
typedef union CLMAC_RX_MAX_SIZEr_s {
	uint32_t v[2];
	uint32_t clmac_rx_max_size[2];
	uint32_t _clmac_rx_max_size;
} CLMAC_RX_MAX_SIZEr_t;

#define CLMAC_RX_MAX_SIZEr_CLR(r) sal_memset(&((r)._clmac_rx_max_size), 0, sizeof(CLMAC_RX_MAX_SIZEr_t))
#define CLMAC_RX_MAX_SIZEr_SET(r,i,d) (r).clmac_rx_max_size[i] = d
#define CLMAC_RX_MAX_SIZEr_GET(r,i) (r).clmac_rx_max_size[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_GET(r) (((r).clmac_rx_max_size[0]) & 0x3fff)
#define CLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_SET(r,f) (r).clmac_rx_max_size[0]=(((r).clmac_rx_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CLMAC_RX_MAX_SIZE.
 */
#define READ_CLMAC_RX_MAX_SIZEr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_MAX_SIZEr_OFFSET,0,CLMAC_RX_MAX_SIZEr_SIZE,(r._clmac_rx_max_size))
#define WRITE_CLMAC_RX_MAX_SIZEr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_MAX_SIZEr_OFFSET,0,CLMAC_RX_MAX_SIZEr_SIZE,&(r._clmac_rx_max_size))

/*******************************************************************************
 * End of 'CLMAC_RX_MAX_SIZEr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_TS_MEM_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_TS_MEM_ECC_STATUSr_OFFSET 0x10063100

#define CLMAC_RX_TS_MEM_ECC_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_TS_MEM_ECC_STATUS.
 */
typedef union CLMAC_RX_TS_MEM_ECC_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_rx_ts_mem_ecc_status[2];
	uint32_t _clmac_rx_ts_mem_ecc_status;
} CLMAC_RX_TS_MEM_ECC_STATUSr_t;

#define CLMAC_RX_TS_MEM_ECC_STATUSr_CLR(r) sal_memset(&((r)._clmac_rx_ts_mem_ecc_status), 0, sizeof(CLMAC_RX_TS_MEM_ECC_STATUSr_t))
#define CLMAC_RX_TS_MEM_ECC_STATUSr_SET(r,i,d) (r).clmac_rx_ts_mem_ecc_status[i] = d
#define CLMAC_RX_TS_MEM_ECC_STATUSr_GET(r,i) (r).clmac_rx_ts_mem_ecc_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_TS_MEM_ECC_STATUSr_RX_TS_MEM_SINGLE_BIT_ERRf_GET(r) (((r).clmac_rx_ts_mem_ecc_status[0]) & 0x1)
#define CLMAC_RX_TS_MEM_ECC_STATUSr_RX_TS_MEM_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_rx_ts_mem_ecc_status[0]=(((r).clmac_rx_ts_mem_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_RX_TS_MEM_ECC_STATUSr_RX_TS_MEM_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_rx_ts_mem_ecc_status[0]) >> 1) & 0x1)
#define CLMAC_RX_TS_MEM_ECC_STATUSr_RX_TS_MEM_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_rx_ts_mem_ecc_status[0]=(((r).clmac_rx_ts_mem_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLMAC_RX_TS_MEM_ECC_STATUS.
 */
#define READ_CLMAC_RX_TS_MEM_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_TS_MEM_ECC_STATUSr_OFFSET,0,CLMAC_RX_TS_MEM_ECC_STATUSr_SIZE,(r._clmac_rx_ts_mem_ecc_status))
#define WRITE_CLMAC_RX_TS_MEM_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_TS_MEM_ECC_STATUSr_OFFSET,0,CLMAC_RX_TS_MEM_ECC_STATUSr_SIZE,&(r._clmac_rx_ts_mem_ecc_status))

/*******************************************************************************
 * End of 'CLMAC_RX_TS_MEM_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_RX_VLAN_TAG
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_RX_VLAN_TAGr_OFFSET 0x10060900

#define CLMAC_RX_VLAN_TAGr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_RX_VLAN_TAG.
 */
typedef union CLMAC_RX_VLAN_TAGr_s {
	uint32_t v[2];
	uint32_t clmac_rx_vlan_tag[2];
	uint32_t _clmac_rx_vlan_tag;
} CLMAC_RX_VLAN_TAGr_t;

#define CLMAC_RX_VLAN_TAGr_CLR(r) sal_memset(&((r)._clmac_rx_vlan_tag), 0, sizeof(CLMAC_RX_VLAN_TAGr_t))
#define CLMAC_RX_VLAN_TAGr_SET(r,i,d) (r).clmac_rx_vlan_tag[i] = d
#define CLMAC_RX_VLAN_TAGr_GET(r,i) (r).clmac_rx_vlan_tag[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_GET(r) (((r).clmac_rx_vlan_tag[0]) & 0xffff)
#define CLMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_SET(r,f) (r).clmac_rx_vlan_tag[0]=(((r).clmac_rx_vlan_tag[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_GET(r) ((((r).clmac_rx_vlan_tag[0]) >> 16) & 0xffff)
#define CLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_SET(r,f) (r).clmac_rx_vlan_tag[0]=(((r).clmac_rx_vlan_tag[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define CLMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_GET(r) (((r).clmac_rx_vlan_tag[1]) & 0x1)
#define CLMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_SET(r,f) (r).clmac_rx_vlan_tag[1]=(((r).clmac_rx_vlan_tag[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_GET(r) ((((r).clmac_rx_vlan_tag[1]) >> 1) & 0x1)
#define CLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_SET(r,f) (r).clmac_rx_vlan_tag[1]=(((r).clmac_rx_vlan_tag[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLMAC_RX_VLAN_TAG.
 */
#define READ_CLMAC_RX_VLAN_TAGr(pa,p,r) bcmpmac_read(pa,p,CLMAC_RX_VLAN_TAGr_OFFSET,0,CLMAC_RX_VLAN_TAGr_SIZE,(r._clmac_rx_vlan_tag))
#define WRITE_CLMAC_RX_VLAN_TAGr(pa,p,r) bcmpmac_write(pa,p,CLMAC_RX_VLAN_TAGr_OFFSET,0,CLMAC_RX_VLAN_TAGr_SIZE,&(r._clmac_rx_vlan_tag))

/*******************************************************************************
 * End of 'CLMAC_RX_VLAN_TAGr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_SPARE0
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_SPARE0r_OFFSET 0x10060200

#define CLMAC_SPARE0r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_SPARE0.
 */
typedef union CLMAC_SPARE0r_s {
	uint32_t v[2];
	uint32_t clmac_spare0[2];
	uint32_t _clmac_spare0;
} CLMAC_SPARE0r_t;

#define CLMAC_SPARE0r_CLR(r) sal_memset(&((r)._clmac_spare0), 0, sizeof(CLMAC_SPARE0r_t))
#define CLMAC_SPARE0r_SET(r,i,d) (r).clmac_spare0[i] = d
#define CLMAC_SPARE0r_GET(r,i) (r).clmac_spare0[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_SPARE0r_RSVDf_GET(r) (((r).clmac_spare0[0]) & 0xff)
#define CLMAC_SPARE0r_RSVDf_SET(r,f) (r).clmac_spare0[0]=(((r).clmac_spare0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CLMAC_SPARE0.
 */
#define READ_CLMAC_SPARE0r(pa,p,r) bcmpmac_read(pa,p,CLMAC_SPARE0r_OFFSET,0,CLMAC_SPARE0r_SIZE,(r._clmac_spare0))
#define WRITE_CLMAC_SPARE0r(pa,p,r) bcmpmac_write(pa,p,CLMAC_SPARE0r_OFFSET,0,CLMAC_SPARE0r_SIZE,&(r._clmac_spare0))

/*******************************************************************************
 * End of 'CLMAC_SPARE0r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_SPARE1
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_SPARE1r_OFFSET 0x10060300

#define CLMAC_SPARE1r_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_SPARE1.
 */
typedef union CLMAC_SPARE1r_s {
	uint32_t v[2];
	uint32_t clmac_spare1[2];
	uint32_t _clmac_spare1;
} CLMAC_SPARE1r_t;

#define CLMAC_SPARE1r_CLR(r) sal_memset(&((r)._clmac_spare1), 0, sizeof(CLMAC_SPARE1r_t))
#define CLMAC_SPARE1r_SET(r,i,d) (r).clmac_spare1[i] = d
#define CLMAC_SPARE1r_GET(r,i) (r).clmac_spare1[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_SPARE1r_RSVDf_GET(r) (((r).clmac_spare1[0]) & 0x3)
#define CLMAC_SPARE1r_RSVDf_SET(r,f) (r).clmac_spare1[0]=(((r).clmac_spare1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access CLMAC_SPARE1.
 */
#define READ_CLMAC_SPARE1r(pa,p,r) bcmpmac_read(pa,p,CLMAC_SPARE1r_OFFSET,0,CLMAC_SPARE1r_SIZE,(r._clmac_spare1))
#define WRITE_CLMAC_SPARE1r(pa,p,r) bcmpmac_write(pa,p,CLMAC_SPARE1r_OFFSET,0,CLMAC_SPARE1r_SIZE,&(r._clmac_spare1))

/*******************************************************************************
 * End of 'CLMAC_SPARE1r'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TIMESTAMP_ADJUST
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TIMESTAMP_ADJUSTr_OFFSET 0x10062000

#define CLMAC_TIMESTAMP_ADJUSTr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TIMESTAMP_ADJUST.
 */
typedef union CLMAC_TIMESTAMP_ADJUSTr_s {
	uint32_t v[2];
	uint32_t clmac_timestamp_adjust[2];
	uint32_t _clmac_timestamp_adjust;
} CLMAC_TIMESTAMP_ADJUSTr_t;

#define CLMAC_TIMESTAMP_ADJUSTr_CLR(r) sal_memset(&((r)._clmac_timestamp_adjust), 0, sizeof(CLMAC_TIMESTAMP_ADJUSTr_t))
#define CLMAC_TIMESTAMP_ADJUSTr_SET(r,i,d) (r).clmac_timestamp_adjust[i] = d
#define CLMAC_TIMESTAMP_ADJUSTr_GET(r,i) (r).clmac_timestamp_adjust[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TIMESTAMP_ADJUSTr_TS_OSTS_ADJUSTf_GET(r) (((r).clmac_timestamp_adjust[0]) & 0x1ff)
#define CLMAC_TIMESTAMP_ADJUSTr_TS_OSTS_ADJUSTf_SET(r,f) (r).clmac_timestamp_adjust[0]=(((r).clmac_timestamp_adjust[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define CLMAC_TIMESTAMP_ADJUSTr_TS_TSTS_ADJUSTf_GET(r) ((((r).clmac_timestamp_adjust[0]) >> 9) & 0x3f)
#define CLMAC_TIMESTAMP_ADJUSTr_TS_TSTS_ADJUSTf_SET(r,f) (r).clmac_timestamp_adjust[0]=(((r).clmac_timestamp_adjust[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define CLMAC_TIMESTAMP_ADJUSTr_TS_USE_CS_OFFSETf_GET(r) ((((r).clmac_timestamp_adjust[0]) >> 15) & 0x1)
#define CLMAC_TIMESTAMP_ADJUSTr_TS_USE_CS_OFFSETf_SET(r,f) (r).clmac_timestamp_adjust[0]=(((r).clmac_timestamp_adjust[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access CLMAC_TIMESTAMP_ADJUST.
 */
#define READ_CLMAC_TIMESTAMP_ADJUSTr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TIMESTAMP_ADJUSTr_OFFSET,0,CLMAC_TIMESTAMP_ADJUSTr_SIZE,(r._clmac_timestamp_adjust))
#define WRITE_CLMAC_TIMESTAMP_ADJUSTr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TIMESTAMP_ADJUSTr_OFFSET,0,CLMAC_TIMESTAMP_ADJUSTr_SIZE,&(r._clmac_timestamp_adjust))

/*******************************************************************************
 * End of 'CLMAC_TIMESTAMP_ADJUSTr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TXFIFO_CELL_CNT
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TXFIFO_CELL_CNTr_OFFSET 0x10062b00

#define CLMAC_TXFIFO_CELL_CNTr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TXFIFO_CELL_CNT.
 */
typedef union CLMAC_TXFIFO_CELL_CNTr_s {
	uint32_t v[2];
	uint32_t clmac_txfifo_cell_cnt[2];
	uint32_t _clmac_txfifo_cell_cnt;
} CLMAC_TXFIFO_CELL_CNTr_t;

#define CLMAC_TXFIFO_CELL_CNTr_CLR(r) sal_memset(&((r)._clmac_txfifo_cell_cnt), 0, sizeof(CLMAC_TXFIFO_CELL_CNTr_t))
#define CLMAC_TXFIFO_CELL_CNTr_SET(r,i,d) (r).clmac_txfifo_cell_cnt[i] = d
#define CLMAC_TXFIFO_CELL_CNTr_GET(r,i) (r).clmac_txfifo_cell_cnt[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_GET(r) (((r).clmac_txfifo_cell_cnt[0]) & 0x3f)
#define CLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_SET(r,f) (r).clmac_txfifo_cell_cnt[0]=(((r).clmac_txfifo_cell_cnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access CLMAC_TXFIFO_CELL_CNT.
 */
#define READ_CLMAC_TXFIFO_CELL_CNTr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TXFIFO_CELL_CNTr_OFFSET,0,CLMAC_TXFIFO_CELL_CNTr_SIZE,(r._clmac_txfifo_cell_cnt))
#define WRITE_CLMAC_TXFIFO_CELL_CNTr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TXFIFO_CELL_CNTr_OFFSET,0,CLMAC_TXFIFO_CELL_CNTr_SIZE,&(r._clmac_txfifo_cell_cnt))

/*******************************************************************************
 * End of 'CLMAC_TXFIFO_CELL_CNTr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TXFIFO_CELL_REQ_CNT
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TXFIFO_CELL_REQ_CNTr_OFFSET 0x10062c00

#define CLMAC_TXFIFO_CELL_REQ_CNTr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TXFIFO_CELL_REQ_CNT.
 */
typedef union CLMAC_TXFIFO_CELL_REQ_CNTr_s {
	uint32_t v[2];
	uint32_t clmac_txfifo_cell_req_cnt[2];
	uint32_t _clmac_txfifo_cell_req_cnt;
} CLMAC_TXFIFO_CELL_REQ_CNTr_t;

#define CLMAC_TXFIFO_CELL_REQ_CNTr_CLR(r) sal_memset(&((r)._clmac_txfifo_cell_req_cnt), 0, sizeof(CLMAC_TXFIFO_CELL_REQ_CNTr_t))
#define CLMAC_TXFIFO_CELL_REQ_CNTr_SET(r,i,d) (r).clmac_txfifo_cell_req_cnt[i] = d
#define CLMAC_TXFIFO_CELL_REQ_CNTr_GET(r,i) (r).clmac_txfifo_cell_req_cnt[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TXFIFO_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).clmac_txfifo_cell_req_cnt[0]) & 0x3f)
#define CLMAC_TXFIFO_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).clmac_txfifo_cell_req_cnt[0]=(((r).clmac_txfifo_cell_req_cnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access CLMAC_TXFIFO_CELL_REQ_CNT.
 */
#define READ_CLMAC_TXFIFO_CELL_REQ_CNTr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TXFIFO_CELL_REQ_CNTr_OFFSET,0,CLMAC_TXFIFO_CELL_REQ_CNTr_SIZE,(r._clmac_txfifo_cell_req_cnt))
#define WRITE_CLMAC_TXFIFO_CELL_REQ_CNTr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TXFIFO_CELL_REQ_CNTr_OFFSET,0,CLMAC_TXFIFO_CELL_REQ_CNTr_SIZE,&(r._clmac_txfifo_cell_req_cnt))

/*******************************************************************************
 * End of 'CLMAC_TXFIFO_CELL_REQ_CNTr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TX_CDC_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TX_CDC_ECC_STATUSr_OFFSET 0x10063300

#define CLMAC_TX_CDC_ECC_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_CDC_ECC_STATUS.
 */
typedef union CLMAC_TX_CDC_ECC_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_tx_cdc_ecc_status[2];
	uint32_t _clmac_tx_cdc_ecc_status;
} CLMAC_TX_CDC_ECC_STATUSr_t;

#define CLMAC_TX_CDC_ECC_STATUSr_CLR(r) sal_memset(&((r)._clmac_tx_cdc_ecc_status), 0, sizeof(CLMAC_TX_CDC_ECC_STATUSr_t))
#define CLMAC_TX_CDC_ECC_STATUSr_SET(r,i,d) (r).clmac_tx_cdc_ecc_status[i] = d
#define CLMAC_TX_CDC_ECC_STATUSr_GET(r,i) (r).clmac_tx_cdc_ecc_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_CDC_ECC_STATUSr_TX_CDC_SINGLE_BIT_ERRf_GET(r) (((r).clmac_tx_cdc_ecc_status[0]) & 0x1)
#define CLMAC_TX_CDC_ECC_STATUSr_TX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).clmac_tx_cdc_ecc_status[0]=(((r).clmac_tx_cdc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_TX_CDC_ECC_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).clmac_tx_cdc_ecc_status[0]) >> 1) & 0x1)
#define CLMAC_TX_CDC_ECC_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).clmac_tx_cdc_ecc_status[0]=(((r).clmac_tx_cdc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLMAC_TX_CDC_ECC_STATUS.
 */
#define READ_CLMAC_TX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TX_CDC_ECC_STATUSr_OFFSET,0,CLMAC_TX_CDC_ECC_STATUSr_SIZE,(r._clmac_tx_cdc_ecc_status))
#define WRITE_CLMAC_TX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TX_CDC_ECC_STATUSr_OFFSET,0,CLMAC_TX_CDC_ECC_STATUSr_SIZE,&(r._clmac_tx_cdc_ecc_status))

/*******************************************************************************
 * End of 'CLMAC_TX_CDC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TX_CRC_CORRUPT_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TX_CRC_CORRUPT_CTRLr_OFFSET 0x10062100

#define CLMAC_TX_CRC_CORRUPT_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_CRC_CORRUPT_CTRL.
 */
typedef union CLMAC_TX_CRC_CORRUPT_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_tx_crc_corrupt_ctrl[2];
	uint32_t _clmac_tx_crc_corrupt_ctrl;
} CLMAC_TX_CRC_CORRUPT_CTRLr_t;

#define CLMAC_TX_CRC_CORRUPT_CTRLr_CLR(r) sal_memset(&((r)._clmac_tx_crc_corrupt_ctrl), 0, sizeof(CLMAC_TX_CRC_CORRUPT_CTRLr_t))
#define CLMAC_TX_CRC_CORRUPT_CTRLr_SET(r,i,d) (r).clmac_tx_crc_corrupt_ctrl[i] = d
#define CLMAC_TX_CRC_CORRUPT_CTRLr_GET(r,i) (r).clmac_tx_crc_corrupt_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_CRC_CORRUPT_CTRLr_CLMAC_TX_CRC_CORRUPT_CTRL_LOf_GET(r) ((r).clmac_tx_crc_corrupt_ctrl[0])
#define CLMAC_TX_CRC_CORRUPT_CTRLr_CLMAC_TX_CRC_CORRUPT_CTRL_LOf_SET(r,f) (r).clmac_tx_crc_corrupt_ctrl[0]=((uint32_t)f)
#define CLMAC_TX_CRC_CORRUPT_CTRLr_TX_ERR_CORRUPTS_CRCf_GET(r) (((r).clmac_tx_crc_corrupt_ctrl[0]) & 0x1)
#define CLMAC_TX_CRC_CORRUPT_CTRLr_TX_ERR_CORRUPTS_CRCf_SET(r,f) (r).clmac_tx_crc_corrupt_ctrl[0]=(((r).clmac_tx_crc_corrupt_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPT_ENf_GET(r) ((((r).clmac_tx_crc_corrupt_ctrl[0]) >> 1) & 0x1)
#define CLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPT_ENf_SET(r,f) (r).clmac_tx_crc_corrupt_ctrl[0]=(((r).clmac_tx_crc_corrupt_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPTION_MODEf_GET(r) ((((r).clmac_tx_crc_corrupt_ctrl[0]) >> 2) & 0x1)
#define CLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPTION_MODEf_SET(r,f) (r).clmac_tx_crc_corrupt_ctrl[0]=(((r).clmac_tx_crc_corrupt_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_TX_CRC_CORRUPT_CTRLr_PROG_TX_CRCf_GET(r) bcmpmac_field32_get((r).clmac_tx_crc_corrupt_ctrl,3,34)
#define CLMAC_TX_CRC_CORRUPT_CTRLr_PROG_TX_CRCf_SET(r,f) bcmpmac_field32_set((r).clmac_tx_crc_corrupt_ctrl,3,34,f)
#define CLMAC_TX_CRC_CORRUPT_CTRLr_CLMAC_TX_CRC_CORRUPT_CTRL_HIf_GET(r) (((r).clmac_tx_crc_corrupt_ctrl[1]) & 0x7)
#define CLMAC_TX_CRC_CORRUPT_CTRLr_CLMAC_TX_CRC_CORRUPT_CTRL_HIf_SET(r,f) (r).clmac_tx_crc_corrupt_ctrl[1]=(((r).clmac_tx_crc_corrupt_ctrl[1] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access CLMAC_TX_CRC_CORRUPT_CTRL.
 */
#define READ_CLMAC_TX_CRC_CORRUPT_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TX_CRC_CORRUPT_CTRLr_OFFSET,0,CLMAC_TX_CRC_CORRUPT_CTRLr_SIZE,(r._clmac_tx_crc_corrupt_ctrl))
#define WRITE_CLMAC_TX_CRC_CORRUPT_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TX_CRC_CORRUPT_CTRLr_OFFSET,0,CLMAC_TX_CRC_CORRUPT_CTRLr_SIZE,&(r._clmac_tx_crc_corrupt_ctrl))

/*******************************************************************************
 * End of 'CLMAC_TX_CRC_CORRUPT_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TX_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TX_CTRLr_OFFSET 0x10060400

#define CLMAC_TX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_CTRL.
 */
typedef union CLMAC_TX_CTRLr_s {
	uint32_t v[2];
	uint32_t clmac_tx_ctrl[2];
	uint32_t _clmac_tx_ctrl;
} CLMAC_TX_CTRLr_t;

#define CLMAC_TX_CTRLr_CLR(r) sal_memset(&((r)._clmac_tx_ctrl), 0, sizeof(CLMAC_TX_CTRLr_t))
#define CLMAC_TX_CTRLr_SET(r,i,d) (r).clmac_tx_ctrl[i] = d
#define CLMAC_TX_CTRLr_GET(r,i) (r).clmac_tx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_LOf_GET(r) ((r).clmac_tx_ctrl[0])
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_LOf_SET(r,f) (r).clmac_tx_ctrl[0]=((uint32_t)f)
#define CLMAC_TX_CTRLr_CRC_MODEf_GET(r) (((r).clmac_tx_ctrl[0]) & 0x3)
#define CLMAC_TX_CTRLr_CRC_MODEf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define CLMAC_TX_CTRLr_DISCARDf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 2) & 0x1)
#define CLMAC_TX_CTRLr_DISCARDf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLMAC_TX_CTRLr_TX_ANY_STARTf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 3) & 0x1)
#define CLMAC_TX_CTRLr_TX_ANY_STARTf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLMAC_TX_CTRLr_PAD_ENf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 4) & 0x1)
#define CLMAC_TX_CTRLr_PAD_ENf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLMAC_TX_CTRLr_PAD_THRESHOLDf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 5) & 0x7f)
#define CLMAC_TX_CTRLr_PAD_THRESHOLDf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define CLMAC_TX_CTRLr_AVERAGE_IPGf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 12) & 0x7f)
#define CLMAC_TX_CTRLr_AVERAGE_IPGf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32_t)0x7f << 12)) | ((((uint32_t)f) & 0x7f) << 12))
#define CLMAC_TX_CTRLr_THROT_NUMf_GET(r) ((((r).clmac_tx_ctrl[0]) >> 19) & 0x3f)
#define CLMAC_TX_CTRLr_THROT_NUMf_SET(r,f) (r).clmac_tx_ctrl[0]=(((r).clmac_tx_ctrl[0] & ~((uint32_t)0x3f << 19)) | ((((uint32_t)f) & 0x3f) << 19))
#define CLMAC_TX_CTRLr_THROT_DENOMf_GET(r) bcmpmac_field32_get((r).clmac_tx_ctrl,25,32)
#define CLMAC_TX_CTRLr_THROT_DENOMf_SET(r,f) bcmpmac_field32_set((r).clmac_tx_ctrl,25,32,f)
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_HIf_GET(r) (((r).clmac_tx_ctrl[1]) & 0x3ff)
#define CLMAC_TX_CTRLr_CLMAC_TX_CTRL_HIf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define CLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_GET(r) ((((r).clmac_tx_ctrl[1]) >> 1) & 0xf)
#define CLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define CLMAC_TX_CTRLr_EP_DISCARDf_GET(r) ((((r).clmac_tx_ctrl[1]) >> 5) & 0x1)
#define CLMAC_TX_CTRLr_EP_DISCARDf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLMAC_TX_CTRLr_TX_THRESHOLDf_GET(r) ((((r).clmac_tx_ctrl[1]) >> 6) & 0xf)
#define CLMAC_TX_CTRLr_TX_THRESHOLDf_SET(r,f) (r).clmac_tx_ctrl[1]=(((r).clmac_tx_ctrl[1] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))

/*
 * These macros can be used to access CLMAC_TX_CTRL.
 */
#define READ_CLMAC_TX_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TX_CTRLr_OFFSET,0,CLMAC_TX_CTRLr_SIZE,(r._clmac_tx_ctrl))
#define WRITE_CLMAC_TX_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TX_CTRLr_OFFSET,0,CLMAC_TX_CTRLr_SIZE,&(r._clmac_tx_ctrl))

/*******************************************************************************
 * End of 'CLMAC_TX_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TX_LLFC_MSG_FIELDS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TX_LLFC_MSG_FIELDSr_OFFSET 0x10061300

#define CLMAC_TX_LLFC_MSG_FIELDSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_LLFC_MSG_FIELDS.
 */
typedef union CLMAC_TX_LLFC_MSG_FIELDSr_s {
	uint32_t v[2];
	uint32_t clmac_tx_llfc_msg_fields[2];
	uint32_t _clmac_tx_llfc_msg_fields;
} CLMAC_TX_LLFC_MSG_FIELDSr_t;

#define CLMAC_TX_LLFC_MSG_FIELDSr_CLR(r) sal_memset(&((r)._clmac_tx_llfc_msg_fields), 0, sizeof(CLMAC_TX_LLFC_MSG_FIELDSr_t))
#define CLMAC_TX_LLFC_MSG_FIELDSr_SET(r,i,d) (r).clmac_tx_llfc_msg_fields[i] = d
#define CLMAC_TX_LLFC_MSG_FIELDSr_GET(r,i) (r).clmac_tx_llfc_msg_fields[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_MSG_TYPE_LOGICALf_GET(r) (((r).clmac_tx_llfc_msg_fields[0]) & 0xff)
#define CLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_MSG_TYPE_LOGICALf_SET(r,f) (r).clmac_tx_llfc_msg_fields[0]=(((r).clmac_tx_llfc_msg_fields[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define CLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_FC_OBJ_LOGICALf_GET(r) ((((r).clmac_tx_llfc_msg_fields[0]) >> 8) & 0xf)
#define CLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_FC_OBJ_LOGICALf_SET(r,f) (r).clmac_tx_llfc_msg_fields[0]=(((r).clmac_tx_llfc_msg_fields[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define CLMAC_TX_LLFC_MSG_FIELDSr_LLFC_XOFF_TIMEf_GET(r) ((((r).clmac_tx_llfc_msg_fields[0]) >> 12) & 0xffff)
#define CLMAC_TX_LLFC_MSG_FIELDSr_LLFC_XOFF_TIMEf_SET(r,f) (r).clmac_tx_llfc_msg_fields[0]=(((r).clmac_tx_llfc_msg_fields[0] & ~((uint32_t)0xffff << 12)) | ((((uint32_t)f) & 0xffff) << 12))

/*
 * These macros can be used to access CLMAC_TX_LLFC_MSG_FIELDS.
 */
#define READ_CLMAC_TX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TX_LLFC_MSG_FIELDSr_OFFSET,0,CLMAC_TX_LLFC_MSG_FIELDSr_SIZE,(r._clmac_tx_llfc_msg_fields))
#define WRITE_CLMAC_TX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TX_LLFC_MSG_FIELDSr_OFFSET,0,CLMAC_TX_LLFC_MSG_FIELDSr_SIZE,&(r._clmac_tx_llfc_msg_fields))

/*******************************************************************************
 * End of 'CLMAC_TX_LLFC_MSG_FIELDSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TX_MAC_SA
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TX_MAC_SAr_OFFSET 0x10060500

#define CLMAC_TX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_MAC_SA.
 */
typedef union CLMAC_TX_MAC_SAr_s {
	uint32_t v[2];
	uint32_t clmac_tx_mac_sa[2];
	uint32_t _clmac_tx_mac_sa;
} CLMAC_TX_MAC_SAr_t;

#define CLMAC_TX_MAC_SAr_CLR(r) sal_memset(&((r)._clmac_tx_mac_sa), 0, sizeof(CLMAC_TX_MAC_SAr_t))
#define CLMAC_TX_MAC_SAr_SET(r,i,d) (r).clmac_tx_mac_sa[i] = d
#define CLMAC_TX_MAC_SAr_GET(r,i) (r).clmac_tx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_MAC_SAr_CTRL_SAf_GET(r,a) bcmpmac_field_get((r).clmac_tx_mac_sa,0,47,a)
#define CLMAC_TX_MAC_SAr_CTRL_SAf_SET(r,a) bcmpmac_field_set((r).clmac_tx_mac_sa,0,47,a)
#define CLMAC_TX_MAC_SAr_SA_LOf_GET(r) ((r).clmac_tx_mac_sa[0])
#define CLMAC_TX_MAC_SAr_SA_LOf_SET(r,f) (r).clmac_tx_mac_sa[0]=((uint32_t)f)
#define CLMAC_TX_MAC_SAr_SA_HIf_GET(r) (((r).clmac_tx_mac_sa[1]) & 0xffff)
#define CLMAC_TX_MAC_SAr_SA_HIf_SET(r,f) (r).clmac_tx_mac_sa[1]=(((r).clmac_tx_mac_sa[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_TX_MAC_SA.
 */
#define READ_CLMAC_TX_MAC_SAr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TX_MAC_SAr_OFFSET,0,CLMAC_TX_MAC_SAr_SIZE,(r._clmac_tx_mac_sa))
#define WRITE_CLMAC_TX_MAC_SAr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TX_MAC_SAr_OFFSET,0,CLMAC_TX_MAC_SAr_SIZE,&(r._clmac_tx_mac_sa))

/*******************************************************************************
 * End of 'CLMAC_TX_MAC_SAr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TX_TIMESTAMP_FIFO_DATA
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_OFFSET 0x10061500

#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
typedef union CLMAC_TX_TIMESTAMP_FIFO_DATAr_s {
	uint32_t v[2];
	uint32_t clmac_tx_timestamp_fifo_data[2];
	uint32_t _clmac_tx_timestamp_fifo_data;
} CLMAC_TX_TIMESTAMP_FIFO_DATAr_t;

#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_CLR(r) sal_memset(&((r)._clmac_tx_timestamp_fifo_data), 0, sizeof(CLMAC_TX_TIMESTAMP_FIFO_DATAr_t))
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SET(r,i,d) (r).clmac_tx_timestamp_fifo_data[i] = d
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_GET(r,i) (r).clmac_tx_timestamp_fifo_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_GET(r) ((r).clmac_tx_timestamp_fifo_data[0])
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_SET(r,f) (r).clmac_tx_timestamp_fifo_data[0]=((uint32_t)f)
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_GET(r) (((r).clmac_tx_timestamp_fifo_data[1]) & 0xffff)
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_SET(r,f) (r).clmac_tx_timestamp_fifo_data[1]=(((r).clmac_tx_timestamp_fifo_data[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_GET(r) ((((r).clmac_tx_timestamp_fifo_data[1]) >> 16) & 0x1)
#define CLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_SET(r,f) (r).clmac_tx_timestamp_fifo_data[1]=(((r).clmac_tx_timestamp_fifo_data[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access CLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
#define READ_CLMAC_TX_TIMESTAMP_FIFO_DATAr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TX_TIMESTAMP_FIFO_DATAr_OFFSET,0,CLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE,(r._clmac_tx_timestamp_fifo_data))
#define WRITE_CLMAC_TX_TIMESTAMP_FIFO_DATAr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TX_TIMESTAMP_FIFO_DATAr_OFFSET,0,CLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE,&(r._clmac_tx_timestamp_fifo_data))

/*******************************************************************************
 * End of 'CLMAC_TX_TIMESTAMP_FIFO_DATAr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_TX_TIMESTAMP_FIFO_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_OFFSET 0x10061600

#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
typedef union CLMAC_TX_TIMESTAMP_FIFO_STATUSr_s {
	uint32_t v[2];
	uint32_t clmac_tx_timestamp_fifo_status[2];
	uint32_t _clmac_tx_timestamp_fifo_status;
} CLMAC_TX_TIMESTAMP_FIFO_STATUSr_t;

#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_CLR(r) sal_memset(&((r)._clmac_tx_timestamp_fifo_status), 0, sizeof(CLMAC_TX_TIMESTAMP_FIFO_STATUSr_t))
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_SET(r,i,d) (r).clmac_tx_timestamp_fifo_status[i] = d
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_GET(r,i) (r).clmac_tx_timestamp_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_GET(r) (((r).clmac_tx_timestamp_fifo_status[0]) & 0x7)
#define CLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_SET(r,f) (r).clmac_tx_timestamp_fifo_status[0]=(((r).clmac_tx_timestamp_fifo_status[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access CLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
#define READ_CLMAC_TX_TIMESTAMP_FIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLMAC_TX_TIMESTAMP_FIFO_STATUSr_OFFSET,0,CLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE,(r._clmac_tx_timestamp_fifo_status))
#define WRITE_CLMAC_TX_TIMESTAMP_FIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLMAC_TX_TIMESTAMP_FIFO_STATUSr_OFFSET,0,CLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE,&(r._clmac_tx_timestamp_fifo_status))

/*******************************************************************************
 * End of 'CLMAC_TX_TIMESTAMP_FIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLMAC_VERSION_ID
 * BLOCKS:   CLPORT
 * SIZE:     64
 */
#define CLMAC_VERSION_IDr_OFFSET 0x10063500

#define CLMAC_VERSION_IDr_SIZE 8

/*
 * This structure should be used to declare and program CLMAC_VERSION_ID.
 */
typedef union CLMAC_VERSION_IDr_s {
	uint32_t v[2];
	uint32_t clmac_version_id[2];
	uint32_t _clmac_version_id;
} CLMAC_VERSION_IDr_t;

#define CLMAC_VERSION_IDr_CLR(r) sal_memset(&((r)._clmac_version_id), 0, sizeof(CLMAC_VERSION_IDr_t))
#define CLMAC_VERSION_IDr_SET(r,i,d) (r).clmac_version_id[i] = d
#define CLMAC_VERSION_IDr_GET(r,i) (r).clmac_version_id[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLMAC_VERSION_IDr_CLMAC_VERSIONf_GET(r) (((r).clmac_version_id[0]) & 0xffff)
#define CLMAC_VERSION_IDr_CLMAC_VERSIONf_SET(r,f) (r).clmac_version_id[0]=(((r).clmac_version_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLMAC_VERSION_ID.
 */
#define READ_CLMAC_VERSION_IDr(pa,p,r) bcmpmac_read(pa,p,CLMAC_VERSION_IDr_OFFSET,0,CLMAC_VERSION_IDr_SIZE,(r._clmac_version_id))
#define WRITE_CLMAC_VERSION_IDr(pa,p,r) bcmpmac_write(pa,p,CLMAC_VERSION_IDr_OFFSET,0,CLMAC_VERSION_IDr_SIZE,&(r._clmac_version_id))

/*******************************************************************************
 * End of 'CLMAC_VERSION_IDr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_CNTMAXSIZE
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_CNTMAXSIZEr_OFFSET 0x10020100

#define CLPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_CNTMAXSIZE.
 */
typedef union CLPORT_CNTMAXSIZEr_s {
	uint32_t v[1];
	uint32_t clport_cntmaxsize[1];
	uint32_t _clport_cntmaxsize;
} CLPORT_CNTMAXSIZEr_t;

#define CLPORT_CNTMAXSIZEr_CLR(r) (r).clport_cntmaxsize[0] = 0
#define CLPORT_CNTMAXSIZEr_SET(r,d) (r).clport_cntmaxsize[0] = d
#define CLPORT_CNTMAXSIZEr_GET(r) (r).clport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).clport_cntmaxsize[0]) & 0x3fff)
#define CLPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).clport_cntmaxsize[0]=(((r).clport_cntmaxsize[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CLPORT_CNTMAXSIZE.
 */
#define READ_CLPORT_CNTMAXSIZEr(pa,p,r) bcmpmac_read(pa,p,CLPORT_CNTMAXSIZEr_OFFSET,0,CLPORT_CNTMAXSIZEr_SIZE,(r._clport_cntmaxsize))
#define WRITE_CLPORT_CNTMAXSIZEr(pa,p,r) bcmpmac_write(pa,p,CLPORT_CNTMAXSIZEr_OFFSET,0,CLPORT_CNTMAXSIZEr_SIZE,&(r._clport_cntmaxsize))

/*******************************************************************************
 * End of 'CLPORT_CNTMAXSIZEr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_CONFIG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_CONFIGr_OFFSET 0x10020000

#define CLPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_CONFIG.
 */
typedef union CLPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t clport_config[1];
	uint32_t _clport_config;
} CLPORT_CONFIGr_t;

#define CLPORT_CONFIGr_CLR(r) (r).clport_config[0] = 0
#define CLPORT_CONFIGr_SET(r,d) (r).clport_config[0] = d
#define CLPORT_CONFIGr_GET(r) (r).clport_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_CONFIGr_RESERVED_0f_GET(r) (((r).clport_config[0]) & 0x1)
#define CLPORT_CONFIGr_RESERVED_0f_SET(r,f) (r).clport_config[0]=(((r).clport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_CONFIGr_MY_MODIDf_GET(r) ((((r).clport_config[0]) >> 1) & 0xff)
#define CLPORT_CONFIGr_MY_MODIDf_SET(r,f) (r).clport_config[0]=(((r).clport_config[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define CLPORT_CONFIGr_RESERVED_9f_GET(r) ((((r).clport_config[0]) >> 9) & 0x1)
#define CLPORT_CONFIGr_RESERVED_9f_SET(r,f) (r).clport_config[0]=(((r).clport_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CLPORT_CONFIGr_HIGIG_MODEf_GET(r) ((((r).clport_config[0]) >> 10) & 0x1)
#define CLPORT_CONFIGr_HIGIG_MODEf_SET(r,f) (r).clport_config[0]=(((r).clport_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define CLPORT_CONFIGr_HIGIG2_MODEf_GET(r) ((((r).clport_config[0]) >> 11) & 0x1)
#define CLPORT_CONFIGr_HIGIG2_MODEf_SET(r,f) (r).clport_config[0]=(((r).clport_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define CLPORT_CONFIGr_RESERVED_15_12f_GET(r) ((((r).clport_config[0]) >> 12) & 0xf)
#define CLPORT_CONFIGr_RESERVED_15_12f_SET(r,f) (r).clport_config[0]=(((r).clport_config[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access CLPORT_CONFIG.
 */
#define READ_CLPORT_CONFIGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_CONFIGr_OFFSET,0,CLPORT_CONFIGr_SIZE,(r._clport_config))
#define WRITE_CLPORT_CONFIGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_CONFIGr_OFFSET,0,CLPORT_CONFIGr_SIZE,&(r._clport_config))

/*******************************************************************************
 * End of 'CLPORT_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_ECC_CONTROL
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_ECC_CONTROLr_OFFSET 0x00021a00

#define CLPORT_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_ECC_CONTROL.
 */
typedef union CLPORT_ECC_CONTROLr_s {
	uint32_t v[1];
	uint32_t clport_ecc_control[1];
	uint32_t _clport_ecc_control;
} CLPORT_ECC_CONTROLr_t;

#define CLPORT_ECC_CONTROLr_CLR(r) (r).clport_ecc_control[0] = 0
#define CLPORT_ECC_CONTROLr_SET(r,d) (r).clport_ecc_control[0] = d
#define CLPORT_ECC_CONTROLr_GET(r) (r).clport_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_ECC_CONTROLr_MIB_TSC_MEM_ENf_GET(r) (((r).clport_ecc_control[0]) & 0x1)
#define CLPORT_ECC_CONTROLr_MIB_TSC_MEM_ENf_SET(r,f) (r).clport_ecc_control[0]=(((r).clport_ecc_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_ECC_CONTROLr_MIB_TSC0_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).clport_ecc_control[0]) >> 1) & 0x1)
#define CLPORT_ECC_CONTROLr_MIB_TSC0_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).clport_ecc_control[0]=(((r).clport_ecc_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_ECC_CONTROLr_MIB_TSC1_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).clport_ecc_control[0]) >> 2) & 0x1)
#define CLPORT_ECC_CONTROLr_MIB_TSC1_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).clport_ecc_control[0]=(((r).clport_ecc_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_ECC_CONTROLr_MIB_RSC_MEM_ENf_GET(r) ((((r).clport_ecc_control[0]) >> 3) & 0x1)
#define CLPORT_ECC_CONTROLr_MIB_RSC_MEM_ENf_SET(r,f) (r).clport_ecc_control[0]=(((r).clport_ecc_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLPORT_ECC_CONTROLr_MIB_RSC0_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).clport_ecc_control[0]) >> 4) & 0x1)
#define CLPORT_ECC_CONTROLr_MIB_RSC0_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).clport_ecc_control[0]=(((r).clport_ecc_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLPORT_ECC_CONTROLr_MIB_RSC1_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).clport_ecc_control[0]) >> 5) & 0x1)
#define CLPORT_ECC_CONTROLr_MIB_RSC1_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).clport_ecc_control[0]=(((r).clport_ecc_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access CLPORT_ECC_CONTROL.
 */
#define READ_CLPORT_ECC_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CLPORT_ECC_CONTROLr_OFFSET,0,CLPORT_ECC_CONTROLr_SIZE,(r._clport_ecc_control))
#define WRITE_CLPORT_ECC_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CLPORT_ECC_CONTROLr_OFFSET,0,CLPORT_ECC_CONTROLr_SIZE,&(r._clport_ecc_control))

/*******************************************************************************
 * End of 'CLPORT_ECC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_EEE_CLOCK_GATE
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_EEE_CLOCK_GATEr_OFFSET 0x00020e00

#define CLPORT_EEE_CLOCK_GATEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_EEE_CLOCK_GATE.
 */
typedef union CLPORT_EEE_CLOCK_GATEr_s {
	uint32_t v[1];
	uint32_t clport_eee_clock_gate[1];
	uint32_t _clport_eee_clock_gate;
} CLPORT_EEE_CLOCK_GATEr_t;

#define CLPORT_EEE_CLOCK_GATEr_CLR(r) (r).clport_eee_clock_gate[0] = 0
#define CLPORT_EEE_CLOCK_GATEr_SET(r,d) (r).clport_eee_clock_gate[0] = d
#define CLPORT_EEE_CLOCK_GATEr_GET(r) (r).clport_eee_clock_gate[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_EEE_CLOCK_GATEr_CORE0f_GET(r) (((r).clport_eee_clock_gate[0]) & 0x1)
#define CLPORT_EEE_CLOCK_GATEr_CORE0f_SET(r,f) (r).clport_eee_clock_gate[0]=(((r).clport_eee_clock_gate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CLPORT_EEE_CLOCK_GATE.
 */
#define READ_CLPORT_EEE_CLOCK_GATEr(pa,p,r) bcmpmac_read(pa,p,CLPORT_EEE_CLOCK_GATEr_OFFSET,0,CLPORT_EEE_CLOCK_GATEr_SIZE,(r._clport_eee_clock_gate))
#define WRITE_CLPORT_EEE_CLOCK_GATEr(pa,p,r) bcmpmac_write(pa,p,CLPORT_EEE_CLOCK_GATEr_OFFSET,0,CLPORT_EEE_CLOCK_GATEr_SIZE,&(r._clport_eee_clock_gate))

/*******************************************************************************
 * End of 'CLPORT_EEE_CLOCK_GATEr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_EEE_CORE0_CLOCK_GATE_COUNTER
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_OFFSET 0x00020f00

#define CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_EEE_CORE0_CLOCK_GATE_COUNTER.
 */
typedef union CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_s {
	uint32_t v[1];
	uint32_t clport_eee_core0_clock_gate_counter[1];
	uint32_t _clport_eee_core0_clock_gate_counter;
} CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_t;

#define CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_CLR(r) (r).clport_eee_core0_clock_gate_counter[0] = 0
#define CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SET(r,d) (r).clport_eee_core0_clock_gate_counter[0] = d
#define CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_GET(r) (r).clport_eee_core0_clock_gate_counter[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_COUNTf_GET(r) ((r).clport_eee_core0_clock_gate_counter[0])
#define CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_COUNTf_SET(r,f) (r).clport_eee_core0_clock_gate_counter[0]=((uint32_t)f)

/*
 * These macros can be used to access CLPORT_EEE_CORE0_CLOCK_GATE_COUNTER.
 */
#define READ_CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr(pa,p,r) bcmpmac_read(pa,p,CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_OFFSET,0,CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SIZE,(r._clport_eee_core0_clock_gate_counter))
#define WRITE_CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr(pa,p,r) bcmpmac_write(pa,p,CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_OFFSET,0,CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SIZE,&(r._clport_eee_core0_clock_gate_counter))

/*******************************************************************************
 * End of 'CLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_EEE_COUNTER_MODE
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_EEE_COUNTER_MODEr_OFFSET 0x10020300

#define CLPORT_EEE_COUNTER_MODEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_EEE_COUNTER_MODE.
 */
typedef union CLPORT_EEE_COUNTER_MODEr_s {
	uint32_t v[1];
	uint32_t clport_eee_counter_mode[1];
	uint32_t _clport_eee_counter_mode;
} CLPORT_EEE_COUNTER_MODEr_t;

#define CLPORT_EEE_COUNTER_MODEr_CLR(r) (r).clport_eee_counter_mode[0] = 0
#define CLPORT_EEE_COUNTER_MODEr_SET(r,d) (r).clport_eee_counter_mode[0] = d
#define CLPORT_EEE_COUNTER_MODEr_GET(r) (r).clport_eee_counter_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_EEE_COUNTER_MODEr_MODE_BITf_GET(r) (((r).clport_eee_counter_mode[0]) & 0x1)
#define CLPORT_EEE_COUNTER_MODEr_MODE_BITf_SET(r,f) (r).clport_eee_counter_mode[0]=(((r).clport_eee_counter_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CLPORT_EEE_COUNTER_MODE.
 */
#define READ_CLPORT_EEE_COUNTER_MODEr(pa,p,r) bcmpmac_read(pa,p,CLPORT_EEE_COUNTER_MODEr_OFFSET,0,CLPORT_EEE_COUNTER_MODEr_SIZE,(r._clport_eee_counter_mode))
#define WRITE_CLPORT_EEE_COUNTER_MODEr(pa,p,r) bcmpmac_write(pa,p,CLPORT_EEE_COUNTER_MODEr_OFFSET,0,CLPORT_EEE_COUNTER_MODEr_SIZE,&(r._clport_eee_counter_mode))

/*******************************************************************************
 * End of 'CLPORT_EEE_COUNTER_MODEr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_EEE_DURATION_TIMER_PULSE
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_EEE_DURATION_TIMER_PULSEr_OFFSET 0x00021200

#define CLPORT_EEE_DURATION_TIMER_PULSEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_EEE_DURATION_TIMER_PULSE.
 */
typedef union CLPORT_EEE_DURATION_TIMER_PULSEr_s {
	uint32_t v[1];
	uint32_t clport_eee_duration_timer_pulse[1];
	uint32_t _clport_eee_duration_timer_pulse;
} CLPORT_EEE_DURATION_TIMER_PULSEr_t;

#define CLPORT_EEE_DURATION_TIMER_PULSEr_CLR(r) (r).clport_eee_duration_timer_pulse[0] = 0
#define CLPORT_EEE_DURATION_TIMER_PULSEr_SET(r,d) (r).clport_eee_duration_timer_pulse[0] = d
#define CLPORT_EEE_DURATION_TIMER_PULSEr_GET(r) (r).clport_eee_duration_timer_pulse[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_EEE_DURATION_TIMER_PULSEr_CNT_VALUEf_GET(r) (((r).clport_eee_duration_timer_pulse[0]) & 0xff)
#define CLPORT_EEE_DURATION_TIMER_PULSEr_CNT_VALUEf_SET(r,f) (r).clport_eee_duration_timer_pulse[0]=(((r).clport_eee_duration_timer_pulse[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CLPORT_EEE_DURATION_TIMER_PULSE.
 */
#define READ_CLPORT_EEE_DURATION_TIMER_PULSEr(pa,p,r) bcmpmac_read(pa,p,CLPORT_EEE_DURATION_TIMER_PULSEr_OFFSET,0,CLPORT_EEE_DURATION_TIMER_PULSEr_SIZE,(r._clport_eee_duration_timer_pulse))
#define WRITE_CLPORT_EEE_DURATION_TIMER_PULSEr(pa,p,r) bcmpmac_write(pa,p,CLPORT_EEE_DURATION_TIMER_PULSEr_OFFSET,0,CLPORT_EEE_DURATION_TIMER_PULSEr_SIZE,&(r._clport_eee_duration_timer_pulse))

/*******************************************************************************
 * End of 'CLPORT_EEE_DURATION_TIMER_PULSEr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_ENABLE_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_ENABLE_REGr_OFFSET 0x00020b00

#define CLPORT_ENABLE_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_ENABLE_REG.
 */
typedef union CLPORT_ENABLE_REGr_s {
	uint32_t v[1];
	uint32_t clport_enable_reg[1];
	uint32_t _clport_enable_reg;
} CLPORT_ENABLE_REGr_t;

#define CLPORT_ENABLE_REGr_CLR(r) (r).clport_enable_reg[0] = 0
#define CLPORT_ENABLE_REGr_SET(r,d) (r).clport_enable_reg[0] = d
#define CLPORT_ENABLE_REGr_GET(r) (r).clport_enable_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_ENABLE_REGr_PORT0f_GET(r) (((r).clport_enable_reg[0]) & 0x1)
#define CLPORT_ENABLE_REGr_PORT0f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_ENABLE_REGr_PORT1f_GET(r) ((((r).clport_enable_reg[0]) >> 1) & 0x1)
#define CLPORT_ENABLE_REGr_PORT1f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_ENABLE_REGr_PORT2f_GET(r) ((((r).clport_enable_reg[0]) >> 2) & 0x1)
#define CLPORT_ENABLE_REGr_PORT2f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_ENABLE_REGr_PORT3f_GET(r) ((((r).clport_enable_reg[0]) >> 3) & 0x1)
#define CLPORT_ENABLE_REGr_PORT3f_SET(r,f) (r).clport_enable_reg[0]=(((r).clport_enable_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CLPORT_ENABLE_REG.
 */
#define READ_CLPORT_ENABLE_REGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_ENABLE_REGr_OFFSET,0,CLPORT_ENABLE_REGr_SIZE,(r._clport_enable_reg))
#define WRITE_CLPORT_ENABLE_REGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_ENABLE_REGr_OFFSET,0,CLPORT_ENABLE_REGr_SIZE,&(r._clport_enable_reg))

/*******************************************************************************
 * End of 'CLPORT_ENABLE_REGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_FAULT_LINK_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_FAULT_LINK_STATUSr_OFFSET 0x10020500

#define CLPORT_FAULT_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_FAULT_LINK_STATUS.
 */
typedef union CLPORT_FAULT_LINK_STATUSr_s {
	uint32_t v[1];
	uint32_t clport_fault_link_status[1];
	uint32_t _clport_fault_link_status;
} CLPORT_FAULT_LINK_STATUSr_t;

#define CLPORT_FAULT_LINK_STATUSr_CLR(r) (r).clport_fault_link_status[0] = 0
#define CLPORT_FAULT_LINK_STATUSr_SET(r,d) (r).clport_fault_link_status[0] = d
#define CLPORT_FAULT_LINK_STATUSr_GET(r) (r).clport_fault_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_GET(r) (((r).clport_fault_link_status[0]) & 0x1)
#define CLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_SET(r,f) (r).clport_fault_link_status[0]=(((r).clport_fault_link_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_GET(r) ((((r).clport_fault_link_status[0]) >> 1) & 0x1)
#define CLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_SET(r,f) (r).clport_fault_link_status[0]=(((r).clport_fault_link_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLPORT_FAULT_LINK_STATUS.
 */
#define READ_CLPORT_FAULT_LINK_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLPORT_FAULT_LINK_STATUSr_OFFSET,0,CLPORT_FAULT_LINK_STATUSr_SIZE,(r._clport_fault_link_status))
#define WRITE_CLPORT_FAULT_LINK_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLPORT_FAULT_LINK_STATUSr_OFFSET,0,CLPORT_FAULT_LINK_STATUSr_SIZE,&(r._clport_fault_link_status))

/*******************************************************************************
 * End of 'CLPORT_FAULT_LINK_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_FLOW_CONTROL_CONFIG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_FLOW_CONTROL_CONFIGr_OFFSET 0x10020700

#define CLPORT_FLOW_CONTROL_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_FLOW_CONTROL_CONFIG.
 */
typedef union CLPORT_FLOW_CONTROL_CONFIGr_s {
	uint32_t v[1];
	uint32_t clport_flow_control_config[1];
	uint32_t _clport_flow_control_config;
} CLPORT_FLOW_CONTROL_CONFIGr_t;

#define CLPORT_FLOW_CONTROL_CONFIGr_CLR(r) (r).clport_flow_control_config[0] = 0
#define CLPORT_FLOW_CONTROL_CONFIGr_SET(r,d) (r).clport_flow_control_config[0] = d
#define CLPORT_FLOW_CONTROL_CONFIGr_GET(r) (r).clport_flow_control_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_FLOW_CONTROL_CONFIGr_PARALLEL_FC_ENf_GET(r) (((r).clport_flow_control_config[0]) & 0x1)
#define CLPORT_FLOW_CONTROL_CONFIGr_PARALLEL_FC_ENf_SET(r,f) (r).clport_flow_control_config[0]=(((r).clport_flow_control_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_FLOW_CONTROL_CONFIGr_MERGE_MODE_ENf_GET(r) ((((r).clport_flow_control_config[0]) >> 1) & 0x1)
#define CLPORT_FLOW_CONTROL_CONFIGr_MERGE_MODE_ENf_SET(r,f) (r).clport_flow_control_config[0]=(((r).clport_flow_control_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLPORT_FLOW_CONTROL_CONFIG.
 */
#define READ_CLPORT_FLOW_CONTROL_CONFIGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_FLOW_CONTROL_CONFIGr_OFFSET,0,CLPORT_FLOW_CONTROL_CONFIGr_SIZE,(r._clport_flow_control_config))
#define WRITE_CLPORT_FLOW_CONTROL_CONFIGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_FLOW_CONTROL_CONFIGr_OFFSET,0,CLPORT_FLOW_CONTROL_CONFIGr_SIZE,&(r._clport_flow_control_config))

/*******************************************************************************
 * End of 'CLPORT_FLOW_CONTROL_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_FORCE_DOUBLE_BIT_ERROR
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_OFFSET 0x00021b00

#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_FORCE_DOUBLE_BIT_ERROR.
 */
typedef union CLPORT_FORCE_DOUBLE_BIT_ERRORr_s {
	uint32_t v[1];
	uint32_t clport_force_double_bit_error[1];
	uint32_t _clport_force_double_bit_error;
} CLPORT_FORCE_DOUBLE_BIT_ERRORr_t;

#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_CLR(r) (r).clport_force_double_bit_error[0] = 0
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_SET(r,d) (r).clport_force_double_bit_error[0] = d
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_GET(r) (r).clport_force_double_bit_error[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC0_MEMf_GET(r) (((r).clport_force_double_bit_error[0]) & 0x1)
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC0_MEMf_SET(r,f) (r).clport_force_double_bit_error[0]=(((r).clport_force_double_bit_error[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC1_MEMf_GET(r) ((((r).clport_force_double_bit_error[0]) >> 1) & 0x1)
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC1_MEMf_SET(r,f) (r).clport_force_double_bit_error[0]=(((r).clport_force_double_bit_error[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC0_MEMf_GET(r) ((((r).clport_force_double_bit_error[0]) >> 2) & 0x1)
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC0_MEMf_SET(r,f) (r).clport_force_double_bit_error[0]=(((r).clport_force_double_bit_error[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC1_MEMf_GET(r) ((((r).clport_force_double_bit_error[0]) >> 3) & 0x1)
#define CLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC1_MEMf_SET(r,f) (r).clport_force_double_bit_error[0]=(((r).clport_force_double_bit_error[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CLPORT_FORCE_DOUBLE_BIT_ERROR.
 */
#define READ_CLPORT_FORCE_DOUBLE_BIT_ERRORr(pa,p,r) bcmpmac_read(pa,p,CLPORT_FORCE_DOUBLE_BIT_ERRORr_OFFSET,0,CLPORT_FORCE_DOUBLE_BIT_ERRORr_SIZE,(r._clport_force_double_bit_error))
#define WRITE_CLPORT_FORCE_DOUBLE_BIT_ERRORr(pa,p,r) bcmpmac_write(pa,p,CLPORT_FORCE_DOUBLE_BIT_ERRORr_OFFSET,0,CLPORT_FORCE_DOUBLE_BIT_ERRORr_SIZE,&(r._clport_force_double_bit_error))

/*******************************************************************************
 * End of 'CLPORT_FORCE_DOUBLE_BIT_ERRORr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_FORCE_SINGLE_BIT_ERROR
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_OFFSET 0x00021c00

#define CLPORT_FORCE_SINGLE_BIT_ERRORr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_FORCE_SINGLE_BIT_ERROR.
 */
typedef union CLPORT_FORCE_SINGLE_BIT_ERRORr_s {
	uint32_t v[1];
	uint32_t clport_force_single_bit_error[1];
	uint32_t _clport_force_single_bit_error;
} CLPORT_FORCE_SINGLE_BIT_ERRORr_t;

#define CLPORT_FORCE_SINGLE_BIT_ERRORr_CLR(r) (r).clport_force_single_bit_error[0] = 0
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_SET(r,d) (r).clport_force_single_bit_error[0] = d
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_GET(r) (r).clport_force_single_bit_error[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC0_MEMf_GET(r) (((r).clport_force_single_bit_error[0]) & 0x1)
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC0_MEMf_SET(r,f) (r).clport_force_single_bit_error[0]=(((r).clport_force_single_bit_error[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC1_MEMf_GET(r) ((((r).clport_force_single_bit_error[0]) >> 1) & 0x1)
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC1_MEMf_SET(r,f) (r).clport_force_single_bit_error[0]=(((r).clport_force_single_bit_error[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC0_MEMf_GET(r) ((((r).clport_force_single_bit_error[0]) >> 2) & 0x1)
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC0_MEMf_SET(r,f) (r).clport_force_single_bit_error[0]=(((r).clport_force_single_bit_error[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC1_MEMf_GET(r) ((((r).clport_force_single_bit_error[0]) >> 3) & 0x1)
#define CLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC1_MEMf_SET(r,f) (r).clport_force_single_bit_error[0]=(((r).clport_force_single_bit_error[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CLPORT_FORCE_SINGLE_BIT_ERROR.
 */
#define READ_CLPORT_FORCE_SINGLE_BIT_ERRORr(pa,p,r) bcmpmac_read(pa,p,CLPORT_FORCE_SINGLE_BIT_ERRORr_OFFSET,0,CLPORT_FORCE_SINGLE_BIT_ERRORr_SIZE,(r._clport_force_single_bit_error))
#define WRITE_CLPORT_FORCE_SINGLE_BIT_ERRORr(pa,p,r) bcmpmac_write(pa,p,CLPORT_FORCE_SINGLE_BIT_ERRORr_OFFSET,0,CLPORT_FORCE_SINGLE_BIT_ERRORr_SIZE,&(r._clport_force_single_bit_error))

/*******************************************************************************
 * End of 'CLPORT_FORCE_SINGLE_BIT_ERRORr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_INTR_ENABLE
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_INTR_ENABLEr_OFFSET 0x00022a00

#define CLPORT_INTR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_INTR_ENABLE.
 */
typedef union CLPORT_INTR_ENABLEr_s {
	uint32_t v[1];
	uint32_t clport_intr_enable[1];
	uint32_t _clport_intr_enable;
} CLPORT_INTR_ENABLEr_t;

#define CLPORT_INTR_ENABLEr_CLR(r) (r).clport_intr_enable[0] = 0
#define CLPORT_INTR_ENABLEr_SET(r,d) (r).clport_intr_enable[0] = d
#define CLPORT_INTR_ENABLEr_GET(r) (r).clport_intr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_INTR_ENABLEr_MIB_TX_MEM_ERRf_GET(r) (((r).clport_intr_enable[0]) & 0x1)
#define CLPORT_INTR_ENABLEr_MIB_TX_MEM_ERRf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_INTR_ENABLEr_MIB_RX_MEM_ERRf_GET(r) ((((r).clport_intr_enable[0]) >> 1) & 0x1)
#define CLPORT_INTR_ENABLEr_MIB_RX_MEM_ERRf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_INTR_ENABLEr_MAC_TX_CDC_MEM_ERRf_GET(r) ((((r).clport_intr_enable[0]) >> 2) & 0x1)
#define CLPORT_INTR_ENABLEr_MAC_TX_CDC_MEM_ERRf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_INTR_ENABLEr_MAC_RX_CDC_MEM_ERRf_GET(r) ((((r).clport_intr_enable[0]) >> 3) & 0x1)
#define CLPORT_INTR_ENABLEr_MAC_RX_CDC_MEM_ERRf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLPORT_INTR_ENABLEr_MAC_RX_TS_CDC_MEM_ERRf_GET(r) ((((r).clport_intr_enable[0]) >> 4) & 0x1)
#define CLPORT_INTR_ENABLEr_MAC_RX_TS_CDC_MEM_ERRf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLPORT_INTR_ENABLEr_TSC_ERRf_GET(r) ((((r).clport_intr_enable[0]) >> 5) & 0x1)
#define CLPORT_INTR_ENABLEr_TSC_ERRf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLPORT_INTR_ENABLEr_PMD_ERRf_GET(r) ((((r).clport_intr_enable[0]) >> 6) & 0x1)
#define CLPORT_INTR_ENABLEr_PMD_ERRf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CLPORT_INTR_ENABLEr_RX_FLOWCONTROL_REQ_FULLf_GET(r) ((((r).clport_intr_enable[0]) >> 7) & 0xf)
#define CLPORT_INTR_ENABLEr_RX_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).clport_intr_enable[0]=(((r).clport_intr_enable[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access CLPORT_INTR_ENABLE.
 */
#define READ_CLPORT_INTR_ENABLEr(pa,p,r) bcmpmac_read(pa,p,CLPORT_INTR_ENABLEr_OFFSET,0,CLPORT_INTR_ENABLEr_SIZE,(r._clport_intr_enable))
#define WRITE_CLPORT_INTR_ENABLEr(pa,p,r) bcmpmac_write(pa,p,CLPORT_INTR_ENABLEr_OFFSET,0,CLPORT_INTR_ENABLEr_SIZE,&(r._clport_intr_enable))

/*******************************************************************************
 * End of 'CLPORT_INTR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_INTR_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_INTR_STATUSr_OFFSET 0x00022900

#define CLPORT_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_INTR_STATUS.
 */
typedef union CLPORT_INTR_STATUSr_s {
	uint32_t v[1];
	uint32_t clport_intr_status[1];
	uint32_t _clport_intr_status;
} CLPORT_INTR_STATUSr_t;

#define CLPORT_INTR_STATUSr_CLR(r) (r).clport_intr_status[0] = 0
#define CLPORT_INTR_STATUSr_SET(r,d) (r).clport_intr_status[0] = d
#define CLPORT_INTR_STATUSr_GET(r) (r).clport_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_INTR_STATUSr_MIB_TX_MEM_ERRf_GET(r) (((r).clport_intr_status[0]) & 0x1)
#define CLPORT_INTR_STATUSr_MIB_TX_MEM_ERRf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_INTR_STATUSr_MIB_RX_MEM_ERRf_GET(r) ((((r).clport_intr_status[0]) >> 1) & 0x1)
#define CLPORT_INTR_STATUSr_MIB_RX_MEM_ERRf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_INTR_STATUSr_MAC_TX_CDC_MEM_ERRf_GET(r) ((((r).clport_intr_status[0]) >> 2) & 0x1)
#define CLPORT_INTR_STATUSr_MAC_TX_CDC_MEM_ERRf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_INTR_STATUSr_MAC_RX_CDC_MEM_ERRf_GET(r) ((((r).clport_intr_status[0]) >> 3) & 0x1)
#define CLPORT_INTR_STATUSr_MAC_RX_CDC_MEM_ERRf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLPORT_INTR_STATUSr_MAC_RX_TS_CDC_MEM_ERRf_GET(r) ((((r).clport_intr_status[0]) >> 4) & 0x1)
#define CLPORT_INTR_STATUSr_MAC_RX_TS_CDC_MEM_ERRf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define CLPORT_INTR_STATUSr_TSC_ERRf_GET(r) ((((r).clport_intr_status[0]) >> 5) & 0x1)
#define CLPORT_INTR_STATUSr_TSC_ERRf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define CLPORT_INTR_STATUSr_PMD_ERRf_GET(r) ((((r).clport_intr_status[0]) >> 6) & 0x1)
#define CLPORT_INTR_STATUSr_PMD_ERRf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CLPORT_INTR_STATUSr_RX_FLOWCONTROL_REQ_FULLf_GET(r) ((((r).clport_intr_status[0]) >> 7) & 0xf)
#define CLPORT_INTR_STATUSr_RX_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).clport_intr_status[0]=(((r).clport_intr_status[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access CLPORT_INTR_STATUS.
 */
#define READ_CLPORT_INTR_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLPORT_INTR_STATUSr_OFFSET,0,CLPORT_INTR_STATUSr_SIZE,(r._clport_intr_status))
#define WRITE_CLPORT_INTR_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLPORT_INTR_STATUSr_OFFSET,0,CLPORT_INTR_STATUSr_SIZE,&(r._clport_intr_status))

/*******************************************************************************
 * End of 'CLPORT_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_LAG_FAILOVER_CONFIG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_LAG_FAILOVER_CONFIGr_OFFSET 0x10020200

#define CLPORT_LAG_FAILOVER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_LAG_FAILOVER_CONFIG.
 */
typedef union CLPORT_LAG_FAILOVER_CONFIGr_s {
	uint32_t v[1];
	uint32_t clport_lag_failover_config[1];
	uint32_t _clport_lag_failover_config;
} CLPORT_LAG_FAILOVER_CONFIGr_t;

#define CLPORT_LAG_FAILOVER_CONFIGr_CLR(r) (r).clport_lag_failover_config[0] = 0
#define CLPORT_LAG_FAILOVER_CONFIGr_SET(r,d) (r).clport_lag_failover_config[0] = d
#define CLPORT_LAG_FAILOVER_CONFIGr_GET(r) (r).clport_lag_failover_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_GET(r) (((r).clport_lag_failover_config[0]) & 0x1)
#define CLPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_SET(r,f) (r).clport_lag_failover_config[0]=(((r).clport_lag_failover_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CLPORT_LAG_FAILOVER_CONFIG.
 */
#define READ_CLPORT_LAG_FAILOVER_CONFIGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_LAG_FAILOVER_CONFIGr_OFFSET,0,CLPORT_LAG_FAILOVER_CONFIGr_SIZE,(r._clport_lag_failover_config))
#define WRITE_CLPORT_LAG_FAILOVER_CONFIGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_LAG_FAILOVER_CONFIGr_OFFSET,0,CLPORT_LAG_FAILOVER_CONFIGr_SIZE,&(r._clport_lag_failover_config))

/*******************************************************************************
 * End of 'CLPORT_LAG_FAILOVER_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_LED_CHAIN_CONFIG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_LED_CHAIN_CONFIGr_OFFSET 0x00022300

#define CLPORT_LED_CHAIN_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_LED_CHAIN_CONFIG.
 */
typedef union CLPORT_LED_CHAIN_CONFIGr_s {
	uint32_t v[1];
	uint32_t clport_led_chain_config[1];
	uint32_t _clport_led_chain_config;
} CLPORT_LED_CHAIN_CONFIGr_t;

#define CLPORT_LED_CHAIN_CONFIGr_CLR(r) (r).clport_led_chain_config[0] = 0
#define CLPORT_LED_CHAIN_CONFIGr_SET(r,d) (r).clport_led_chain_config[0] = d
#define CLPORT_LED_CHAIN_CONFIGr_GET(r) (r).clport_led_chain_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_LED_CHAIN_CONFIGr_INTRA_DELAYf_GET(r) (((r).clport_led_chain_config[0]) & 0xf)
#define CLPORT_LED_CHAIN_CONFIGr_INTRA_DELAYf_SET(r,f) (r).clport_led_chain_config[0]=(((r).clport_led_chain_config[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CLPORT_LED_CHAIN_CONFIG.
 */
#define READ_CLPORT_LED_CHAIN_CONFIGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_LED_CHAIN_CONFIGr_OFFSET,0,CLPORT_LED_CHAIN_CONFIGr_SIZE,(r._clport_led_chain_config))
#define WRITE_CLPORT_LED_CHAIN_CONFIGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_LED_CHAIN_CONFIGr_OFFSET,0,CLPORT_LED_CHAIN_CONFIGr_SIZE,&(r._clport_led_chain_config))

/*******************************************************************************
 * End of 'CLPORT_LED_CHAIN_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_LINKSTATUS_DOWN
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_LINKSTATUS_DOWNr_OFFSET 0x00022700

#define CLPORT_LINKSTATUS_DOWNr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_LINKSTATUS_DOWN.
 */
typedef union CLPORT_LINKSTATUS_DOWNr_s {
	uint32_t v[1];
	uint32_t clport_linkstatus_down[1];
	uint32_t _clport_linkstatus_down;
} CLPORT_LINKSTATUS_DOWNr_t;

#define CLPORT_LINKSTATUS_DOWNr_CLR(r) (r).clport_linkstatus_down[0] = 0
#define CLPORT_LINKSTATUS_DOWNr_SET(r,d) (r).clport_linkstatus_down[0] = d
#define CLPORT_LINKSTATUS_DOWNr_GET(r) (r).clport_linkstatus_down[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_LINKSTATUS_DOWNr_PORT0_LINKSTATUSf_GET(r) (((r).clport_linkstatus_down[0]) & 0x1)
#define CLPORT_LINKSTATUS_DOWNr_PORT0_LINKSTATUSf_SET(r,f) (r).clport_linkstatus_down[0]=(((r).clport_linkstatus_down[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_LINKSTATUS_DOWNr_PORT1_LINKSTATUSf_GET(r) ((((r).clport_linkstatus_down[0]) >> 1) & 0x1)
#define CLPORT_LINKSTATUS_DOWNr_PORT1_LINKSTATUSf_SET(r,f) (r).clport_linkstatus_down[0]=(((r).clport_linkstatus_down[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_LINKSTATUS_DOWNr_PORT2_LINKSTATUSf_GET(r) ((((r).clport_linkstatus_down[0]) >> 2) & 0x1)
#define CLPORT_LINKSTATUS_DOWNr_PORT2_LINKSTATUSf_SET(r,f) (r).clport_linkstatus_down[0]=(((r).clport_linkstatus_down[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_LINKSTATUS_DOWNr_PORT3_LINKSTATUSf_GET(r) ((((r).clport_linkstatus_down[0]) >> 3) & 0x1)
#define CLPORT_LINKSTATUS_DOWNr_PORT3_LINKSTATUSf_SET(r,f) (r).clport_linkstatus_down[0]=(((r).clport_linkstatus_down[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CLPORT_LINKSTATUS_DOWN.
 */
#define READ_CLPORT_LINKSTATUS_DOWNr(pa,p,r) bcmpmac_read(pa,p,CLPORT_LINKSTATUS_DOWNr_OFFSET,0,CLPORT_LINKSTATUS_DOWNr_SIZE,(r._clport_linkstatus_down))
#define WRITE_CLPORT_LINKSTATUS_DOWNr(pa,p,r) bcmpmac_write(pa,p,CLPORT_LINKSTATUS_DOWNr_OFFSET,0,CLPORT_LINKSTATUS_DOWNr_SIZE,&(r._clport_linkstatus_down))

/*******************************************************************************
 * End of 'CLPORT_LINKSTATUS_DOWNr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_LINKSTATUS_DOWN_CLEAR
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_LINKSTATUS_DOWN_CLEARr_OFFSET 0x00022800

#define CLPORT_LINKSTATUS_DOWN_CLEARr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_LINKSTATUS_DOWN_CLEAR.
 */
typedef union CLPORT_LINKSTATUS_DOWN_CLEARr_s {
	uint32_t v[1];
	uint32_t clport_linkstatus_down_clear[1];
	uint32_t _clport_linkstatus_down_clear;
} CLPORT_LINKSTATUS_DOWN_CLEARr_t;

#define CLPORT_LINKSTATUS_DOWN_CLEARr_CLR(r) (r).clport_linkstatus_down_clear[0] = 0
#define CLPORT_LINKSTATUS_DOWN_CLEARr_SET(r,d) (r).clport_linkstatus_down_clear[0] = d
#define CLPORT_LINKSTATUS_DOWN_CLEARr_GET(r) (r).clport_linkstatus_down_clear[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT0_LINKDOWN_CLEARf_GET(r) (((r).clport_linkstatus_down_clear[0]) & 0x1)
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT0_LINKDOWN_CLEARf_SET(r,f) (r).clport_linkstatus_down_clear[0]=(((r).clport_linkstatus_down_clear[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT1_LINKDOWN_CLEARf_GET(r) ((((r).clport_linkstatus_down_clear[0]) >> 1) & 0x1)
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT1_LINKDOWN_CLEARf_SET(r,f) (r).clport_linkstatus_down_clear[0]=(((r).clport_linkstatus_down_clear[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT2_LINKDOWN_CLEARf_GET(r) ((((r).clport_linkstatus_down_clear[0]) >> 2) & 0x1)
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT2_LINKDOWN_CLEARf_SET(r,f) (r).clport_linkstatus_down_clear[0]=(((r).clport_linkstatus_down_clear[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT3_LINKDOWN_CLEARf_GET(r) ((((r).clport_linkstatus_down_clear[0]) >> 3) & 0x1)
#define CLPORT_LINKSTATUS_DOWN_CLEARr_PORT3_LINKDOWN_CLEARf_SET(r,f) (r).clport_linkstatus_down_clear[0]=(((r).clport_linkstatus_down_clear[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CLPORT_LINKSTATUS_DOWN_CLEAR.
 */
#define READ_CLPORT_LINKSTATUS_DOWN_CLEARr(pa,p,r) bcmpmac_read(pa,p,CLPORT_LINKSTATUS_DOWN_CLEARr_OFFSET,0,CLPORT_LINKSTATUS_DOWN_CLEARr_SIZE,(r._clport_linkstatus_down_clear))
#define WRITE_CLPORT_LINKSTATUS_DOWN_CLEARr(pa,p,r) bcmpmac_write(pa,p,CLPORT_LINKSTATUS_DOWN_CLEARr_OFFSET,0,CLPORT_LINKSTATUS_DOWN_CLEARr_SIZE,&(r._clport_linkstatus_down_clear))

/*******************************************************************************
 * End of 'CLPORT_LINKSTATUS_DOWN_CLEARr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MAC_CONTROL
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MAC_CONTROLr_OFFSET 0x00021000

#define CLPORT_MAC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MAC_CONTROL.
 */
typedef union CLPORT_MAC_CONTROLr_s {
	uint32_t v[1];
	uint32_t clport_mac_control[1];
	uint32_t _clport_mac_control;
} CLPORT_MAC_CONTROLr_t;

#define CLPORT_MAC_CONTROLr_CLR(r) (r).clport_mac_control[0] = 0
#define CLPORT_MAC_CONTROLr_SET(r,d) (r).clport_mac_control[0] = d
#define CLPORT_MAC_CONTROLr_GET(r) (r).clport_mac_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MAC_CONTROLr_XMAC0_RESETf_GET(r) (((r).clport_mac_control[0]) & 0x1)
#define CLPORT_MAC_CONTROLr_XMAC0_RESETf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_GET(r) ((((r).clport_mac_control[0]) >> 1) & 0x1)
#define CLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_GET(r) ((((r).clport_mac_control[0]) >> 2) & 0x1)
#define CLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_MAC_CONTROLr_CLMAC_WAN_IPG_FEATURE_ENf_GET(r) ((((r).clport_mac_control[0]) >> 3) & 0x1)
#define CLPORT_MAC_CONTROLr_CLMAC_WAN_IPG_FEATURE_ENf_SET(r,f) (r).clport_mac_control[0]=(((r).clport_mac_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CLPORT_MAC_CONTROL.
 */
#define READ_CLPORT_MAC_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CLPORT_MAC_CONTROLr_OFFSET,0,CLPORT_MAC_CONTROLr_SIZE,(r._clport_mac_control))
#define WRITE_CLPORT_MAC_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CLPORT_MAC_CONTROLr_OFFSET,0,CLPORT_MAC_CONTROLr_SIZE,&(r._clport_mac_control))

/*******************************************************************************
 * End of 'CLPORT_MAC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MAC_RSV_MASK
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MAC_RSV_MASKr_OFFSET 0x10020800

#define CLPORT_MAC_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MAC_RSV_MASK.
 */
typedef union CLPORT_MAC_RSV_MASKr_s {
	uint32_t v[1];
	uint32_t clport_mac_rsv_mask[1];
	uint32_t _clport_mac_rsv_mask;
} CLPORT_MAC_RSV_MASKr_t;

#define CLPORT_MAC_RSV_MASKr_CLR(r) (r).clport_mac_rsv_mask[0] = 0
#define CLPORT_MAC_RSV_MASKr_SET(r,d) (r).clport_mac_rsv_mask[0] = d
#define CLPORT_MAC_RSV_MASKr_GET(r) (r).clport_mac_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MAC_RSV_MASKr_MASKf_GET(r) ((r).clport_mac_rsv_mask[0])
#define CLPORT_MAC_RSV_MASKr_MASKf_SET(r,f) (r).clport_mac_rsv_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access CLPORT_MAC_RSV_MASK.
 */
#define READ_CLPORT_MAC_RSV_MASKr(pa,p,r) bcmpmac_read(pa,p,CLPORT_MAC_RSV_MASKr_OFFSET,0,CLPORT_MAC_RSV_MASKr_SIZE,(r._clport_mac_rsv_mask))
#define WRITE_CLPORT_MAC_RSV_MASKr(pa,p,r) bcmpmac_write(pa,p,CLPORT_MAC_RSV_MASKr_OFFSET,0,CLPORT_MAC_RSV_MASKr_SIZE,&(r._clport_mac_rsv_mask))

/*******************************************************************************
 * End of 'CLPORT_MAC_RSV_MASKr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MIB_RESET
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_RESETr_OFFSET 0x00022400

#define CLPORT_MIB_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MIB_RESET.
 */
typedef union CLPORT_MIB_RESETr_s {
	uint32_t v[1];
	uint32_t clport_mib_reset[1];
	uint32_t _clport_mib_reset;
} CLPORT_MIB_RESETr_t;

#define CLPORT_MIB_RESETr_CLR(r) (r).clport_mib_reset[0] = 0
#define CLPORT_MIB_RESETr_SET(r,d) (r).clport_mib_reset[0] = d
#define CLPORT_MIB_RESETr_GET(r) (r).clport_mib_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MIB_RESETr_CLR_CNTf_GET(r) (((r).clport_mib_reset[0]) & 0xf)
#define CLPORT_MIB_RESETr_CLR_CNTf_SET(r,f) (r).clport_mib_reset[0]=(((r).clport_mib_reset[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CLPORT_MIB_RESET.
 */
#define READ_CLPORT_MIB_RESETr(pa,p,r) bcmpmac_read(pa,p,CLPORT_MIB_RESETr_OFFSET,0,CLPORT_MIB_RESETr_SIZE,(r._clport_mib_reset))
#define WRITE_CLPORT_MIB_RESETr(pa,p,r) bcmpmac_write(pa,p,CLPORT_MIB_RESETr_OFFSET,0,CLPORT_MIB_RESETr_SIZE,&(r._clport_mib_reset))

/*******************************************************************************
 * End of 'CLPORT_MIB_RESETr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MIB_RSC0_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_RSC0_ECC_STATUSr_OFFSET 0x00021d00

#define CLPORT_MIB_RSC0_ECC_STATUSr_SIZE 4

/* CLPORT_MIB_RSC0_ECC_STATUSr is element of CLPORT_MIB_RSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  CLPORT_MIB_RSC1_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_RSC1_ECC_STATUSr_OFFSET 0x00021e00

#define CLPORT_MIB_RSC1_ECC_STATUSr_SIZE 4

/* CLPORT_MIB_RSC1_ECC_STATUSr is element of CLPORT_MIB_RSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  CLPORT_MIB_RSC_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_RSC_ECC_STATUSr_OFFSET 0x00021d00

#define CLPORT_MIB_RSC_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MIB_RSC_ECC_STATUS.
 */
typedef union CLPORT_MIB_RSC_ECC_STATUSr_s {
	uint32_t v[1];
	uint32_t clport_mib_rsc_ecc_status[1];
	uint32_t _clport_mib_rsc_ecc_status;
} CLPORT_MIB_RSC_ECC_STATUSr_t;

#define CLPORT_MIB_RSC_ECC_STATUSr_CLR(r) (r).clport_mib_rsc_ecc_status[0] = 0
#define CLPORT_MIB_RSC_ECC_STATUSr_SET(r,d) (r).clport_mib_rsc_ecc_status[0] = d
#define CLPORT_MIB_RSC_ECC_STATUSr_GET(r) (r).clport_mib_rsc_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MIB_RSC_ECC_STATUSr_ECC_ERRf_GET(r) (((r).clport_mib_rsc_ecc_status[0]) & 0x1)
#define CLPORT_MIB_RSC_ECC_STATUSr_ECC_ERRf_SET(r,f) (r).clport_mib_rsc_ecc_status[0]=(((r).clport_mib_rsc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_MIB_RSC_ECC_STATUSr_MULTIPLE_ERRf_GET(r) ((((r).clport_mib_rsc_ecc_status[0]) >> 1) & 0x1)
#define CLPORT_MIB_RSC_ECC_STATUSr_MULTIPLE_ERRf_SET(r,f) (r).clport_mib_rsc_ecc_status[0]=(((r).clport_mib_rsc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_MIB_RSC_ECC_STATUSr_DOUBLE_BIT_ERRf_GET(r) ((((r).clport_mib_rsc_ecc_status[0]) >> 2) & 0x1)
#define CLPORT_MIB_RSC_ECC_STATUSr_DOUBLE_BIT_ERRf_SET(r,f) (r).clport_mib_rsc_ecc_status[0]=(((r).clport_mib_rsc_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_MIB_RSC_ECC_STATUSr_ENTRY_IDXf_GET(r) ((((r).clport_mib_rsc_ecc_status[0]) >> 3) & 0xff)
#define CLPORT_MIB_RSC_ECC_STATUSr_ENTRY_IDXf_SET(r,f) (r).clport_mib_rsc_ecc_status[0]=(((r).clport_mib_rsc_ecc_status[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))

/*
 * These macros can be used to access CLPORT_MIB_RSC_ECC_STATUS.
 */
#define READ_CLPORT_MIB_RSC_ECC_STATUSr(pa,p,i,r) bcmpmac_read(pa,p,CLPORT_MIB_RSC_ECC_STATUSr_OFFSET,i,CLPORT_MIB_RSC_ECC_STATUSr_SIZE,(r._clport_mib_rsc_ecc_status))
#define WRITE_CLPORT_MIB_RSC_ECC_STATUSr(pa,p,i,r) bcmpmac_write(pa,p,CLPORT_MIB_RSC_ECC_STATUSr_OFFSET,i,CLPORT_MIB_RSC_ECC_STATUSr_SIZE,&(r._clport_mib_rsc_ecc_status))

/*******************************************************************************
 * End of 'CLPORT_MIB_RSC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MIB_RSC_RAM_CONTROL
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_RSC_RAM_CONTROLr_OFFSET 0x00022200

#define CLPORT_MIB_RSC_RAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MIB_RSC_RAM_CONTROL.
 */
typedef union CLPORT_MIB_RSC_RAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t clport_mib_rsc_ram_control[1];
	uint32_t _clport_mib_rsc_ram_control;
} CLPORT_MIB_RSC_RAM_CONTROLr_t;

#define CLPORT_MIB_RSC_RAM_CONTROLr_CLR(r) (r).clport_mib_rsc_ram_control[0] = 0
#define CLPORT_MIB_RSC_RAM_CONTROLr_SET(r,d) (r).clport_mib_rsc_ram_control[0] = d
#define CLPORT_MIB_RSC_RAM_CONTROLr_GET(r) (r).clport_mib_rsc_ram_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_TMf_GET(r) (((r).clport_mib_rsc_ram_control[0]) & 0xfff)
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_TMf_SET(r,f) (r).clport_mib_rsc_ram_control[0]=(((r).clport_mib_rsc_ram_control[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_TMf_GET(r) ((((r).clport_mib_rsc_ram_control[0]) >> 12) & 0xfff)
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_TMf_SET(r,f) (r).clport_mib_rsc_ram_control[0]=(((r).clport_mib_rsc_ram_control[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_LVMf_GET(r) ((((r).clport_mib_rsc_ram_control[0]) >> 24) & 0x1)
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_LVMf_SET(r,f) (r).clport_mib_rsc_ram_control[0]=(((r).clport_mib_rsc_ram_control[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_LVMf_GET(r) ((((r).clport_mib_rsc_ram_control[0]) >> 25) & 0x1)
#define CLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_LVMf_SET(r,f) (r).clport_mib_rsc_ram_control[0]=(((r).clport_mib_rsc_ram_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access CLPORT_MIB_RSC_RAM_CONTROL.
 */
#define READ_CLPORT_MIB_RSC_RAM_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CLPORT_MIB_RSC_RAM_CONTROLr_OFFSET,0,CLPORT_MIB_RSC_RAM_CONTROLr_SIZE,(r._clport_mib_rsc_ram_control))
#define WRITE_CLPORT_MIB_RSC_RAM_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CLPORT_MIB_RSC_RAM_CONTROLr_OFFSET,0,CLPORT_MIB_RSC_RAM_CONTROLr_SIZE,&(r._clport_mib_rsc_ram_control))

/*******************************************************************************
 * End of 'CLPORT_MIB_RSC_RAM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MIB_TSC0_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_TSC0_ECC_STATUSr_OFFSET 0x00021f00

#define CLPORT_MIB_TSC0_ECC_STATUSr_SIZE 4

/* CLPORT_MIB_TSC0_ECC_STATUSr is element of CLPORT_MIB_TSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  CLPORT_MIB_TSC1_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_TSC1_ECC_STATUSr_OFFSET 0x00022000

#define CLPORT_MIB_TSC1_ECC_STATUSr_SIZE 4

/* CLPORT_MIB_TSC1_ECC_STATUSr is element of CLPORT_MIB_TSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  CLPORT_MIB_TSC_ECC_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_TSC_ECC_STATUSr_OFFSET 0x00021f00

#define CLPORT_MIB_TSC_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MIB_TSC_ECC_STATUS.
 */
typedef union CLPORT_MIB_TSC_ECC_STATUSr_s {
	uint32_t v[1];
	uint32_t clport_mib_tsc_ecc_status[1];
	uint32_t _clport_mib_tsc_ecc_status;
} CLPORT_MIB_TSC_ECC_STATUSr_t;

#define CLPORT_MIB_TSC_ECC_STATUSr_CLR(r) (r).clport_mib_tsc_ecc_status[0] = 0
#define CLPORT_MIB_TSC_ECC_STATUSr_SET(r,d) (r).clport_mib_tsc_ecc_status[0] = d
#define CLPORT_MIB_TSC_ECC_STATUSr_GET(r) (r).clport_mib_tsc_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MIB_TSC_ECC_STATUSr_ECC_ERRf_GET(r) (((r).clport_mib_tsc_ecc_status[0]) & 0x1)
#define CLPORT_MIB_TSC_ECC_STATUSr_ECC_ERRf_SET(r,f) (r).clport_mib_tsc_ecc_status[0]=(((r).clport_mib_tsc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_MIB_TSC_ECC_STATUSr_MULTIPLE_ERRf_GET(r) ((((r).clport_mib_tsc_ecc_status[0]) >> 1) & 0x1)
#define CLPORT_MIB_TSC_ECC_STATUSr_MULTIPLE_ERRf_SET(r,f) (r).clport_mib_tsc_ecc_status[0]=(((r).clport_mib_tsc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_MIB_TSC_ECC_STATUSr_DOUBLE_BIT_ERRf_GET(r) ((((r).clport_mib_tsc_ecc_status[0]) >> 2) & 0x1)
#define CLPORT_MIB_TSC_ECC_STATUSr_DOUBLE_BIT_ERRf_SET(r,f) (r).clport_mib_tsc_ecc_status[0]=(((r).clport_mib_tsc_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_MIB_TSC_ECC_STATUSr_ENTRY_IDXf_GET(r) ((((r).clport_mib_tsc_ecc_status[0]) >> 3) & 0xff)
#define CLPORT_MIB_TSC_ECC_STATUSr_ENTRY_IDXf_SET(r,f) (r).clport_mib_tsc_ecc_status[0]=(((r).clport_mib_tsc_ecc_status[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))

/*
 * These macros can be used to access CLPORT_MIB_TSC_ECC_STATUS.
 */
#define READ_CLPORT_MIB_TSC_ECC_STATUSr(pa,p,i,r) bcmpmac_read(pa,p,CLPORT_MIB_TSC_ECC_STATUSr_OFFSET,i,CLPORT_MIB_TSC_ECC_STATUSr_SIZE,(r._clport_mib_tsc_ecc_status))
#define WRITE_CLPORT_MIB_TSC_ECC_STATUSr(pa,p,i,r) bcmpmac_write(pa,p,CLPORT_MIB_TSC_ECC_STATUSr_OFFSET,i,CLPORT_MIB_TSC_ECC_STATUSr_SIZE,&(r._clport_mib_tsc_ecc_status))

/*******************************************************************************
 * End of 'CLPORT_MIB_TSC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MIB_TSC_RAM_CONTROL
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MIB_TSC_RAM_CONTROLr_OFFSET 0x00022100

#define CLPORT_MIB_TSC_RAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MIB_TSC_RAM_CONTROL.
 */
typedef union CLPORT_MIB_TSC_RAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t clport_mib_tsc_ram_control[1];
	uint32_t _clport_mib_tsc_ram_control;
} CLPORT_MIB_TSC_RAM_CONTROLr_t;

#define CLPORT_MIB_TSC_RAM_CONTROLr_CLR(r) (r).clport_mib_tsc_ram_control[0] = 0
#define CLPORT_MIB_TSC_RAM_CONTROLr_SET(r,d) (r).clport_mib_tsc_ram_control[0] = d
#define CLPORT_MIB_TSC_RAM_CONTROLr_GET(r) (r).clport_mib_tsc_ram_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_TMf_GET(r) (((r).clport_mib_tsc_ram_control[0]) & 0xfff)
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_TMf_SET(r,f) (r).clport_mib_tsc_ram_control[0]=(((r).clport_mib_tsc_ram_control[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_TMf_GET(r) ((((r).clport_mib_tsc_ram_control[0]) >> 12) & 0xfff)
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_TMf_SET(r,f) (r).clport_mib_tsc_ram_control[0]=(((r).clport_mib_tsc_ram_control[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_LVMf_GET(r) ((((r).clport_mib_tsc_ram_control[0]) >> 24) & 0x1)
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_LVMf_SET(r,f) (r).clport_mib_tsc_ram_control[0]=(((r).clport_mib_tsc_ram_control[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_LVMf_GET(r) ((((r).clport_mib_tsc_ram_control[0]) >> 25) & 0x1)
#define CLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_LVMf_SET(r,f) (r).clport_mib_tsc_ram_control[0]=(((r).clport_mib_tsc_ram_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access CLPORT_MIB_TSC_RAM_CONTROL.
 */
#define READ_CLPORT_MIB_TSC_RAM_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CLPORT_MIB_TSC_RAM_CONTROLr_OFFSET,0,CLPORT_MIB_TSC_RAM_CONTROLr_SIZE,(r._clport_mib_tsc_ram_control))
#define WRITE_CLPORT_MIB_TSC_RAM_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CLPORT_MIB_TSC_RAM_CONTROLr_OFFSET,0,CLPORT_MIB_TSC_RAM_CONTROLr_SIZE,&(r._clport_mib_tsc_ram_control))

/*******************************************************************************
 * End of 'CLPORT_MIB_TSC_RAM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_MODE_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_MODE_REGr_OFFSET 0x00020a00

#define CLPORT_MODE_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_MODE_REG.
 */
typedef union CLPORT_MODE_REGr_s {
	uint32_t v[1];
	uint32_t clport_mode_reg[1];
	uint32_t _clport_mode_reg;
} CLPORT_MODE_REGr_t;

#define CLPORT_MODE_REGr_CLR(r) (r).clport_mode_reg[0] = 0
#define CLPORT_MODE_REGr_SET(r,d) (r).clport_mode_reg[0] = d
#define CLPORT_MODE_REGr_GET(r) (r).clport_mode_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_GET(r) (((r).clport_mode_reg[0]) & 0x7)
#define CLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define CLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_GET(r) ((((r).clport_mode_reg[0]) >> 3) & 0x7)
#define CLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_GET(r) ((((r).clport_mode_reg[0]) >> 6) & 0x1)
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define CLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_GET(r) ((((r).clport_mode_reg[0]) >> 7) & 0x1)
#define CLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define CLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_GET(r) ((((r).clport_mode_reg[0]) >> 8) & 0x1)
#define CLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_GET(r) ((((r).clport_mode_reg[0]) >> 9) & 0x1)
#define CLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define CLPORT_MODE_REGr_SINGLE_PORT_MODE_SPEED_100Gf_GET(r) ((((r).clport_mode_reg[0]) >> 10) & 0x1)
#define CLPORT_MODE_REGr_SINGLE_PORT_MODE_SPEED_100Gf_SET(r,f) (r).clport_mode_reg[0]=(((r).clport_mode_reg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))

/*
 * These macros can be used to access CLPORT_MODE_REG.
 */
#define READ_CLPORT_MODE_REGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_MODE_REGr_OFFSET,0,CLPORT_MODE_REGr_SIZE,(r._clport_mode_reg))
#define WRITE_CLPORT_MODE_REGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_MODE_REGr_OFFSET,0,CLPORT_MODE_REGr_SIZE,&(r._clport_mode_reg))

/*******************************************************************************
 * End of 'CLPORT_MODE_REGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_POWER_SAVE
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_POWER_SAVEr_OFFSET 0x00020d00

#define CLPORT_POWER_SAVEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_POWER_SAVE.
 */
typedef union CLPORT_POWER_SAVEr_s {
	uint32_t v[1];
	uint32_t clport_power_save[1];
	uint32_t _clport_power_save;
} CLPORT_POWER_SAVEr_t;

#define CLPORT_POWER_SAVEr_CLR(r) (r).clport_power_save[0] = 0
#define CLPORT_POWER_SAVEr_SET(r,d) (r).clport_power_save[0] = d
#define CLPORT_POWER_SAVEr_GET(r) (r).clport_power_save[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_POWER_SAVEr_XPORT_CORE0f_GET(r) (((r).clport_power_save[0]) & 0x1)
#define CLPORT_POWER_SAVEr_XPORT_CORE0f_SET(r,f) (r).clport_power_save[0]=(((r).clport_power_save[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CLPORT_POWER_SAVE.
 */
#define READ_CLPORT_POWER_SAVEr(pa,p,r) bcmpmac_read(pa,p,CLPORT_POWER_SAVEr_OFFSET,0,CLPORT_POWER_SAVEr_SIZE,(r._clport_power_save))
#define WRITE_CLPORT_POWER_SAVEr(pa,p,r) bcmpmac_write(pa,p,CLPORT_POWER_SAVEr_OFFSET,0,CLPORT_POWER_SAVEr_SIZE,&(r._clport_power_save))

/*******************************************************************************
 * End of 'CLPORT_POWER_SAVEr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_SBUS_CONTROL
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_SBUS_CONTROLr_OFFSET 0x00022b00

#define CLPORT_SBUS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_SBUS_CONTROL.
 */
typedef union CLPORT_SBUS_CONTROLr_s {
	uint32_t v[1];
	uint32_t clport_sbus_control[1];
	uint32_t _clport_sbus_control;
} CLPORT_SBUS_CONTROLr_t;

#define CLPORT_SBUS_CONTROLr_CLR(r) (r).clport_sbus_control[0] = 0
#define CLPORT_SBUS_CONTROLr_SET(r,d) (r).clport_sbus_control[0] = d
#define CLPORT_SBUS_CONTROLr_GET(r) (r).clport_sbus_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_SBUS_CONTROLr_SBUS_BCAST_BLOCK_IDf_GET(r) (((r).clport_sbus_control[0]) & 0x7f)
#define CLPORT_SBUS_CONTROLr_SBUS_BCAST_BLOCK_IDf_SET(r,f) (r).clport_sbus_control[0]=(((r).clport_sbus_control[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define CLPORT_SBUS_CONTROLr_SBUS_CHAIN_LASTf_GET(r) ((((r).clport_sbus_control[0]) >> 7) & 0x1)
#define CLPORT_SBUS_CONTROLr_SBUS_CHAIN_LASTf_SET(r,f) (r).clport_sbus_control[0]=(((r).clport_sbus_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CLPORT_SBUS_CONTROL.
 */
#define READ_CLPORT_SBUS_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CLPORT_SBUS_CONTROLr_OFFSET,0,CLPORT_SBUS_CONTROLr_SIZE,(r._clport_sbus_control))
#define WRITE_CLPORT_SBUS_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CLPORT_SBUS_CONTROLr_OFFSET,0,CLPORT_SBUS_CONTROLr_SIZE,&(r._clport_sbus_control))

/*******************************************************************************
 * End of 'CLPORT_SBUS_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_SGNDET_EARLYCRS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_SGNDET_EARLYCRSr_OFFSET 0x10020400

#define CLPORT_SGNDET_EARLYCRSr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_SGNDET_EARLYCRS.
 */
typedef union CLPORT_SGNDET_EARLYCRSr_s {
	uint32_t v[1];
	uint32_t clport_sgndet_earlycrs[1];
	uint32_t _clport_sgndet_earlycrs;
} CLPORT_SGNDET_EARLYCRSr_t;

#define CLPORT_SGNDET_EARLYCRSr_CLR(r) (r).clport_sgndet_earlycrs[0] = 0
#define CLPORT_SGNDET_EARLYCRSr_SET(r,d) (r).clport_sgndet_earlycrs[0] = d
#define CLPORT_SGNDET_EARLYCRSr_GET(r) (r).clport_sgndet_earlycrs[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_SGNDET_EARLYCRSr_SGN_DETf_GET(r) (((r).clport_sgndet_earlycrs[0]) & 0x1)
#define CLPORT_SGNDET_EARLYCRSr_SGN_DETf_SET(r,f) (r).clport_sgndet_earlycrs[0]=(((r).clport_sgndet_earlycrs[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CLPORT_SGNDET_EARLYCRS.
 */
#define READ_CLPORT_SGNDET_EARLYCRSr(pa,p,r) bcmpmac_read(pa,p,CLPORT_SGNDET_EARLYCRSr_OFFSET,0,CLPORT_SGNDET_EARLYCRSr_SIZE,(r._clport_sgndet_earlycrs))
#define WRITE_CLPORT_SGNDET_EARLYCRSr(pa,p,r) bcmpmac_write(pa,p,CLPORT_SGNDET_EARLYCRSr_OFFSET,0,CLPORT_SGNDET_EARLYCRSr_SIZE,&(r._clport_sgndet_earlycrs))

/*******************************************************************************
 * End of 'CLPORT_SGNDET_EARLYCRSr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_SOFT_RESET
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_SOFT_RESETr_OFFSET 0x00020c00

#define CLPORT_SOFT_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_SOFT_RESET.
 */
typedef union CLPORT_SOFT_RESETr_s {
	uint32_t v[1];
	uint32_t clport_soft_reset[1];
	uint32_t _clport_soft_reset;
} CLPORT_SOFT_RESETr_t;

#define CLPORT_SOFT_RESETr_CLR(r) (r).clport_soft_reset[0] = 0
#define CLPORT_SOFT_RESETr_SET(r,d) (r).clport_soft_reset[0] = d
#define CLPORT_SOFT_RESETr_GET(r) (r).clport_soft_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_SOFT_RESETr_PORT0f_GET(r) (((r).clport_soft_reset[0]) & 0x1)
#define CLPORT_SOFT_RESETr_PORT0f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_SOFT_RESETr_PORT1f_GET(r) ((((r).clport_soft_reset[0]) >> 1) & 0x1)
#define CLPORT_SOFT_RESETr_PORT1f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_SOFT_RESETr_PORT2f_GET(r) ((((r).clport_soft_reset[0]) >> 2) & 0x1)
#define CLPORT_SOFT_RESETr_PORT2f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_SOFT_RESETr_PORT3f_GET(r) ((((r).clport_soft_reset[0]) >> 3) & 0x1)
#define CLPORT_SOFT_RESETr_PORT3f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLPORT_SOFT_RESETr_RESERVED4f_GET(r) ((((r).clport_soft_reset[0]) >> 4) & 0x1)
#define CLPORT_SOFT_RESETr_RESERVED4f_SET(r,f) (r).clport_soft_reset[0]=(((r).clport_soft_reset[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CLPORT_SOFT_RESET.
 */
#define READ_CLPORT_SOFT_RESETr(pa,p,r) bcmpmac_read(pa,p,CLPORT_SOFT_RESETr_OFFSET,0,CLPORT_SOFT_RESETr_SIZE,(r._clport_soft_reset))
#define WRITE_CLPORT_SOFT_RESETr(pa,p,r) bcmpmac_write(pa,p,CLPORT_SOFT_RESETr_OFFSET,0,CLPORT_SOFT_RESETr_SIZE,&(r._clport_soft_reset))

/*******************************************************************************
 * End of 'CLPORT_SOFT_RESETr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_SPARE0_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_SPARE0_REGr_OFFSET 0x10020900

#define CLPORT_SPARE0_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_SPARE0_REG.
 */
typedef union CLPORT_SPARE0_REGr_s {
	uint32_t v[1];
	uint32_t clport_spare0_reg[1];
	uint32_t _clport_spare0_reg;
} CLPORT_SPARE0_REGr_t;

#define CLPORT_SPARE0_REGr_CLR(r) (r).clport_spare0_reg[0] = 0
#define CLPORT_SPARE0_REGr_SET(r,d) (r).clport_spare0_reg[0] = d
#define CLPORT_SPARE0_REGr_GET(r) (r).clport_spare0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_SPARE0_REGr_RSVDf_GET(r) ((r).clport_spare0_reg[0])
#define CLPORT_SPARE0_REGr_RSVDf_SET(r,f) (r).clport_spare0_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CLPORT_SPARE0_REG.
 */
#define READ_CLPORT_SPARE0_REGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_SPARE0_REGr_OFFSET,0,CLPORT_SPARE0_REGr_SIZE,(r._clport_spare0_reg))
#define WRITE_CLPORT_SPARE0_REGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_SPARE0_REGr_OFFSET,0,CLPORT_SPARE0_REGr_SIZE,&(r._clport_spare0_reg))

/*******************************************************************************
 * End of 'CLPORT_SPARE0_REGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_SW_FLOW_CONTROL
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_SW_FLOW_CONTROLr_OFFSET 0x10020600

#define CLPORT_SW_FLOW_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_SW_FLOW_CONTROL.
 */
typedef union CLPORT_SW_FLOW_CONTROLr_s {
	uint32_t v[1];
	uint32_t clport_sw_flow_control[1];
	uint32_t _clport_sw_flow_control;
} CLPORT_SW_FLOW_CONTROLr_t;

#define CLPORT_SW_FLOW_CONTROLr_CLR(r) (r).clport_sw_flow_control[0] = 0
#define CLPORT_SW_FLOW_CONTROLr_SET(r,d) (r).clport_sw_flow_control[0] = d
#define CLPORT_SW_FLOW_CONTROLr_GET(r) (r).clport_sw_flow_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_SW_FLOW_CONTROLr_FC_PAUSEf_GET(r) (((r).clport_sw_flow_control[0]) & 0x1)
#define CLPORT_SW_FLOW_CONTROLr_FC_PAUSEf_SET(r,f) (r).clport_sw_flow_control[0]=(((r).clport_sw_flow_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_SW_FLOW_CONTROLr_FC_ENf_GET(r) ((((r).clport_sw_flow_control[0]) >> 1) & 0x1)
#define CLPORT_SW_FLOW_CONTROLr_FC_ENf_SET(r,f) (r).clport_sw_flow_control[0]=(((r).clport_sw_flow_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLPORT_SW_FLOW_CONTROL.
 */
#define READ_CLPORT_SW_FLOW_CONTROLr(pa,p,r) bcmpmac_read(pa,p,CLPORT_SW_FLOW_CONTROLr_OFFSET,0,CLPORT_SW_FLOW_CONTROLr_SIZE,(r._clport_sw_flow_control))
#define WRITE_CLPORT_SW_FLOW_CONTROLr(pa,p,r) bcmpmac_write(pa,p,CLPORT_SW_FLOW_CONTROLr_OFFSET,0,CLPORT_SW_FLOW_CONTROLr_SIZE,&(r._clport_sw_flow_control))

/*******************************************************************************
 * End of 'CLPORT_SW_FLOW_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_TSC_PLL_LOCK_STATUS
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_TSC_PLL_LOCK_STATUSr_OFFSET 0x00021300

#define CLPORT_TSC_PLL_LOCK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_TSC_PLL_LOCK_STATUS.
 */
typedef union CLPORT_TSC_PLL_LOCK_STATUSr_s {
	uint32_t v[1];
	uint32_t clport_tsc_pll_lock_status[1];
	uint32_t _clport_tsc_pll_lock_status;
} CLPORT_TSC_PLL_LOCK_STATUSr_t;

#define CLPORT_TSC_PLL_LOCK_STATUSr_CLR(r) (r).clport_tsc_pll_lock_status[0] = 0
#define CLPORT_TSC_PLL_LOCK_STATUSr_SET(r,d) (r).clport_tsc_pll_lock_status[0] = d
#define CLPORT_TSC_PLL_LOCK_STATUSr_GET(r) (r).clport_tsc_pll_lock_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_TSC_PLL_LOCK_STATUSr_CURRENTf_GET(r) (((r).clport_tsc_pll_lock_status[0]) & 0x1)
#define CLPORT_TSC_PLL_LOCK_STATUSr_CURRENTf_SET(r,f) (r).clport_tsc_pll_lock_status[0]=(((r).clport_tsc_pll_lock_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_TSC_PLL_LOCK_STATUSr_LOSTf_GET(r) ((((r).clport_tsc_pll_lock_status[0]) >> 1) & 0x1)
#define CLPORT_TSC_PLL_LOCK_STATUSr_LOSTf_SET(r,f) (r).clport_tsc_pll_lock_status[0]=(((r).clport_tsc_pll_lock_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access CLPORT_TSC_PLL_LOCK_STATUS.
 */
#define READ_CLPORT_TSC_PLL_LOCK_STATUSr(pa,p,r) bcmpmac_read(pa,p,CLPORT_TSC_PLL_LOCK_STATUSr_OFFSET,0,CLPORT_TSC_PLL_LOCK_STATUSr_SIZE,(r._clport_tsc_pll_lock_status))
#define WRITE_CLPORT_TSC_PLL_LOCK_STATUSr(pa,p,r) bcmpmac_write(pa,p,CLPORT_TSC_PLL_LOCK_STATUSr_OFFSET,0,CLPORT_TSC_PLL_LOCK_STATUSr_SIZE,&(r._clport_tsc_pll_lock_status))

/*******************************************************************************
 * End of 'CLPORT_TSC_PLL_LOCK_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_TS_TIMER_31_0_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_TS_TIMER_31_0_REGr_OFFSET 0x00022600

#define CLPORT_TS_TIMER_31_0_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_TS_TIMER_31_0_REG.
 */
typedef union CLPORT_TS_TIMER_31_0_REGr_s {
	uint32_t v[1];
	uint32_t clport_ts_timer_31_0_reg[1];
	uint32_t _clport_ts_timer_31_0_reg;
} CLPORT_TS_TIMER_31_0_REGr_t;

#define CLPORT_TS_TIMER_31_0_REGr_CLR(r) (r).clport_ts_timer_31_0_reg[0] = 0
#define CLPORT_TS_TIMER_31_0_REGr_SET(r,d) (r).clport_ts_timer_31_0_reg[0] = d
#define CLPORT_TS_TIMER_31_0_REGr_GET(r) (r).clport_ts_timer_31_0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_TS_TIMER_31_0_REGr_TS_TIMER_31_0_VALUEf_GET(r) ((r).clport_ts_timer_31_0_reg[0])
#define CLPORT_TS_TIMER_31_0_REGr_TS_TIMER_31_0_VALUEf_SET(r,f) (r).clport_ts_timer_31_0_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access CLPORT_TS_TIMER_31_0_REG.
 */
#define READ_CLPORT_TS_TIMER_31_0_REGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_TS_TIMER_31_0_REGr_OFFSET,0,CLPORT_TS_TIMER_31_0_REGr_SIZE,(r._clport_ts_timer_31_0_reg))
#define WRITE_CLPORT_TS_TIMER_31_0_REGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_TS_TIMER_31_0_REGr_OFFSET,0,CLPORT_TS_TIMER_31_0_REGr_SIZE,&(r._clport_ts_timer_31_0_reg))

/*******************************************************************************
 * End of 'CLPORT_TS_TIMER_31_0_REGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_TS_TIMER_47_32_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_TS_TIMER_47_32_REGr_OFFSET 0x00022500

#define CLPORT_TS_TIMER_47_32_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_TS_TIMER_47_32_REG.
 */
typedef union CLPORT_TS_TIMER_47_32_REGr_s {
	uint32_t v[1];
	uint32_t clport_ts_timer_47_32_reg[1];
	uint32_t _clport_ts_timer_47_32_reg;
} CLPORT_TS_TIMER_47_32_REGr_t;

#define CLPORT_TS_TIMER_47_32_REGr_CLR(r) (r).clport_ts_timer_47_32_reg[0] = 0
#define CLPORT_TS_TIMER_47_32_REGr_SET(r,d) (r).clport_ts_timer_47_32_reg[0] = d
#define CLPORT_TS_TIMER_47_32_REGr_GET(r) (r).clport_ts_timer_47_32_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_TS_TIMER_47_32_REGr_TS_TIMER_47_32_VALUEf_GET(r) (((r).clport_ts_timer_47_32_reg[0]) & 0xffff)
#define CLPORT_TS_TIMER_47_32_REGr_TS_TIMER_47_32_VALUEf_SET(r,f) (r).clport_ts_timer_47_32_reg[0]=(((r).clport_ts_timer_47_32_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CLPORT_TS_TIMER_47_32_REG.
 */
#define READ_CLPORT_TS_TIMER_47_32_REGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_TS_TIMER_47_32_REGr_OFFSET,0,CLPORT_TS_TIMER_47_32_REGr_SIZE,(r._clport_ts_timer_47_32_reg))
#define WRITE_CLPORT_TS_TIMER_47_32_REGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_TS_TIMER_47_32_REGr_OFFSET,0,CLPORT_TS_TIMER_47_32_REGr_SIZE,&(r._clport_ts_timer_47_32_reg))

/*******************************************************************************
 * End of 'CLPORT_TS_TIMER_47_32_REGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_WC_UCMEM_CTRL
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_WC_UCMEM_CTRLr_OFFSET 0x00021900

#define CLPORT_WC_UCMEM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_WC_UCMEM_CTRL.
 */
typedef union CLPORT_WC_UCMEM_CTRLr_s {
	uint32_t v[1];
	uint32_t clport_wc_ucmem_ctrl[1];
	uint32_t _clport_wc_ucmem_ctrl;
} CLPORT_WC_UCMEM_CTRLr_t;

#define CLPORT_WC_UCMEM_CTRLr_CLR(r) (r).clport_wc_ucmem_ctrl[0] = 0
#define CLPORT_WC_UCMEM_CTRLr_SET(r,d) (r).clport_wc_ucmem_ctrl[0] = d
#define CLPORT_WC_UCMEM_CTRLr_GET(r) (r).clport_wc_ucmem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_GET(r) (((r).clport_wc_ucmem_ctrl[0]) & 0x1)
#define CLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_SET(r,f) (r).clport_wc_ucmem_ctrl[0]=(((r).clport_wc_ucmem_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_WC_UCMEM_CTRLr_RSVD3_1f_GET(r) ((((r).clport_wc_ucmem_ctrl[0]) >> 1) & 0x7)
#define CLPORT_WC_UCMEM_CTRLr_RSVD3_1f_SET(r,f) (r).clport_wc_ucmem_ctrl[0]=(((r).clport_wc_ucmem_ctrl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access CLPORT_WC_UCMEM_CTRL.
 */
#define READ_CLPORT_WC_UCMEM_CTRLr(pa,p,r) bcmpmac_read(pa,p,CLPORT_WC_UCMEM_CTRLr_OFFSET,0,CLPORT_WC_UCMEM_CTRLr_SIZE,(r._clport_wc_ucmem_ctrl))
#define WRITE_CLPORT_WC_UCMEM_CTRLr(pa,p,r) bcmpmac_write(pa,p,CLPORT_WC_UCMEM_CTRLr_OFFSET,0,CLPORT_WC_UCMEM_CTRLr_SIZE,&(r._clport_wc_ucmem_ctrl))

/*******************************************************************************
 * End of 'CLPORT_WC_UCMEM_CTRLr'
 */




/*******************************************************************************
 * MEMORY:  CLPORT_WC_UCMEM_DATA
 * BLOCKS:   CLPORT
 * SIZE:     128
 */
#define CLPORT_WC_UCMEM_DATAm_OFFSET 0x20000000

#define CLPORT_WC_UCMEM_DATAm_MIN 0
#define CLPORT_WC_UCMEM_DATAm_MAX 2047
#define CLPORT_WC_UCMEM_DATAm_CMAX(u) 2047
#define CLPORT_WC_UCMEM_DATAm_SIZE 16

/*
 * This structure should be used to declare and program CLPORT_WC_UCMEM_DATA.
 */
typedef union CLPORT_WC_UCMEM_DATAm_s {
	uint32_t v[4];
	uint32_t clport_wc_ucmem_data[4];
	uint32_t _clport_wc_ucmem_data;
} CLPORT_WC_UCMEM_DATAm_t;

#define CLPORT_WC_UCMEM_DATAm_CLR(r) sal_memset(&((r)._clport_wc_ucmem_data), 0, sizeof(CLPORT_WC_UCMEM_DATAm_t))
#define CLPORT_WC_UCMEM_DATAm_SET(r,i,d) (r).clport_wc_ucmem_data[i] = d
#define CLPORT_WC_UCMEM_DATAm_GET(r,i) (r).clport_wc_ucmem_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_WC_UCMEM_DATAm_UC_DATAf_GET(r,a) bcmpmac_field_get((r).clport_wc_ucmem_data,0,127,a)
#define CLPORT_WC_UCMEM_DATAm_UC_DATAf_SET(r,a) bcmpmac_field_set((r).clport_wc_ucmem_data,0,127,a)

/*
 * These macros can be used to access CLPORT_WC_UCMEM_DATA.
 */
#define READ_CLPORT_WC_UCMEM_DATAm(pa,p,i,m) bcmpmac_read(pa,p,CLPORT_WC_UCMEM_DATAm_OFFSET,i,CLPORT_WC_UCMEM_DATAm_SIZE,(m._clport_wc_ucmem_data))
#define WRITE_CLPORT_WC_UCMEM_DATAm(pa,p,i,m) bcmpmac_write(pa,p,CLPORT_WC_UCMEM_DATAm_OFFSET,i,CLPORT_WC_UCMEM_DATAm_SIZE,&(m._clport_wc_ucmem_data))

/*******************************************************************************
 * End of 'CLPORT_WC_UCMEM_DATAm'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_XGXS0_CTRL_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_XGXS0_CTRL_REGr_OFFSET 0x00021400

#define CLPORT_XGXS0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_XGXS0_CTRL_REG.
 */
typedef union CLPORT_XGXS0_CTRL_REGr_s {
	uint32_t v[1];
	uint32_t clport_xgxs0_ctrl_reg[1];
	uint32_t _clport_xgxs0_ctrl_reg;
} CLPORT_XGXS0_CTRL_REGr_t;

#define CLPORT_XGXS0_CTRL_REGr_CLR(r) (r).clport_xgxs0_ctrl_reg[0] = 0
#define CLPORT_XGXS0_CTRL_REGr_SET(r,d) (r).clport_xgxs0_ctrl_reg[0] = d
#define CLPORT_XGXS0_CTRL_REGr_GET(r) (r).clport_xgxs0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_XGXS0_CTRL_REGr_RSTB_HWf_GET(r) (((r).clport_xgxs0_ctrl_reg[0]) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_RSTB_HWf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 1) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_XGXS0_CTRL_REGr_REFIN_ENf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 2) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_REFIN_ENf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define CLPORT_XGXS0_CTRL_REGr_PWRDWNf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 3) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_PWRDWNf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define CLPORT_XGXS0_CTRL_REGr_IDDQf_GET(r) ((((r).clport_xgxs0_ctrl_reg[0]) >> 4) & 0x1)
#define CLPORT_XGXS0_CTRL_REGr_IDDQf_SET(r,f) (r).clport_xgxs0_ctrl_reg[0]=(((r).clport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access CLPORT_XGXS0_CTRL_REG.
 */
#define READ_CLPORT_XGXS0_CTRL_REGr(pa,p,r) bcmpmac_read(pa,p,CLPORT_XGXS0_CTRL_REGr_OFFSET,0,CLPORT_XGXS0_CTRL_REGr_SIZE,(r._clport_xgxs0_ctrl_reg))
#define WRITE_CLPORT_XGXS0_CTRL_REGr(pa,p,r) bcmpmac_write(pa,p,CLPORT_XGXS0_CTRL_REGr_OFFSET,0,CLPORT_XGXS0_CTRL_REGr_SIZE,&(r._clport_xgxs0_ctrl_reg))

/*******************************************************************************
 * End of 'CLPORT_XGXS0_CTRL_REGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_XGXS0_LN0_STATUS0_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_XGXS0_LN0_STATUS0_REGr_OFFSET 0x00021500

#define CLPORT_XGXS0_LN0_STATUS0_REGr_SIZE 4

/* CLPORT_XGXS0_LN0_STATUS0_REGr is element of CLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  CLPORT_XGXS0_LN1_STATUS0_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_XGXS0_LN1_STATUS0_REGr_OFFSET 0x00021600

#define CLPORT_XGXS0_LN1_STATUS0_REGr_SIZE 4

/* CLPORT_XGXS0_LN1_STATUS0_REGr is element of CLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  CLPORT_XGXS0_LN2_STATUS0_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_XGXS0_LN2_STATUS0_REGr_OFFSET 0x00021700

#define CLPORT_XGXS0_LN2_STATUS0_REGr_SIZE 4

/* CLPORT_XGXS0_LN2_STATUS0_REGr is element of CLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  CLPORT_XGXS0_LN3_STATUS0_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_XGXS0_LN3_STATUS0_REGr_OFFSET 0x00021800

#define CLPORT_XGXS0_LN3_STATUS0_REGr_SIZE 4

/* CLPORT_XGXS0_LN3_STATUS0_REGr is element of CLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  CLPORT_XGXS0_STATUS0_REG
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_XGXS0_STATUS0_REGr_OFFSET 0x00021500

#define CLPORT_XGXS0_STATUS0_REGr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_XGXS0_STATUS0_REG.
 */
typedef union CLPORT_XGXS0_STATUS0_REGr_s {
	uint32_t v[1];
	uint32_t clport_xgxs0_status0_reg[1];
	uint32_t _clport_xgxs0_status0_reg;
} CLPORT_XGXS0_STATUS0_REGr_t;

#define CLPORT_XGXS0_STATUS0_REGr_CLR(r) (r).clport_xgxs0_status0_reg[0] = 0
#define CLPORT_XGXS0_STATUS0_REGr_SET(r,d) (r).clport_xgxs0_status0_reg[0] = d
#define CLPORT_XGXS0_STATUS0_REGr_GET(r) (r).clport_xgxs0_status0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_XGXS0_STATUS0_REGr_LINK_STATUSf_GET(r) (((r).clport_xgxs0_status0_reg[0]) & 0x1)
#define CLPORT_XGXS0_STATUS0_REGr_LINK_STATUSf_SET(r,f) (r).clport_xgxs0_status0_reg[0]=(((r).clport_xgxs0_status0_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define CLPORT_XGXS0_STATUS0_REGr_SIG_DETf_GET(r) ((((r).clport_xgxs0_status0_reg[0]) >> 1) & 0x1)
#define CLPORT_XGXS0_STATUS0_REGr_SIG_DETf_SET(r,f) (r).clport_xgxs0_status0_reg[0]=(((r).clport_xgxs0_status0_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define CLPORT_XGXS0_STATUS0_REGr_PMD_LOCKf_GET(r) ((((r).clport_xgxs0_status0_reg[0]) >> 2) & 0x1)
#define CLPORT_XGXS0_STATUS0_REGr_PMD_LOCKf_SET(r,f) (r).clport_xgxs0_status0_reg[0]=(((r).clport_xgxs0_status0_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access CLPORT_XGXS0_STATUS0_REG.
 */
#define READ_CLPORT_XGXS0_STATUS0_REGr(pa,p,i,r) bcmpmac_read(pa,p,CLPORT_XGXS0_STATUS0_REGr_OFFSET,i,CLPORT_XGXS0_STATUS0_REGr_SIZE,(r._clport_xgxs0_status0_reg))
#define WRITE_CLPORT_XGXS0_STATUS0_REGr(pa,p,i,r) bcmpmac_write(pa,p,CLPORT_XGXS0_STATUS0_REGr_OFFSET,i,CLPORT_XGXS0_STATUS0_REGr_SIZE,&(r._clport_xgxs0_status0_reg))

/*******************************************************************************
 * End of 'CLPORT_XGXS0_STATUS0_REGr'
 */




/*******************************************************************************
 * REGISTER:  CLPORT_XGXS_COUNTER_MODE
 * BLOCKS:   CLPORT
 * SIZE:     32
 */
#define CLPORT_XGXS_COUNTER_MODEr_OFFSET 0x00021100

#define CLPORT_XGXS_COUNTER_MODEr_SIZE 4

/*
 * This structure should be used to declare and program CLPORT_XGXS_COUNTER_MODE.
 */
typedef union CLPORT_XGXS_COUNTER_MODEr_s {
	uint32_t v[1];
	uint32_t clport_xgxs_counter_mode[1];
	uint32_t _clport_xgxs_counter_mode;
} CLPORT_XGXS_COUNTER_MODEr_t;

#define CLPORT_XGXS_COUNTER_MODEr_CLR(r) (r).clport_xgxs_counter_mode[0] = 0
#define CLPORT_XGXS_COUNTER_MODEr_SET(r,d) (r).clport_xgxs_counter_mode[0] = d
#define CLPORT_XGXS_COUNTER_MODEr_GET(r) (r).clport_xgxs_counter_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define CLPORT_XGXS_COUNTER_MODEr_CNT_MODEf_GET(r) (((r).clport_xgxs_counter_mode[0]) & 0x1)
#define CLPORT_XGXS_COUNTER_MODEr_CNT_MODEf_SET(r,f) (r).clport_xgxs_counter_mode[0]=(((r).clport_xgxs_counter_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access CLPORT_XGXS_COUNTER_MODE.
 */
#define READ_CLPORT_XGXS_COUNTER_MODEr(pa,p,r) bcmpmac_read(pa,p,CLPORT_XGXS_COUNTER_MODEr_OFFSET,0,CLPORT_XGXS_COUNTER_MODEr_SIZE,(r._clport_xgxs_counter_mode))
#define WRITE_CLPORT_XGXS_COUNTER_MODEr(pa,p,r) bcmpmac_write(pa,p,CLPORT_XGXS_COUNTER_MODEr_OFFSET,0,CLPORT_XGXS_COUNTER_MODEr_SIZE,&(r._clport_xgxs_counter_mode))

/*******************************************************************************
 * End of 'CLPORT_XGXS_COUNTER_MODEr'
 */




/*******************************************************************************
 * REGISTER:  R1023
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R1023r_OFFSET 0x00000400

#define R1023r_SIZE 8

/*
 * This structure should be used to declare and program R1023.
 */
typedef union R1023r_s {
	uint32_t v[2];
	uint32_t r1023[2];
	uint32_t _r1023;
} R1023r_t;

#define R1023r_CLR(r) sal_memset(&((r)._r1023), 0, sizeof(R1023r_t))
#define R1023r_SET(r,i,d) (r).r1023[i] = d
#define R1023r_GET(r,i) (r).r1023[i]

/*
 * These macros can be used to access individual fields.
 */
#define R1023r_COUNTf_GET(r,a) bcmpmac_field_get((r).r1023,0,39,a)
#define R1023r_COUNTf_SET(r,a) bcmpmac_field_set((r).r1023,0,39,a)

/*
 * These macros can be used to access R1023.
 */
#define READ_R1023r(pa,p,r) bcmpmac_read(pa,p,R1023r_OFFSET,0,R1023r_SIZE,(r._r1023))
#define WRITE_R1023r(pa,p,r) bcmpmac_write(pa,p,R1023r_OFFSET,0,R1023r_SIZE,&(r._r1023))

/*******************************************************************************
 * End of 'R1023r'
 */




/*******************************************************************************
 * REGISTER:  R127
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R127r_OFFSET 0x00000100

#define R127r_SIZE 8

/*
 * This structure should be used to declare and program R127.
 */
typedef union R127r_s {
	uint32_t v[2];
	uint32_t r127[2];
	uint32_t _r127;
} R127r_t;

#define R127r_CLR(r) sal_memset(&((r)._r127), 0, sizeof(R127r_t))
#define R127r_SET(r,i,d) (r).r127[i] = d
#define R127r_GET(r,i) (r).r127[i]

/*
 * These macros can be used to access individual fields.
 */
#define R127r_COUNTf_GET(r,a) bcmpmac_field_get((r).r127,0,39,a)
#define R127r_COUNTf_SET(r,a) bcmpmac_field_set((r).r127,0,39,a)

/*
 * These macros can be used to access R127.
 */
#define READ_R127r(pa,p,r) bcmpmac_read(pa,p,R127r_OFFSET,0,R127r_SIZE,(r._r127))
#define WRITE_R127r(pa,p,r) bcmpmac_write(pa,p,R127r_OFFSET,0,R127r_SIZE,&(r._r127))

/*******************************************************************************
 * End of 'R127r'
 */




/*******************************************************************************
 * REGISTER:  R1518
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R1518r_OFFSET 0x00000500

#define R1518r_SIZE 8

/*
 * This structure should be used to declare and program R1518.
 */
typedef union R1518r_s {
	uint32_t v[2];
	uint32_t r1518[2];
	uint32_t _r1518;
} R1518r_t;

#define R1518r_CLR(r) sal_memset(&((r)._r1518), 0, sizeof(R1518r_t))
#define R1518r_SET(r,i,d) (r).r1518[i] = d
#define R1518r_GET(r,i) (r).r1518[i]

/*
 * These macros can be used to access individual fields.
 */
#define R1518r_COUNTf_GET(r,a) bcmpmac_field_get((r).r1518,0,39,a)
#define R1518r_COUNTf_SET(r,a) bcmpmac_field_set((r).r1518,0,39,a)

/*
 * These macros can be used to access R1518.
 */
#define READ_R1518r(pa,p,r) bcmpmac_read(pa,p,R1518r_OFFSET,0,R1518r_SIZE,(r._r1518))
#define WRITE_R1518r(pa,p,r) bcmpmac_write(pa,p,R1518r_OFFSET,0,R1518r_SIZE,&(r._r1518))

/*******************************************************************************
 * End of 'R1518r'
 */




/*******************************************************************************
 * REGISTER:  R16383
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R16383r_OFFSET 0x00000a00

#define R16383r_SIZE 8

/*
 * This structure should be used to declare and program R16383.
 */
typedef union R16383r_s {
	uint32_t v[2];
	uint32_t r16383[2];
	uint32_t _r16383;
} R16383r_t;

#define R16383r_CLR(r) sal_memset(&((r)._r16383), 0, sizeof(R16383r_t))
#define R16383r_SET(r,i,d) (r).r16383[i] = d
#define R16383r_GET(r,i) (r).r16383[i]

/*
 * These macros can be used to access individual fields.
 */
#define R16383r_COUNTf_GET(r,a) bcmpmac_field_get((r).r16383,0,39,a)
#define R16383r_COUNTf_SET(r,a) bcmpmac_field_set((r).r16383,0,39,a)

/*
 * These macros can be used to access R16383.
 */
#define READ_R16383r(pa,p,r) bcmpmac_read(pa,p,R16383r_OFFSET,0,R16383r_SIZE,(r._r16383))
#define WRITE_R16383r(pa,p,r) bcmpmac_write(pa,p,R16383r_OFFSET,0,R16383r_SIZE,&(r._r16383))

/*******************************************************************************
 * End of 'R16383r'
 */




/*******************************************************************************
 * REGISTER:  R2047
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R2047r_OFFSET 0x00000700

#define R2047r_SIZE 8

/*
 * This structure should be used to declare and program R2047.
 */
typedef union R2047r_s {
	uint32_t v[2];
	uint32_t r2047[2];
	uint32_t _r2047;
} R2047r_t;

#define R2047r_CLR(r) sal_memset(&((r)._r2047), 0, sizeof(R2047r_t))
#define R2047r_SET(r,i,d) (r).r2047[i] = d
#define R2047r_GET(r,i) (r).r2047[i]

/*
 * These macros can be used to access individual fields.
 */
#define R2047r_COUNTf_GET(r,a) bcmpmac_field_get((r).r2047,0,39,a)
#define R2047r_COUNTf_SET(r,a) bcmpmac_field_set((r).r2047,0,39,a)

/*
 * These macros can be used to access R2047.
 */
#define READ_R2047r(pa,p,r) bcmpmac_read(pa,p,R2047r_OFFSET,0,R2047r_SIZE,(r._r2047))
#define WRITE_R2047r(pa,p,r) bcmpmac_write(pa,p,R2047r_OFFSET,0,R2047r_SIZE,&(r._r2047))

/*******************************************************************************
 * End of 'R2047r'
 */




/*******************************************************************************
 * REGISTER:  R255
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R255r_OFFSET 0x00000200

#define R255r_SIZE 8

/*
 * This structure should be used to declare and program R255.
 */
typedef union R255r_s {
	uint32_t v[2];
	uint32_t r255[2];
	uint32_t _r255;
} R255r_t;

#define R255r_CLR(r) sal_memset(&((r)._r255), 0, sizeof(R255r_t))
#define R255r_SET(r,i,d) (r).r255[i] = d
#define R255r_GET(r,i) (r).r255[i]

/*
 * These macros can be used to access individual fields.
 */
#define R255r_COUNTf_GET(r,a) bcmpmac_field_get((r).r255,0,39,a)
#define R255r_COUNTf_SET(r,a) bcmpmac_field_set((r).r255,0,39,a)

/*
 * These macros can be used to access R255.
 */
#define READ_R255r(pa,p,r) bcmpmac_read(pa,p,R255r_OFFSET,0,R255r_SIZE,(r._r255))
#define WRITE_R255r(pa,p,r) bcmpmac_write(pa,p,R255r_OFFSET,0,R255r_SIZE,&(r._r255))

/*******************************************************************************
 * End of 'R255r'
 */




/*******************************************************************************
 * REGISTER:  R4095
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R4095r_OFFSET 0x00000800

#define R4095r_SIZE 8

/*
 * This structure should be used to declare and program R4095.
 */
typedef union R4095r_s {
	uint32_t v[2];
	uint32_t r4095[2];
	uint32_t _r4095;
} R4095r_t;

#define R4095r_CLR(r) sal_memset(&((r)._r4095), 0, sizeof(R4095r_t))
#define R4095r_SET(r,i,d) (r).r4095[i] = d
#define R4095r_GET(r,i) (r).r4095[i]

/*
 * These macros can be used to access individual fields.
 */
#define R4095r_COUNTf_GET(r,a) bcmpmac_field_get((r).r4095,0,39,a)
#define R4095r_COUNTf_SET(r,a) bcmpmac_field_set((r).r4095,0,39,a)

/*
 * These macros can be used to access R4095.
 */
#define READ_R4095r(pa,p,r) bcmpmac_read(pa,p,R4095r_OFFSET,0,R4095r_SIZE,(r._r4095))
#define WRITE_R4095r(pa,p,r) bcmpmac_write(pa,p,R4095r_OFFSET,0,R4095r_SIZE,&(r._r4095))

/*******************************************************************************
 * End of 'R4095r'
 */




/*******************************************************************************
 * REGISTER:  R511
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R511r_OFFSET 0x00000300

#define R511r_SIZE 8

/*
 * This structure should be used to declare and program R511.
 */
typedef union R511r_s {
	uint32_t v[2];
	uint32_t r511[2];
	uint32_t _r511;
} R511r_t;

#define R511r_CLR(r) sal_memset(&((r)._r511), 0, sizeof(R511r_t))
#define R511r_SET(r,i,d) (r).r511[i] = d
#define R511r_GET(r,i) (r).r511[i]

/*
 * These macros can be used to access individual fields.
 */
#define R511r_COUNTf_GET(r,a) bcmpmac_field_get((r).r511,0,39,a)
#define R511r_COUNTf_SET(r,a) bcmpmac_field_set((r).r511,0,39,a)

/*
 * These macros can be used to access R511.
 */
#define READ_R511r(pa,p,r) bcmpmac_read(pa,p,R511r_OFFSET,0,R511r_SIZE,(r._r511))
#define WRITE_R511r(pa,p,r) bcmpmac_write(pa,p,R511r_OFFSET,0,R511r_SIZE,&(r._r511))

/*******************************************************************************
 * End of 'R511r'
 */




/*******************************************************************************
 * REGISTER:  R64
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R64r_OFFSET 0x00000000

#define R64r_SIZE 8

/*
 * This structure should be used to declare and program R64.
 */
typedef union R64r_s {
	uint32_t v[2];
	uint32_t r64[2];
	uint32_t _r64;
} R64r_t;

#define R64r_CLR(r) sal_memset(&((r)._r64), 0, sizeof(R64r_t))
#define R64r_SET(r,i,d) (r).r64[i] = d
#define R64r_GET(r,i) (r).r64[i]

/*
 * These macros can be used to access individual fields.
 */
#define R64r_COUNTf_GET(r,a) bcmpmac_field_get((r).r64,0,39,a)
#define R64r_COUNTf_SET(r,a) bcmpmac_field_set((r).r64,0,39,a)

/*
 * These macros can be used to access R64.
 */
#define READ_R64r(pa,p,r) bcmpmac_read(pa,p,R64r_OFFSET,0,R64r_SIZE,(r._r64))
#define WRITE_R64r(pa,p,r) bcmpmac_write(pa,p,R64r_OFFSET,0,R64r_SIZE,&(r._r64))

/*******************************************************************************
 * End of 'R64r'
 */




/*******************************************************************************
 * REGISTER:  R9216
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define R9216r_OFFSET 0x00000900

#define R9216r_SIZE 8

/*
 * This structure should be used to declare and program R9216.
 */
typedef union R9216r_s {
	uint32_t v[2];
	uint32_t r9216[2];
	uint32_t _r9216;
} R9216r_t;

#define R9216r_CLR(r) sal_memset(&((r)._r9216), 0, sizeof(R9216r_t))
#define R9216r_SET(r,i,d) (r).r9216[i] = d
#define R9216r_GET(r,i) (r).r9216[i]

/*
 * These macros can be used to access individual fields.
 */
#define R9216r_COUNTf_GET(r,a) bcmpmac_field_get((r).r9216,0,39,a)
#define R9216r_COUNTf_SET(r,a) bcmpmac_field_set((r).r9216,0,39,a)

/*
 * These macros can be used to access R9216.
 */
#define READ_R9216r(pa,p,r) bcmpmac_read(pa,p,R9216r_OFFSET,0,R9216r_SIZE,(r._r9216))
#define WRITE_R9216r(pa,p,r) bcmpmac_write(pa,p,R9216r_OFFSET,0,R9216r_SIZE,&(r._r9216))

/*******************************************************************************
 * End of 'R9216r'
 */




/*******************************************************************************
 * REGISTER:  RALN
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RALNr_OFFSET 0x00001600

#define RALNr_SIZE 8

/*
 * This structure should be used to declare and program RALN.
 */
typedef union RALNr_s {
	uint32_t v[2];
	uint32_t raln[2];
	uint32_t _raln;
} RALNr_t;

#define RALNr_CLR(r) sal_memset(&((r)._raln), 0, sizeof(RALNr_t))
#define RALNr_SET(r,i,d) (r).raln[i] = d
#define RALNr_GET(r,i) (r).raln[i]

/*
 * These macros can be used to access individual fields.
 */
#define RALNr_COUNTf_GET(r,a) bcmpmac_field_get((r).raln,0,39,a)
#define RALNr_COUNTf_SET(r,a) bcmpmac_field_set((r).raln,0,39,a)

/*
 * These macros can be used to access RALN.
 */
#define READ_RALNr(pa,p,r) bcmpmac_read(pa,p,RALNr_OFFSET,0,RALNr_SIZE,(r._raln))
#define WRITE_RALNr(pa,p,r) bcmpmac_write(pa,p,RALNr_OFFSET,0,RALNr_SIZE,&(r._raln))

/*******************************************************************************
 * End of 'RALNr'
 */




/*******************************************************************************
 * REGISTER:  RBCA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RBCAr_OFFSET 0x00000e00

#define RBCAr_SIZE 8

/*
 * This structure should be used to declare and program RBCA.
 */
typedef union RBCAr_s {
	uint32_t v[2];
	uint32_t rbca[2];
	uint32_t _rbca;
} RBCAr_t;

#define RBCAr_CLR(r) sal_memset(&((r)._rbca), 0, sizeof(RBCAr_t))
#define RBCAr_SET(r,i,d) (r).rbca[i] = d
#define RBCAr_GET(r,i) (r).rbca[i]

/*
 * These macros can be used to access individual fields.
 */
#define RBCAr_COUNTf_GET(r,a) bcmpmac_field_get((r).rbca,0,39,a)
#define RBCAr_COUNTf_SET(r,a) bcmpmac_field_set((r).rbca,0,39,a)

/*
 * These macros can be used to access RBCA.
 */
#define READ_RBCAr(pa,p,r) bcmpmac_read(pa,p,RBCAr_OFFSET,0,RBCAr_SIZE,(r._rbca))
#define WRITE_RBCAr(pa,p,r) bcmpmac_write(pa,p,RBCAr_OFFSET,0,RBCAr_SIZE,&(r._rbca))

/*******************************************************************************
 * End of 'RBCAr'
 */




/*******************************************************************************
 * REGISTER:  RBYT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RBYTr_OFFSET 0x00003d00

#define RBYTr_SIZE 8

/*
 * This structure should be used to declare and program RBYT.
 */
typedef union RBYTr_s {
	uint32_t v[2];
	uint32_t rbyt[2];
	uint32_t _rbyt;
} RBYTr_t;

#define RBYTr_CLR(r) sal_memset(&((r)._rbyt), 0, sizeof(RBYTr_t))
#define RBYTr_SET(r,i,d) (r).rbyt[i] = d
#define RBYTr_GET(r,i) (r).rbyt[i]

/*
 * These macros can be used to access individual fields.
 */
#define RBYTr_COUNTf_GET(r,a) bcmpmac_field_get((r).rbyt,0,47,a)
#define RBYTr_COUNTf_SET(r,a) bcmpmac_field_set((r).rbyt,0,47,a)

/*
 * These macros can be used to access RBYT.
 */
#define READ_RBYTr(pa,p,r) bcmpmac_read(pa,p,RBYTr_OFFSET,0,RBYTr_SIZE,(r._rbyt))
#define WRITE_RBYTr(pa,p,r) bcmpmac_write(pa,p,RBYTr_OFFSET,0,RBYTr_SIZE,&(r._rbyt))

/*******************************************************************************
 * End of 'RBYTr'
 */




/*******************************************************************************
 * REGISTER:  RDVLN
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RDVLNr_OFFSET 0x10002000

#define RDVLNr_SIZE 8

/*
 * This structure should be used to declare and program RDVLN.
 */
typedef union RDVLNr_s {
	uint32_t v[2];
	uint32_t rdvln[2];
	uint32_t _rdvln;
} RDVLNr_t;

#define RDVLNr_CLR(r) sal_memset(&((r)._rdvln), 0, sizeof(RDVLNr_t))
#define RDVLNr_SET(r,i,d) (r).rdvln[i] = d
#define RDVLNr_GET(r,i) (r).rdvln[i]

/*
 * These macros can be used to access individual fields.
 */
#define RDVLNr_COUNTf_GET(r,a) bcmpmac_field_get((r).rdvln,0,39,a)
#define RDVLNr_COUNTf_SET(r,a) bcmpmac_field_set((r).rdvln,0,39,a)

/*
 * These macros can be used to access RDVLN.
 */
#define READ_RDVLNr(pa,p,r) bcmpmac_read(pa,p,RDVLNr_OFFSET,0,RDVLNr_SIZE,(r._rdvln))
#define WRITE_RDVLNr(pa,p,r) bcmpmac_write(pa,p,RDVLNr_OFFSET,0,RDVLNr_SIZE,&(r._rdvln))

/*******************************************************************************
 * End of 'RDVLNr'
 */




/*******************************************************************************
 * REGISTER:  RERPKT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RERPKTr_OFFSET 0x00001800

#define RERPKTr_SIZE 8

/*
 * This structure should be used to declare and program RERPKT.
 */
typedef union RERPKTr_s {
	uint32_t v[2];
	uint32_t rerpkt[2];
	uint32_t _rerpkt;
} RERPKTr_t;

#define RERPKTr_CLR(r) sal_memset(&((r)._rerpkt), 0, sizeof(RERPKTr_t))
#define RERPKTr_SET(r,i,d) (r).rerpkt[i] = d
#define RERPKTr_GET(r,i) (r).rerpkt[i]

/*
 * These macros can be used to access individual fields.
 */
#define RERPKTr_COUNTf_GET(r,a) bcmpmac_field_get((r).rerpkt,0,39,a)
#define RERPKTr_COUNTf_SET(r,a) bcmpmac_field_set((r).rerpkt,0,39,a)

/*
 * These macros can be used to access RERPKT.
 */
#define READ_RERPKTr(pa,p,r) bcmpmac_read(pa,p,RERPKTr_OFFSET,0,RERPKTr_SIZE,(r._rerpkt))
#define WRITE_RERPKTr(pa,p,r) bcmpmac_write(pa,p,RERPKTr_OFFSET,0,RERPKTr_SIZE,&(r._rerpkt))

/*******************************************************************************
 * End of 'RERPKTr'
 */




/*******************************************************************************
 * REGISTER:  RFCR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RFCRr_OFFSET 0x00001900

#define RFCRr_SIZE 8

/*
 * This structure should be used to declare and program RFCR.
 */
typedef union RFCRr_s {
	uint32_t v[2];
	uint32_t rfcr[2];
	uint32_t _rfcr;
} RFCRr_t;

#define RFCRr_CLR(r) sal_memset(&((r)._rfcr), 0, sizeof(RFCRr_t))
#define RFCRr_SET(r,i,d) (r).rfcr[i] = d
#define RFCRr_GET(r,i) (r).rfcr[i]

/*
 * These macros can be used to access individual fields.
 */
#define RFCRr_COUNTf_GET(r,a) bcmpmac_field_get((r).rfcr,0,39,a)
#define RFCRr_COUNTf_SET(r,a) bcmpmac_field_set((r).rfcr,0,39,a)

/*
 * These macros can be used to access RFCR.
 */
#define READ_RFCRr(pa,p,r) bcmpmac_read(pa,p,RFCRr_OFFSET,0,RFCRr_SIZE,(r._rfcr))
#define WRITE_RFCRr(pa,p,r) bcmpmac_write(pa,p,RFCRr_OFFSET,0,RFCRr_SIZE,&(r._rfcr))

/*******************************************************************************
 * End of 'RFCRr'
 */




/*******************************************************************************
 * REGISTER:  RFCS
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RFCSr_OFFSET 0x00000f00

#define RFCSr_SIZE 8

/*
 * This structure should be used to declare and program RFCS.
 */
typedef union RFCSr_s {
	uint32_t v[2];
	uint32_t rfcs[2];
	uint32_t _rfcs;
} RFCSr_t;

#define RFCSr_CLR(r) sal_memset(&((r)._rfcs), 0, sizeof(RFCSr_t))
#define RFCSr_SET(r,i,d) (r).rfcs[i] = d
#define RFCSr_GET(r,i) (r).rfcs[i]

/*
 * These macros can be used to access individual fields.
 */
#define RFCSr_COUNTf_GET(r,a) bcmpmac_field_get((r).rfcs,0,39,a)
#define RFCSr_COUNTf_SET(r,a) bcmpmac_field_set((r).rfcs,0,39,a)

/*
 * These macros can be used to access RFCS.
 */
#define READ_RFCSr(pa,p,r) bcmpmac_read(pa,p,RFCSr_OFFSET,0,RFCSr_SIZE,(r._rfcs))
#define WRITE_RFCSr(pa,p,r) bcmpmac_write(pa,p,RFCSr_OFFSET,0,RFCSr_SIZE,&(r._rfcs))

/*******************************************************************************
 * End of 'RFCSr'
 */




/*******************************************************************************
 * REGISTER:  RFLR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RFLRr_OFFSET 0x00001700

#define RFLRr_SIZE 8

/*
 * This structure should be used to declare and program RFLR.
 */
typedef union RFLRr_s {
	uint32_t v[2];
	uint32_t rflr[2];
	uint32_t _rflr;
} RFLRr_t;

#define RFLRr_CLR(r) sal_memset(&((r)._rflr), 0, sizeof(RFLRr_t))
#define RFLRr_SET(r,i,d) (r).rflr[i] = d
#define RFLRr_GET(r,i) (r).rflr[i]

/*
 * These macros can be used to access individual fields.
 */
#define RFLRr_COUNTf_GET(r,a) bcmpmac_field_get((r).rflr,0,39,a)
#define RFLRr_COUNTf_SET(r,a) bcmpmac_field_set((r).rflr,0,39,a)

/*
 * These macros can be used to access RFLR.
 */
#define READ_RFLRr(pa,p,r) bcmpmac_read(pa,p,RFLRr_OFFSET,0,RFLRr_SIZE,(r._rflr))
#define WRITE_RFLRr(pa,p,r) bcmpmac_write(pa,p,RFLRr_OFFSET,0,RFLRr_SIZE,&(r._rflr))

/*******************************************************************************
 * End of 'RFLRr'
 */




/*******************************************************************************
 * REGISTER:  RFRG
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RFRGr_OFFSET 0x10003500

#define RFRGr_SIZE 8

/*
 * This structure should be used to declare and program RFRG.
 */
typedef union RFRGr_s {
	uint32_t v[2];
	uint32_t rfrg[2];
	uint32_t _rfrg;
} RFRGr_t;

#define RFRGr_CLR(r) sal_memset(&((r)._rfrg), 0, sizeof(RFRGr_t))
#define RFRGr_SET(r,i,d) (r).rfrg[i] = d
#define RFRGr_GET(r,i) (r).rfrg[i]

/*
 * These macros can be used to access individual fields.
 */
#define RFRGr_COUNTf_GET(r,a) bcmpmac_field_get((r).rfrg,0,39,a)
#define RFRGr_COUNTf_SET(r,a) bcmpmac_field_set((r).rfrg,0,39,a)

/*
 * These macros can be used to access RFRG.
 */
#define READ_RFRGr(pa,p,r) bcmpmac_read(pa,p,RFRGr_OFFSET,0,RFRGr_SIZE,(r._rfrg))
#define WRITE_RFRGr(pa,p,r) bcmpmac_write(pa,p,RFRGr_OFFSET,0,RFRGr_SIZE,&(r._rfrg))

/*******************************************************************************
 * End of 'RFRGr'
 */




/*******************************************************************************
 * REGISTER:  RJBR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RJBRr_OFFSET 0x00001b00

#define RJBRr_SIZE 8

/*
 * This structure should be used to declare and program RJBR.
 */
typedef union RJBRr_s {
	uint32_t v[2];
	uint32_t rjbr[2];
	uint32_t _rjbr;
} RJBRr_t;

#define RJBRr_CLR(r) sal_memset(&((r)._rjbr), 0, sizeof(RJBRr_t))
#define RJBRr_SET(r,i,d) (r).rjbr[i] = d
#define RJBRr_GET(r,i) (r).rjbr[i]

/*
 * These macros can be used to access individual fields.
 */
#define RJBRr_COUNTf_GET(r,a) bcmpmac_field_get((r).rjbr,0,39,a)
#define RJBRr_COUNTf_SET(r,a) bcmpmac_field_set((r).rjbr,0,39,a)

/*
 * These macros can be used to access RJBR.
 */
#define READ_RJBRr(pa,p,r) bcmpmac_read(pa,p,RJBRr_OFFSET,0,RJBRr_SIZE,(r._rjbr))
#define WRITE_RJBRr(pa,p,r) bcmpmac_write(pa,p,RJBRr_OFFSET,0,RJBRr_SIZE,&(r._rjbr))

/*******************************************************************************
 * End of 'RJBRr'
 */




/*******************************************************************************
 * REGISTER:  RMCA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RMCAr_OFFSET 0x00000d00

#define RMCAr_SIZE 8

/*
 * This structure should be used to declare and program RMCA.
 */
typedef union RMCAr_s {
	uint32_t v[2];
	uint32_t rmca[2];
	uint32_t _rmca;
} RMCAr_t;

#define RMCAr_CLR(r) sal_memset(&((r)._rmca), 0, sizeof(RMCAr_t))
#define RMCAr_SET(r,i,d) (r).rmca[i] = d
#define RMCAr_GET(r,i) (r).rmca[i]

/*
 * These macros can be used to access individual fields.
 */
#define RMCAr_COUNTf_GET(r,a) bcmpmac_field_get((r).rmca,0,39,a)
#define RMCAr_COUNTf_SET(r,a) bcmpmac_field_set((r).rmca,0,39,a)

/*
 * These macros can be used to access RMCA.
 */
#define READ_RMCAr(pa,p,r) bcmpmac_read(pa,p,RMCAr_OFFSET,0,RMCAr_SIZE,(r._rmca))
#define WRITE_RMCAr(pa,p,r) bcmpmac_write(pa,p,RMCAr_OFFSET,0,RMCAr_SIZE,&(r._rmca))

/*******************************************************************************
 * End of 'RMCAr'
 */




/*******************************************************************************
 * REGISTER:  RMCRC
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RMCRCr_OFFSET 0x10001d00

#define RMCRCr_SIZE 8

/*
 * This structure should be used to declare and program RMCRC.
 */
typedef union RMCRCr_s {
	uint32_t v[2];
	uint32_t rmcrc[2];
	uint32_t _rmcrc;
} RMCRCr_t;

#define RMCRCr_CLR(r) sal_memset(&((r)._rmcrc), 0, sizeof(RMCRCr_t))
#define RMCRCr_SET(r,i,d) (r).rmcrc[i] = d
#define RMCRCr_GET(r,i) (r).rmcrc[i]

/*
 * These macros can be used to access individual fields.
 */
#define RMCRCr_COUNTf_GET(r,a) bcmpmac_field_get((r).rmcrc,0,39,a)
#define RMCRCr_COUNTf_SET(r,a) bcmpmac_field_set((r).rmcrc,0,39,a)

/*
 * These macros can be used to access RMCRC.
 */
#define READ_RMCRCr(pa,p,r) bcmpmac_read(pa,p,RMCRCr_OFFSET,0,RMCRCr_SIZE,(r._rmcrc))
#define WRITE_RMCRCr(pa,p,r) bcmpmac_write(pa,p,RMCRCr_OFFSET,0,RMCRCr_SIZE,&(r._rmcrc))

/*******************************************************************************
 * End of 'RMCRCr'
 */




/*******************************************************************************
 * REGISTER:  RMGV
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RMGVr_OFFSET 0x00000600

#define RMGVr_SIZE 8

/*
 * This structure should be used to declare and program RMGV.
 */
typedef union RMGVr_s {
	uint32_t v[2];
	uint32_t rmgv[2];
	uint32_t _rmgv;
} RMGVr_t;

#define RMGVr_CLR(r) sal_memset(&((r)._rmgv), 0, sizeof(RMGVr_t))
#define RMGVr_SET(r,i,d) (r).rmgv[i] = d
#define RMGVr_GET(r,i) (r).rmgv[i]

/*
 * These macros can be used to access individual fields.
 */
#define RMGVr_COUNTf_GET(r,a) bcmpmac_field_get((r).rmgv,0,39,a)
#define RMGVr_COUNTf_SET(r,a) bcmpmac_field_set((r).rmgv,0,39,a)

/*
 * These macros can be used to access RMGV.
 */
#define READ_RMGVr(pa,p,r) bcmpmac_read(pa,p,RMGVr_OFFSET,0,RMGVr_SIZE,(r._rmgv))
#define WRITE_RMGVr(pa,p,r) bcmpmac_write(pa,p,RMGVr_OFFSET,0,RMGVr_SIZE,&(r._rmgv))

/*******************************************************************************
 * End of 'RMGVr'
 */




/*******************************************************************************
 * REGISTER:  RMTUE
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RMTUEr_OFFSET 0x00001c00

#define RMTUEr_SIZE 8

/*
 * This structure should be used to declare and program RMTUE.
 */
typedef union RMTUEr_s {
	uint32_t v[2];
	uint32_t rmtue[2];
	uint32_t _rmtue;
} RMTUEr_t;

#define RMTUEr_CLR(r) sal_memset(&((r)._rmtue), 0, sizeof(RMTUEr_t))
#define RMTUEr_SET(r,i,d) (r).rmtue[i] = d
#define RMTUEr_GET(r,i) (r).rmtue[i]

/*
 * These macros can be used to access individual fields.
 */
#define RMTUEr_COUNTf_GET(r,a) bcmpmac_field_get((r).rmtue,0,39,a)
#define RMTUEr_COUNTf_SET(r,a) bcmpmac_field_set((r).rmtue,0,39,a)

/*
 * These macros can be used to access RMTUE.
 */
#define READ_RMTUEr(pa,p,r) bcmpmac_read(pa,p,RMTUEr_OFFSET,0,RMTUEr_SIZE,(r._rmtue))
#define WRITE_RMTUEr(pa,p,r) bcmpmac_write(pa,p,RMTUEr_OFFSET,0,RMTUEr_SIZE,&(r._rmtue))

/*******************************************************************************
 * End of 'RMTUEr'
 */




/*******************************************************************************
 * REGISTER:  ROVR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define ROVRr_OFFSET 0x00001a00

#define ROVRr_SIZE 8

/*
 * This structure should be used to declare and program ROVR.
 */
typedef union ROVRr_s {
	uint32_t v[2];
	uint32_t rovr[2];
	uint32_t _rovr;
} ROVRr_t;

#define ROVRr_CLR(r) sal_memset(&((r)._rovr), 0, sizeof(ROVRr_t))
#define ROVRr_SET(r,i,d) (r).rovr[i] = d
#define ROVRr_GET(r,i) (r).rovr[i]

/*
 * These macros can be used to access individual fields.
 */
#define ROVRr_COUNTf_GET(r,a) bcmpmac_field_get((r).rovr,0,39,a)
#define ROVRr_COUNTf_SET(r,a) bcmpmac_field_set((r).rovr,0,39,a)

/*
 * These macros can be used to access ROVR.
 */
#define READ_ROVRr(pa,p,r) bcmpmac_read(pa,p,ROVRr_OFFSET,0,ROVRr_SIZE,(r._rovr))
#define WRITE_ROVRr(pa,p,r) bcmpmac_write(pa,p,ROVRr_OFFSET,0,ROVRr_SIZE,&(r._rovr))

/*******************************************************************************
 * End of 'ROVRr'
 */




/*******************************************************************************
 * REGISTER:  RPFC
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCr_OFFSET 0x10002b00

#define RPFCr_SIZE 8

/*
 * This structure should be used to declare and program RPFC.
 */
typedef union RPFCr_s {
	uint32_t v[2];
	uint32_t rpfc[2];
	uint32_t _rpfc;
} RPFCr_t;

#define RPFCr_CLR(r) sal_memset(&((r)._rpfc), 0, sizeof(RPFCr_t))
#define RPFCr_SET(r,i,d) (r).rpfc[i] = d
#define RPFCr_GET(r,i) (r).rpfc[i]

/*
 * These macros can be used to access individual fields.
 */
#define RPFCr_COUNTf_GET(r,a) bcmpmac_field_get((r).rpfc,0,39,a)
#define RPFCr_COUNTf_SET(r,a) bcmpmac_field_set((r).rpfc,0,39,a)

/*
 * These macros can be used to access RPFC.
 */
#define READ_RPFCr(pa,p,i,r) bcmpmac_read(pa,p,RPFCr_OFFSET,i,RPFCr_SIZE,(r._rpfc))
#define WRITE_RPFCr(pa,p,i,r) bcmpmac_write(pa,p,RPFCr_OFFSET,i,RPFCr_SIZE,&(r._rpfc))

/*******************************************************************************
 * End of 'RPFCr'
 */




/*******************************************************************************
 * REGISTER:  RPFC0
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC0r_OFFSET 0x10002b00

#define RPFC0r_SIZE 8

/* RPFC0r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFC1
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC1r_OFFSET 0x10002c00

#define RPFC1r_SIZE 8

/* RPFC1r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFC2
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC2r_OFFSET 0x10002d00

#define RPFC2r_SIZE 8

/* RPFC2r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFC3
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC3r_OFFSET 0x10002e00

#define RPFC3r_SIZE 8

/* RPFC3r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFC4
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC4r_OFFSET 0x10002f00

#define RPFC4r_SIZE 8

/* RPFC4r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFC5
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC5r_OFFSET 0x10003000

#define RPFC5r_SIZE 8

/* RPFC5r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFC6
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC6r_OFFSET 0x10003100

#define RPFC6r_SIZE 8

/* RPFC6r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFC7
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFC7r_OFFSET 0x10003200

#define RPFC7r_SIZE 8

/* RPFC7r is element of RPFC */

/*******************************************************************************
 * REGISTER:  RPFCOFF
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFFr_OFFSET 0x10002300

#define RPFCOFFr_SIZE 8

/*
 * This structure should be used to declare and program RPFCOFF.
 */
typedef union RPFCOFFr_s {
	uint32_t v[2];
	uint32_t rpfcoff[2];
	uint32_t _rpfcoff;
} RPFCOFFr_t;

#define RPFCOFFr_CLR(r) sal_memset(&((r)._rpfcoff), 0, sizeof(RPFCOFFr_t))
#define RPFCOFFr_SET(r,i,d) (r).rpfcoff[i] = d
#define RPFCOFFr_GET(r,i) (r).rpfcoff[i]

/*
 * These macros can be used to access individual fields.
 */
#define RPFCOFFr_COUNTf_GET(r,a) bcmpmac_field_get((r).rpfcoff,0,39,a)
#define RPFCOFFr_COUNTf_SET(r,a) bcmpmac_field_set((r).rpfcoff,0,39,a)

/*
 * These macros can be used to access RPFCOFF.
 */
#define READ_RPFCOFFr(pa,p,i,r) bcmpmac_read(pa,p,RPFCOFFr_OFFSET,i,RPFCOFFr_SIZE,(r._rpfcoff))
#define WRITE_RPFCOFFr(pa,p,i,r) bcmpmac_write(pa,p,RPFCOFFr_OFFSET,i,RPFCOFFr_SIZE,&(r._rpfcoff))

/*******************************************************************************
 * End of 'RPFCOFFr'
 */




/*******************************************************************************
 * REGISTER:  RPFCOFF0
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF0r_OFFSET 0x10002300

#define RPFCOFF0r_SIZE 8

/* RPFCOFF0r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPFCOFF1
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF1r_OFFSET 0x10002400

#define RPFCOFF1r_SIZE 8

/* RPFCOFF1r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPFCOFF2
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF2r_OFFSET 0x10002500

#define RPFCOFF2r_SIZE 8

/* RPFCOFF2r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPFCOFF3
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF3r_OFFSET 0x10002600

#define RPFCOFF3r_SIZE 8

/* RPFCOFF3r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPFCOFF4
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF4r_OFFSET 0x10002700

#define RPFCOFF4r_SIZE 8

/* RPFCOFF4r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPFCOFF5
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF5r_OFFSET 0x10002800

#define RPFCOFF5r_SIZE 8

/* RPFCOFF5r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPFCOFF6
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF6r_OFFSET 0x10002900

#define RPFCOFF6r_SIZE 8

/* RPFCOFF6r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPFCOFF7
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPFCOFF7r_OFFSET 0x10002a00

#define RPFCOFF7r_SIZE 8

/* RPFCOFF7r is element of RPFCOFF */

/*******************************************************************************
 * REGISTER:  RPKT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPKTr_OFFSET 0x00000b00

#define RPKTr_SIZE 8

/*
 * This structure should be used to declare and program RPKT.
 */
typedef union RPKTr_s {
	uint32_t v[2];
	uint32_t rpkt[2];
	uint32_t _rpkt;
} RPKTr_t;

#define RPKTr_CLR(r) sal_memset(&((r)._rpkt), 0, sizeof(RPKTr_t))
#define RPKTr_SET(r,i,d) (r).rpkt[i] = d
#define RPKTr_GET(r,i) (r).rpkt[i]

/*
 * These macros can be used to access individual fields.
 */
#define RPKTr_COUNTf_GET(r,a) bcmpmac_field_get((r).rpkt,0,39,a)
#define RPKTr_COUNTf_SET(r,a) bcmpmac_field_set((r).rpkt,0,39,a)

/*
 * These macros can be used to access RPKT.
 */
#define READ_RPKTr(pa,p,r) bcmpmac_read(pa,p,RPKTr_OFFSET,0,RPKTr_SIZE,(r._rpkt))
#define WRITE_RPKTr(pa,p,r) bcmpmac_write(pa,p,RPKTr_OFFSET,0,RPKTr_SIZE,&(r._rpkt))

/*******************************************************************************
 * End of 'RPKTr'
 */




/*******************************************************************************
 * REGISTER:  RPOK
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPOKr_OFFSET 0x00002200

#define RPOKr_SIZE 8

/*
 * This structure should be used to declare and program RPOK.
 */
typedef union RPOKr_s {
	uint32_t v[2];
	uint32_t rpok[2];
	uint32_t _rpok;
} RPOKr_t;

#define RPOKr_CLR(r) sal_memset(&((r)._rpok), 0, sizeof(RPOKr_t))
#define RPOKr_SET(r,i,d) (r).rpok[i] = d
#define RPOKr_GET(r,i) (r).rpok[i]

/*
 * These macros can be used to access individual fields.
 */
#define RPOKr_COUNTf_GET(r,a) bcmpmac_field_get((r).rpok,0,39,a)
#define RPOKr_COUNTf_SET(r,a) bcmpmac_field_set((r).rpok,0,39,a)

/*
 * These macros can be used to access RPOK.
 */
#define READ_RPOKr(pa,p,r) bcmpmac_read(pa,p,RPOKr_OFFSET,0,RPOKr_SIZE,(r._rpok))
#define WRITE_RPOKr(pa,p,r) bcmpmac_write(pa,p,RPOKr_OFFSET,0,RPOKr_SIZE,&(r._rpok))

/*******************************************************************************
 * End of 'RPOKr'
 */




/*******************************************************************************
 * REGISTER:  RPRM
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RPRMr_OFFSET 0x10001e00

#define RPRMr_SIZE 8

/*
 * This structure should be used to declare and program RPRM.
 */
typedef union RPRMr_s {
	uint32_t v[2];
	uint32_t rprm[2];
	uint32_t _rprm;
} RPRMr_t;

#define RPRMr_CLR(r) sal_memset(&((r)._rprm), 0, sizeof(RPRMr_t))
#define RPRMr_SET(r,i,d) (r).rprm[i] = d
#define RPRMr_GET(r,i) (r).rprm[i]

/*
 * These macros can be used to access individual fields.
 */
#define RPRMr_COUNTf_GET(r,a) bcmpmac_field_get((r).rprm,0,39,a)
#define RPRMr_COUNTf_SET(r,a) bcmpmac_field_set((r).rprm,0,39,a)

/*
 * These macros can be used to access RPRM.
 */
#define READ_RPRMr(pa,p,r) bcmpmac_read(pa,p,RPRMr_OFFSET,0,RPRMr_SIZE,(r._rprm))
#define WRITE_RPRMr(pa,p,r) bcmpmac_write(pa,p,RPRMr_OFFSET,0,RPRMr_SIZE,&(r._rprm))

/*******************************************************************************
 * End of 'RPRMr'
 */




/*******************************************************************************
 * REGISTER:  RRBYT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RRBYTr_OFFSET 0x10003e00

#define RRBYTr_SIZE 8

/*
 * This structure should be used to declare and program RRBYT.
 */
typedef union RRBYTr_s {
	uint32_t v[2];
	uint32_t rrbyt[2];
	uint32_t _rrbyt;
} RRBYTr_t;

#define RRBYTr_CLR(r) sal_memset(&((r)._rrbyt), 0, sizeof(RRBYTr_t))
#define RRBYTr_SET(r,i,d) (r).rrbyt[i] = d
#define RRBYTr_GET(r,i) (r).rrbyt[i]

/*
 * These macros can be used to access individual fields.
 */
#define RRBYTr_COUNTf_GET(r,a) bcmpmac_field_get((r).rrbyt,0,47,a)
#define RRBYTr_COUNTf_SET(r,a) bcmpmac_field_set((r).rrbyt,0,47,a)

/*
 * These macros can be used to access RRBYT.
 */
#define READ_RRBYTr(pa,p,r) bcmpmac_read(pa,p,RRBYTr_OFFSET,0,RRBYTr_SIZE,(r._rrbyt))
#define WRITE_RRBYTr(pa,p,r) bcmpmac_write(pa,p,RRBYTr_OFFSET,0,RRBYTr_SIZE,&(r._rrbyt))

/*******************************************************************************
 * End of 'RRBYTr'
 */




/*******************************************************************************
 * REGISTER:  RRPKT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RRPKTr_OFFSET 0x10003f00

#define RRPKTr_SIZE 8

/*
 * This structure should be used to declare and program RRPKT.
 */
typedef union RRPKTr_s {
	uint32_t v[2];
	uint32_t rrpkt[2];
	uint32_t _rrpkt;
} RRPKTr_t;

#define RRPKTr_CLR(r) sal_memset(&((r)._rrpkt), 0, sizeof(RRPKTr_t))
#define RRPKTr_SET(r,i,d) (r).rrpkt[i] = d
#define RRPKTr_GET(r,i) (r).rrpkt[i]

/*
 * These macros can be used to access individual fields.
 */
#define RRPKTr_COUNTf_GET(r,a) bcmpmac_field_get((r).rrpkt,0,39,a)
#define RRPKTr_COUNTf_SET(r,a) bcmpmac_field_set((r).rrpkt,0,39,a)

/*
 * These macros can be used to access RRPKT.
 */
#define READ_RRPKTr(pa,p,r) bcmpmac_read(pa,p,RRPKTr_OFFSET,0,RRPKTr_SIZE,(r._rrpkt))
#define WRITE_RRPKTr(pa,p,r) bcmpmac_write(pa,p,RRPKTr_OFFSET,0,RRPKTr_SIZE,&(r._rrpkt))

/*******************************************************************************
 * End of 'RRPKTr'
 */




/*******************************************************************************
 * REGISTER:  RSCHCRC
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RSCHCRCr_OFFSET 0x10003300

#define RSCHCRCr_SIZE 8

/*
 * This structure should be used to declare and program RSCHCRC.
 */
typedef union RSCHCRCr_s {
	uint32_t v[2];
	uint32_t rschcrc[2];
	uint32_t _rschcrc;
} RSCHCRCr_t;

#define RSCHCRCr_CLR(r) sal_memset(&((r)._rschcrc), 0, sizeof(RSCHCRCr_t))
#define RSCHCRCr_SET(r,i,d) (r).rschcrc[i] = d
#define RSCHCRCr_GET(r,i) (r).rschcrc[i]

/*
 * These macros can be used to access individual fields.
 */
#define RSCHCRCr_COUNTf_GET(r,a) bcmpmac_field_get((r).rschcrc,0,39,a)
#define RSCHCRCr_COUNTf_SET(r,a) bcmpmac_field_set((r).rschcrc,0,39,a)

/*
 * These macros can be used to access RSCHCRC.
 */
#define READ_RSCHCRCr(pa,p,r) bcmpmac_read(pa,p,RSCHCRCr_OFFSET,0,RSCHCRCr_SIZE,(r._rschcrc))
#define WRITE_RSCHCRCr(pa,p,r) bcmpmac_write(pa,p,RSCHCRCr_OFFSET,0,RSCHCRCr_SIZE,&(r._rschcrc))

/*******************************************************************************
 * End of 'RSCHCRCr'
 */




/*******************************************************************************
 * REGISTER:  RTRFU
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RTRFUr_OFFSET 0x10002100

#define RTRFUr_SIZE 8

/*
 * This structure should be used to declare and program RTRFU.
 */
typedef union RTRFUr_s {
	uint32_t v[2];
	uint32_t rtrfu[2];
	uint32_t _rtrfu;
} RTRFUr_t;

#define RTRFUr_CLR(r) sal_memset(&((r)._rtrfu), 0, sizeof(RTRFUr_t))
#define RTRFUr_SET(r,i,d) (r).rtrfu[i] = d
#define RTRFUr_GET(r,i) (r).rtrfu[i]

/*
 * These macros can be used to access individual fields.
 */
#define RTRFUr_COUNTf_GET(r,a) bcmpmac_field_get((r).rtrfu,0,39,a)
#define RTRFUr_COUNTf_SET(r,a) bcmpmac_field_set((r).rtrfu,0,39,a)

/*
 * These macros can be used to access RTRFU.
 */
#define READ_RTRFUr(pa,p,r) bcmpmac_read(pa,p,RTRFUr_OFFSET,0,RTRFUr_SIZE,(r._rtrfu))
#define WRITE_RTRFUr(pa,p,r) bcmpmac_write(pa,p,RTRFUr_OFFSET,0,RTRFUr_SIZE,&(r._rtrfu))

/*******************************************************************************
 * End of 'RTRFUr'
 */




/*******************************************************************************
 * REGISTER:  RUCA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RUCAr_OFFSET 0x00000c00

#define RUCAr_SIZE 8

/*
 * This structure should be used to declare and program RUCA.
 */
typedef union RUCAr_s {
	uint32_t v[2];
	uint32_t ruca[2];
	uint32_t _ruca;
} RUCAr_t;

#define RUCAr_CLR(r) sal_memset(&((r)._ruca), 0, sizeof(RUCAr_t))
#define RUCAr_SET(r,i,d) (r).ruca[i] = d
#define RUCAr_GET(r,i) (r).ruca[i]

/*
 * These macros can be used to access individual fields.
 */
#define RUCAr_COUNTf_GET(r,a) bcmpmac_field_get((r).ruca,0,39,a)
#define RUCAr_COUNTf_SET(r,a) bcmpmac_field_set((r).ruca,0,39,a)

/*
 * These macros can be used to access RUCA.
 */
#define READ_RUCAr(pa,p,r) bcmpmac_read(pa,p,RUCAr_OFFSET,0,RUCAr_SIZE,(r._ruca))
#define WRITE_RUCAr(pa,p,r) bcmpmac_write(pa,p,RUCAr_OFFSET,0,RUCAr_SIZE,&(r._ruca))

/*******************************************************************************
 * End of 'RUCAr'
 */




/*******************************************************************************
 * REGISTER:  RUND
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RUNDr_OFFSET 0x10003400

#define RUNDr_SIZE 8

/*
 * This structure should be used to declare and program RUND.
 */
typedef union RUNDr_s {
	uint32_t v[2];
	uint32_t rund[2];
	uint32_t _rund;
} RUNDr_t;

#define RUNDr_CLR(r) sal_memset(&((r)._rund), 0, sizeof(RUNDr_t))
#define RUNDr_SET(r,i,d) (r).rund[i] = d
#define RUNDr_GET(r,i) (r).rund[i]

/*
 * These macros can be used to access individual fields.
 */
#define RUNDr_COUNTf_GET(r,a) bcmpmac_field_get((r).rund,0,39,a)
#define RUNDr_COUNTf_SET(r,a) bcmpmac_field_set((r).rund,0,39,a)

/*
 * These macros can be used to access RUND.
 */
#define READ_RUNDr(pa,p,r) bcmpmac_read(pa,p,RUNDr_OFFSET,0,RUNDr_SIZE,(r._rund))
#define WRITE_RUNDr(pa,p,r) bcmpmac_write(pa,p,RUNDr_OFFSET,0,RUNDr_SIZE,&(r._rund))

/*******************************************************************************
 * End of 'RUNDr'
 */




/*******************************************************************************
 * REGISTER:  RVLN
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RVLNr_OFFSET 0x10001f00

#define RVLNr_SIZE 8

/*
 * This structure should be used to declare and program RVLN.
 */
typedef union RVLNr_s {
	uint32_t v[2];
	uint32_t rvln[2];
	uint32_t _rvln;
} RVLNr_t;

#define RVLNr_CLR(r) sal_memset(&((r)._rvln), 0, sizeof(RVLNr_t))
#define RVLNr_SET(r,i,d) (r).rvln[i] = d
#define RVLNr_GET(r,i) (r).rvln[i]

/*
 * These macros can be used to access individual fields.
 */
#define RVLNr_COUNTf_GET(r,a) bcmpmac_field_get((r).rvln,0,39,a)
#define RVLNr_COUNTf_SET(r,a) bcmpmac_field_set((r).rvln,0,39,a)

/*
 * These macros can be used to access RVLN.
 */
#define READ_RVLNr(pa,p,r) bcmpmac_read(pa,p,RVLNr_OFFSET,0,RVLNr_SIZE,(r._rvln))
#define WRITE_RVLNr(pa,p,r) bcmpmac_write(pa,p,RVLNr_OFFSET,0,RVLNr_SIZE,&(r._rvln))

/*******************************************************************************
 * End of 'RVLNr'
 */




/*******************************************************************************
 * REGISTER:  RXCF
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RXCFr_OFFSET 0x00001000

#define RXCFr_SIZE 8

/*
 * This structure should be used to declare and program RXCF.
 */
typedef union RXCFr_s {
	uint32_t v[2];
	uint32_t rxcf[2];
	uint32_t _rxcf;
} RXCFr_t;

#define RXCFr_CLR(r) sal_memset(&((r)._rxcf), 0, sizeof(RXCFr_t))
#define RXCFr_SET(r,i,d) (r).rxcf[i] = d
#define RXCFr_GET(r,i) (r).rxcf[i]

/*
 * These macros can be used to access individual fields.
 */
#define RXCFr_COUNTf_GET(r,a) bcmpmac_field_get((r).rxcf,0,39,a)
#define RXCFr_COUNTf_SET(r,a) bcmpmac_field_set((r).rxcf,0,39,a)

/*
 * These macros can be used to access RXCF.
 */
#define READ_RXCFr(pa,p,r) bcmpmac_read(pa,p,RXCFr_OFFSET,0,RXCFr_SIZE,(r._rxcf))
#define WRITE_RXCFr(pa,p,r) bcmpmac_write(pa,p,RXCFr_OFFSET,0,RXCFr_SIZE,&(r._rxcf))

/*******************************************************************************
 * End of 'RXCFr'
 */




/*******************************************************************************
 * REGISTER:  RXPF
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RXPFr_OFFSET 0x00001100

#define RXPFr_SIZE 8

/*
 * This structure should be used to declare and program RXPF.
 */
typedef union RXPFr_s {
	uint32_t v[2];
	uint32_t rxpf[2];
	uint32_t _rxpf;
} RXPFr_t;

#define RXPFr_CLR(r) sal_memset(&((r)._rxpf), 0, sizeof(RXPFr_t))
#define RXPFr_SET(r,i,d) (r).rxpf[i] = d
#define RXPFr_GET(r,i) (r).rxpf[i]

/*
 * These macros can be used to access individual fields.
 */
#define RXPFr_COUNTf_GET(r,a) bcmpmac_field_get((r).rxpf,0,39,a)
#define RXPFr_COUNTf_SET(r,a) bcmpmac_field_set((r).rxpf,0,39,a)

/*
 * These macros can be used to access RXPF.
 */
#define READ_RXPFr(pa,p,r) bcmpmac_read(pa,p,RXPFr_OFFSET,0,RXPFr_SIZE,(r._rxpf))
#define WRITE_RXPFr(pa,p,r) bcmpmac_write(pa,p,RXPFr_OFFSET,0,RXPFr_SIZE,&(r._rxpf))

/*******************************************************************************
 * End of 'RXPFr'
 */




/*******************************************************************************
 * REGISTER:  RXPP
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RXPPr_OFFSET 0x00001200

#define RXPPr_SIZE 8

/*
 * This structure should be used to declare and program RXPP.
 */
typedef union RXPPr_s {
	uint32_t v[2];
	uint32_t rxpp[2];
	uint32_t _rxpp;
} RXPPr_t;

#define RXPPr_CLR(r) sal_memset(&((r)._rxpp), 0, sizeof(RXPPr_t))
#define RXPPr_SET(r,i,d) (r).rxpp[i] = d
#define RXPPr_GET(r,i) (r).rxpp[i]

/*
 * These macros can be used to access individual fields.
 */
#define RXPPr_COUNTf_GET(r,a) bcmpmac_field_get((r).rxpp,0,39,a)
#define RXPPr_COUNTf_SET(r,a) bcmpmac_field_set((r).rxpp,0,39,a)

/*
 * These macros can be used to access RXPP.
 */
#define READ_RXPPr(pa,p,r) bcmpmac_read(pa,p,RXPPr_OFFSET,0,RXPPr_SIZE,(r._rxpp))
#define WRITE_RXPPr(pa,p,r) bcmpmac_write(pa,p,RXPPr_OFFSET,0,RXPPr_SIZE,&(r._rxpp))

/*******************************************************************************
 * End of 'RXPPr'
 */




/*******************************************************************************
 * REGISTER:  RXUDA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RXUDAr_OFFSET 0x00001400

#define RXUDAr_SIZE 8

/*
 * This structure should be used to declare and program RXUDA.
 */
typedef union RXUDAr_s {
	uint32_t v[2];
	uint32_t rxuda[2];
	uint32_t _rxuda;
} RXUDAr_t;

#define RXUDAr_CLR(r) sal_memset(&((r)._rxuda), 0, sizeof(RXUDAr_t))
#define RXUDAr_SET(r,i,d) (r).rxuda[i] = d
#define RXUDAr_GET(r,i) (r).rxuda[i]

/*
 * These macros can be used to access individual fields.
 */
#define RXUDAr_COUNTf_GET(r,a) bcmpmac_field_get((r).rxuda,0,39,a)
#define RXUDAr_COUNTf_SET(r,a) bcmpmac_field_set((r).rxuda,0,39,a)

/*
 * These macros can be used to access RXUDA.
 */
#define READ_RXUDAr(pa,p,r) bcmpmac_read(pa,p,RXUDAr_OFFSET,0,RXUDAr_SIZE,(r._rxuda))
#define WRITE_RXUDAr(pa,p,r) bcmpmac_write(pa,p,RXUDAr_OFFSET,0,RXUDAr_SIZE,&(r._rxuda))

/*******************************************************************************
 * End of 'RXUDAr'
 */




/*******************************************************************************
 * REGISTER:  RXUO
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RXUOr_OFFSET 0x00001300

#define RXUOr_SIZE 8

/*
 * This structure should be used to declare and program RXUO.
 */
typedef union RXUOr_s {
	uint32_t v[2];
	uint32_t rxuo[2];
	uint32_t _rxuo;
} RXUOr_t;

#define RXUOr_CLR(r) sal_memset(&((r)._rxuo), 0, sizeof(RXUOr_t))
#define RXUOr_SET(r,i,d) (r).rxuo[i] = d
#define RXUOr_GET(r,i) (r).rxuo[i]

/*
 * These macros can be used to access individual fields.
 */
#define RXUOr_COUNTf_GET(r,a) bcmpmac_field_get((r).rxuo,0,39,a)
#define RXUOr_COUNTf_SET(r,a) bcmpmac_field_set((r).rxuo,0,39,a)

/*
 * These macros can be used to access RXUO.
 */
#define READ_RXUOr(pa,p,r) bcmpmac_read(pa,p,RXUOr_OFFSET,0,RXUOr_SIZE,(r._rxuo))
#define WRITE_RXUOr(pa,p,r) bcmpmac_write(pa,p,RXUOr_OFFSET,0,RXUOr_SIZE,&(r._rxuo))

/*******************************************************************************
 * End of 'RXUOr'
 */




/*******************************************************************************
 * REGISTER:  RXWSA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RXWSAr_OFFSET 0x00001500

#define RXWSAr_SIZE 8

/*
 * This structure should be used to declare and program RXWSA.
 */
typedef union RXWSAr_s {
	uint32_t v[2];
	uint32_t rxwsa[2];
	uint32_t _rxwsa;
} RXWSAr_t;

#define RXWSAr_CLR(r) sal_memset(&((r)._rxwsa), 0, sizeof(RXWSAr_t))
#define RXWSAr_SET(r,i,d) (r).rxwsa[i] = d
#define RXWSAr_GET(r,i) (r).rxwsa[i]

/*
 * These macros can be used to access individual fields.
 */
#define RXWSAr_COUNTf_GET(r,a) bcmpmac_field_get((r).rxwsa,0,39,a)
#define RXWSAr_COUNTf_SET(r,a) bcmpmac_field_set((r).rxwsa,0,39,a)

/*
 * These macros can be used to access RXWSA.
 */
#define READ_RXWSAr(pa,p,r) bcmpmac_read(pa,p,RXWSAr_OFFSET,0,RXWSAr_SIZE,(r._rxwsa))
#define WRITE_RXWSAr(pa,p,r) bcmpmac_write(pa,p,RXWSAr_OFFSET,0,RXWSAr_SIZE,&(r._rxwsa))

/*******************************************************************************
 * End of 'RXWSAr'
 */




/*******************************************************************************
 * REGISTER:  RX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RX_EEE_LPI_DURATION_COUNTERr_OFFSET 0x10003700

#define RX_EEE_LPI_DURATION_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program RX_EEE_LPI_DURATION_COUNTER.
 */
typedef union RX_EEE_LPI_DURATION_COUNTERr_s {
	uint32_t v[2];
	uint32_t rx_eee_lpi_duration_counter[2];
	uint32_t _rx_eee_lpi_duration_counter;
} RX_EEE_LPI_DURATION_COUNTERr_t;

#define RX_EEE_LPI_DURATION_COUNTERr_CLR(r) sal_memset(&((r)._rx_eee_lpi_duration_counter), 0, sizeof(RX_EEE_LPI_DURATION_COUNTERr_t))
#define RX_EEE_LPI_DURATION_COUNTERr_SET(r,i,d) (r).rx_eee_lpi_duration_counter[i] = d
#define RX_EEE_LPI_DURATION_COUNTERr_GET(r,i) (r).rx_eee_lpi_duration_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_EEE_LPI_DURATION_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).rx_eee_lpi_duration_counter,0,39,a)
#define RX_EEE_LPI_DURATION_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).rx_eee_lpi_duration_counter,0,39,a)

/*
 * These macros can be used to access RX_EEE_LPI_DURATION_COUNTER.
 */
#define READ_RX_EEE_LPI_DURATION_COUNTERr(pa,p,r) bcmpmac_read(pa,p,RX_EEE_LPI_DURATION_COUNTERr_OFFSET,0,RX_EEE_LPI_DURATION_COUNTERr_SIZE,(r._rx_eee_lpi_duration_counter))
#define WRITE_RX_EEE_LPI_DURATION_COUNTERr(pa,p,r) bcmpmac_write(pa,p,RX_EEE_LPI_DURATION_COUNTERr_OFFSET,0,RX_EEE_LPI_DURATION_COUNTERr_SIZE,&(r._rx_eee_lpi_duration_counter))

/*******************************************************************************
 * End of 'RX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  RX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RX_EEE_LPI_EVENT_COUNTERr_OFFSET 0x10003600

#define RX_EEE_LPI_EVENT_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program RX_EEE_LPI_EVENT_COUNTER.
 */
typedef union RX_EEE_LPI_EVENT_COUNTERr_s {
	uint32_t v[2];
	uint32_t rx_eee_lpi_event_counter[2];
	uint32_t _rx_eee_lpi_event_counter;
} RX_EEE_LPI_EVENT_COUNTERr_t;

#define RX_EEE_LPI_EVENT_COUNTERr_CLR(r) sal_memset(&((r)._rx_eee_lpi_event_counter), 0, sizeof(RX_EEE_LPI_EVENT_COUNTERr_t))
#define RX_EEE_LPI_EVENT_COUNTERr_SET(r,i,d) (r).rx_eee_lpi_event_counter[i] = d
#define RX_EEE_LPI_EVENT_COUNTERr_GET(r,i) (r).rx_eee_lpi_event_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_EEE_LPI_EVENT_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).rx_eee_lpi_event_counter,0,39,a)
#define RX_EEE_LPI_EVENT_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).rx_eee_lpi_event_counter,0,39,a)

/*
 * These macros can be used to access RX_EEE_LPI_EVENT_COUNTER.
 */
#define READ_RX_EEE_LPI_EVENT_COUNTERr(pa,p,r) bcmpmac_read(pa,p,RX_EEE_LPI_EVENT_COUNTERr_OFFSET,0,RX_EEE_LPI_EVENT_COUNTERr_SIZE,(r._rx_eee_lpi_event_counter))
#define WRITE_RX_EEE_LPI_EVENT_COUNTERr(pa,p,r) bcmpmac_write(pa,p,RX_EEE_LPI_EVENT_COUNTERr_OFFSET,0,RX_EEE_LPI_EVENT_COUNTERr_SIZE,&(r._rx_eee_lpi_event_counter))

/*******************************************************************************
 * End of 'RX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  RX_HCFC_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RX_HCFC_COUNTERr_OFFSET 0x10003b00

#define RX_HCFC_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program RX_HCFC_COUNTER.
 */
typedef union RX_HCFC_COUNTERr_s {
	uint32_t v[2];
	uint32_t rx_hcfc_counter[2];
	uint32_t _rx_hcfc_counter;
} RX_HCFC_COUNTERr_t;

#define RX_HCFC_COUNTERr_CLR(r) sal_memset(&((r)._rx_hcfc_counter), 0, sizeof(RX_HCFC_COUNTERr_t))
#define RX_HCFC_COUNTERr_SET(r,i,d) (r).rx_hcfc_counter[i] = d
#define RX_HCFC_COUNTERr_GET(r,i) (r).rx_hcfc_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_HCFC_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).rx_hcfc_counter,0,39,a)
#define RX_HCFC_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).rx_hcfc_counter,0,39,a)

/*
 * These macros can be used to access RX_HCFC_COUNTER.
 */
#define READ_RX_HCFC_COUNTERr(pa,p,r) bcmpmac_read(pa,p,RX_HCFC_COUNTERr_OFFSET,0,RX_HCFC_COUNTERr_SIZE,(r._rx_hcfc_counter))
#define WRITE_RX_HCFC_COUNTERr(pa,p,r) bcmpmac_write(pa,p,RX_HCFC_COUNTERr_OFFSET,0,RX_HCFC_COUNTERr_SIZE,&(r._rx_hcfc_counter))

/*******************************************************************************
 * End of 'RX_HCFC_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  RX_HCFC_CRC_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RX_HCFC_CRC_COUNTERr_OFFSET 0x10003c00

#define RX_HCFC_CRC_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program RX_HCFC_CRC_COUNTER.
 */
typedef union RX_HCFC_CRC_COUNTERr_s {
	uint32_t v[2];
	uint32_t rx_hcfc_crc_counter[2];
	uint32_t _rx_hcfc_crc_counter;
} RX_HCFC_CRC_COUNTERr_t;

#define RX_HCFC_CRC_COUNTERr_CLR(r) sal_memset(&((r)._rx_hcfc_crc_counter), 0, sizeof(RX_HCFC_CRC_COUNTERr_t))
#define RX_HCFC_CRC_COUNTERr_SET(r,i,d) (r).rx_hcfc_crc_counter[i] = d
#define RX_HCFC_CRC_COUNTERr_GET(r,i) (r).rx_hcfc_crc_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_HCFC_CRC_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).rx_hcfc_crc_counter,0,39,a)
#define RX_HCFC_CRC_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).rx_hcfc_crc_counter,0,39,a)

/*
 * These macros can be used to access RX_HCFC_CRC_COUNTER.
 */
#define READ_RX_HCFC_CRC_COUNTERr(pa,p,r) bcmpmac_read(pa,p,RX_HCFC_CRC_COUNTERr_OFFSET,0,RX_HCFC_CRC_COUNTERr_SIZE,(r._rx_hcfc_crc_counter))
#define WRITE_RX_HCFC_CRC_COUNTERr(pa,p,r) bcmpmac_write(pa,p,RX_HCFC_CRC_COUNTERr_OFFSET,0,RX_HCFC_CRC_COUNTERr_SIZE,&(r._rx_hcfc_crc_counter))

/*******************************************************************************
 * End of 'RX_HCFC_CRC_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  RX_LLFC_CRC_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RX_LLFC_CRC_COUNTERr_OFFSET 0x10003a00

#define RX_LLFC_CRC_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program RX_LLFC_CRC_COUNTER.
 */
typedef union RX_LLFC_CRC_COUNTERr_s {
	uint32_t v[2];
	uint32_t rx_llfc_crc_counter[2];
	uint32_t _rx_llfc_crc_counter;
} RX_LLFC_CRC_COUNTERr_t;

#define RX_LLFC_CRC_COUNTERr_CLR(r) sal_memset(&((r)._rx_llfc_crc_counter), 0, sizeof(RX_LLFC_CRC_COUNTERr_t))
#define RX_LLFC_CRC_COUNTERr_SET(r,i,d) (r).rx_llfc_crc_counter[i] = d
#define RX_LLFC_CRC_COUNTERr_GET(r,i) (r).rx_llfc_crc_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_LLFC_CRC_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).rx_llfc_crc_counter,0,39,a)
#define RX_LLFC_CRC_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).rx_llfc_crc_counter,0,39,a)

/*
 * These macros can be used to access RX_LLFC_CRC_COUNTER.
 */
#define READ_RX_LLFC_CRC_COUNTERr(pa,p,r) bcmpmac_read(pa,p,RX_LLFC_CRC_COUNTERr_OFFSET,0,RX_LLFC_CRC_COUNTERr_SIZE,(r._rx_llfc_crc_counter))
#define WRITE_RX_LLFC_CRC_COUNTERr(pa,p,r) bcmpmac_write(pa,p,RX_LLFC_CRC_COUNTERr_OFFSET,0,RX_LLFC_CRC_COUNTERr_SIZE,&(r._rx_llfc_crc_counter))

/*******************************************************************************
 * End of 'RX_LLFC_CRC_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  RX_LLFC_LOG_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RX_LLFC_LOG_COUNTERr_OFFSET 0x10003900

#define RX_LLFC_LOG_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program RX_LLFC_LOG_COUNTER.
 */
typedef union RX_LLFC_LOG_COUNTERr_s {
	uint32_t v[2];
	uint32_t rx_llfc_log_counter[2];
	uint32_t _rx_llfc_log_counter;
} RX_LLFC_LOG_COUNTERr_t;

#define RX_LLFC_LOG_COUNTERr_CLR(r) sal_memset(&((r)._rx_llfc_log_counter), 0, sizeof(RX_LLFC_LOG_COUNTERr_t))
#define RX_LLFC_LOG_COUNTERr_SET(r,i,d) (r).rx_llfc_log_counter[i] = d
#define RX_LLFC_LOG_COUNTERr_GET(r,i) (r).rx_llfc_log_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_LLFC_LOG_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).rx_llfc_log_counter,0,39,a)
#define RX_LLFC_LOG_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).rx_llfc_log_counter,0,39,a)

/*
 * These macros can be used to access RX_LLFC_LOG_COUNTER.
 */
#define READ_RX_LLFC_LOG_COUNTERr(pa,p,r) bcmpmac_read(pa,p,RX_LLFC_LOG_COUNTERr_OFFSET,0,RX_LLFC_LOG_COUNTERr_SIZE,(r._rx_llfc_log_counter))
#define WRITE_RX_LLFC_LOG_COUNTERr(pa,p,r) bcmpmac_write(pa,p,RX_LLFC_LOG_COUNTERr_OFFSET,0,RX_LLFC_LOG_COUNTERr_SIZE,&(r._rx_llfc_log_counter))

/*******************************************************************************
 * End of 'RX_LLFC_LOG_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  RX_LLFC_PHY_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define RX_LLFC_PHY_COUNTERr_OFFSET 0x10003800

#define RX_LLFC_PHY_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program RX_LLFC_PHY_COUNTER.
 */
typedef union RX_LLFC_PHY_COUNTERr_s {
	uint32_t v[2];
	uint32_t rx_llfc_phy_counter[2];
	uint32_t _rx_llfc_phy_counter;
} RX_LLFC_PHY_COUNTERr_t;

#define RX_LLFC_PHY_COUNTERr_CLR(r) sal_memset(&((r)._rx_llfc_phy_counter), 0, sizeof(RX_LLFC_PHY_COUNTERr_t))
#define RX_LLFC_PHY_COUNTERr_SET(r,i,d) (r).rx_llfc_phy_counter[i] = d
#define RX_LLFC_PHY_COUNTERr_GET(r,i) (r).rx_llfc_phy_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define RX_LLFC_PHY_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).rx_llfc_phy_counter,0,39,a)
#define RX_LLFC_PHY_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).rx_llfc_phy_counter,0,39,a)

/*
 * These macros can be used to access RX_LLFC_PHY_COUNTER.
 */
#define READ_RX_LLFC_PHY_COUNTERr(pa,p,r) bcmpmac_read(pa,p,RX_LLFC_PHY_COUNTERr_OFFSET,0,RX_LLFC_PHY_COUNTERr_SIZE,(r._rx_llfc_phy_counter))
#define WRITE_RX_LLFC_PHY_COUNTERr(pa,p,r) bcmpmac_write(pa,p,RX_LLFC_PHY_COUNTERr_OFFSET,0,RX_LLFC_PHY_COUNTERr_SIZE,&(r._rx_llfc_phy_counter))

/*******************************************************************************
 * End of 'RX_LLFC_PHY_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  T1023
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T1023r_OFFSET 0x00004400

#define T1023r_SIZE 8

/*
 * This structure should be used to declare and program T1023.
 */
typedef union T1023r_s {
	uint32_t v[2];
	uint32_t t1023[2];
	uint32_t _t1023;
} T1023r_t;

#define T1023r_CLR(r) sal_memset(&((r)._t1023), 0, sizeof(T1023r_t))
#define T1023r_SET(r,i,d) (r).t1023[i] = d
#define T1023r_GET(r,i) (r).t1023[i]

/*
 * These macros can be used to access individual fields.
 */
#define T1023r_COUNTf_GET(r,a) bcmpmac_field_get((r).t1023,0,39,a)
#define T1023r_COUNTf_SET(r,a) bcmpmac_field_set((r).t1023,0,39,a)

/*
 * These macros can be used to access T1023.
 */
#define READ_T1023r(pa,p,r) bcmpmac_read(pa,p,T1023r_OFFSET,0,T1023r_SIZE,(r._t1023))
#define WRITE_T1023r(pa,p,r) bcmpmac_write(pa,p,T1023r_OFFSET,0,T1023r_SIZE,&(r._t1023))

/*******************************************************************************
 * End of 'T1023r'
 */




/*******************************************************************************
 * REGISTER:  T127
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T127r_OFFSET 0x00004100

#define T127r_SIZE 8

/*
 * This structure should be used to declare and program T127.
 */
typedef union T127r_s {
	uint32_t v[2];
	uint32_t t127[2];
	uint32_t _t127;
} T127r_t;

#define T127r_CLR(r) sal_memset(&((r)._t127), 0, sizeof(T127r_t))
#define T127r_SET(r,i,d) (r).t127[i] = d
#define T127r_GET(r,i) (r).t127[i]

/*
 * These macros can be used to access individual fields.
 */
#define T127r_COUNTf_GET(r,a) bcmpmac_field_get((r).t127,0,39,a)
#define T127r_COUNTf_SET(r,a) bcmpmac_field_set((r).t127,0,39,a)

/*
 * These macros can be used to access T127.
 */
#define READ_T127r(pa,p,r) bcmpmac_read(pa,p,T127r_OFFSET,0,T127r_SIZE,(r._t127))
#define WRITE_T127r(pa,p,r) bcmpmac_write(pa,p,T127r_OFFSET,0,T127r_SIZE,&(r._t127))

/*******************************************************************************
 * End of 'T127r'
 */




/*******************************************************************************
 * REGISTER:  T1518
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T1518r_OFFSET 0x00004500

#define T1518r_SIZE 8

/*
 * This structure should be used to declare and program T1518.
 */
typedef union T1518r_s {
	uint32_t v[2];
	uint32_t t1518[2];
	uint32_t _t1518;
} T1518r_t;

#define T1518r_CLR(r) sal_memset(&((r)._t1518), 0, sizeof(T1518r_t))
#define T1518r_SET(r,i,d) (r).t1518[i] = d
#define T1518r_GET(r,i) (r).t1518[i]

/*
 * These macros can be used to access individual fields.
 */
#define T1518r_COUNTf_GET(r,a) bcmpmac_field_get((r).t1518,0,39,a)
#define T1518r_COUNTf_SET(r,a) bcmpmac_field_set((r).t1518,0,39,a)

/*
 * These macros can be used to access T1518.
 */
#define READ_T1518r(pa,p,r) bcmpmac_read(pa,p,T1518r_OFFSET,0,T1518r_SIZE,(r._t1518))
#define WRITE_T1518r(pa,p,r) bcmpmac_write(pa,p,T1518r_OFFSET,0,T1518r_SIZE,&(r._t1518))

/*******************************************************************************
 * End of 'T1518r'
 */




/*******************************************************************************
 * REGISTER:  T16383
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T16383r_OFFSET 0x00004a00

#define T16383r_SIZE 8

/*
 * This structure should be used to declare and program T16383.
 */
typedef union T16383r_s {
	uint32_t v[2];
	uint32_t t16383[2];
	uint32_t _t16383;
} T16383r_t;

#define T16383r_CLR(r) sal_memset(&((r)._t16383), 0, sizeof(T16383r_t))
#define T16383r_SET(r,i,d) (r).t16383[i] = d
#define T16383r_GET(r,i) (r).t16383[i]

/*
 * These macros can be used to access individual fields.
 */
#define T16383r_COUNTf_GET(r,a) bcmpmac_field_get((r).t16383,0,39,a)
#define T16383r_COUNTf_SET(r,a) bcmpmac_field_set((r).t16383,0,39,a)

/*
 * These macros can be used to access T16383.
 */
#define READ_T16383r(pa,p,r) bcmpmac_read(pa,p,T16383r_OFFSET,0,T16383r_SIZE,(r._t16383))
#define WRITE_T16383r(pa,p,r) bcmpmac_write(pa,p,T16383r_OFFSET,0,T16383r_SIZE,&(r._t16383))

/*******************************************************************************
 * End of 'T16383r'
 */




/*******************************************************************************
 * REGISTER:  T2047
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T2047r_OFFSET 0x00004700

#define T2047r_SIZE 8

/*
 * This structure should be used to declare and program T2047.
 */
typedef union T2047r_s {
	uint32_t v[2];
	uint32_t t2047[2];
	uint32_t _t2047;
} T2047r_t;

#define T2047r_CLR(r) sal_memset(&((r)._t2047), 0, sizeof(T2047r_t))
#define T2047r_SET(r,i,d) (r).t2047[i] = d
#define T2047r_GET(r,i) (r).t2047[i]

/*
 * These macros can be used to access individual fields.
 */
#define T2047r_COUNTf_GET(r,a) bcmpmac_field_get((r).t2047,0,39,a)
#define T2047r_COUNTf_SET(r,a) bcmpmac_field_set((r).t2047,0,39,a)

/*
 * These macros can be used to access T2047.
 */
#define READ_T2047r(pa,p,r) bcmpmac_read(pa,p,T2047r_OFFSET,0,T2047r_SIZE,(r._t2047))
#define WRITE_T2047r(pa,p,r) bcmpmac_write(pa,p,T2047r_OFFSET,0,T2047r_SIZE,&(r._t2047))

/*******************************************************************************
 * End of 'T2047r'
 */




/*******************************************************************************
 * REGISTER:  T255
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T255r_OFFSET 0x00004200

#define T255r_SIZE 8

/*
 * This structure should be used to declare and program T255.
 */
typedef union T255r_s {
	uint32_t v[2];
	uint32_t t255[2];
	uint32_t _t255;
} T255r_t;

#define T255r_CLR(r) sal_memset(&((r)._t255), 0, sizeof(T255r_t))
#define T255r_SET(r,i,d) (r).t255[i] = d
#define T255r_GET(r,i) (r).t255[i]

/*
 * These macros can be used to access individual fields.
 */
#define T255r_COUNTf_GET(r,a) bcmpmac_field_get((r).t255,0,39,a)
#define T255r_COUNTf_SET(r,a) bcmpmac_field_set((r).t255,0,39,a)

/*
 * These macros can be used to access T255.
 */
#define READ_T255r(pa,p,r) bcmpmac_read(pa,p,T255r_OFFSET,0,T255r_SIZE,(r._t255))
#define WRITE_T255r(pa,p,r) bcmpmac_write(pa,p,T255r_OFFSET,0,T255r_SIZE,&(r._t255))

/*******************************************************************************
 * End of 'T255r'
 */




/*******************************************************************************
 * REGISTER:  T4095
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T4095r_OFFSET 0x00004800

#define T4095r_SIZE 8

/*
 * This structure should be used to declare and program T4095.
 */
typedef union T4095r_s {
	uint32_t v[2];
	uint32_t t4095[2];
	uint32_t _t4095;
} T4095r_t;

#define T4095r_CLR(r) sal_memset(&((r)._t4095), 0, sizeof(T4095r_t))
#define T4095r_SET(r,i,d) (r).t4095[i] = d
#define T4095r_GET(r,i) (r).t4095[i]

/*
 * These macros can be used to access individual fields.
 */
#define T4095r_COUNTf_GET(r,a) bcmpmac_field_get((r).t4095,0,39,a)
#define T4095r_COUNTf_SET(r,a) bcmpmac_field_set((r).t4095,0,39,a)

/*
 * These macros can be used to access T4095.
 */
#define READ_T4095r(pa,p,r) bcmpmac_read(pa,p,T4095r_OFFSET,0,T4095r_SIZE,(r._t4095))
#define WRITE_T4095r(pa,p,r) bcmpmac_write(pa,p,T4095r_OFFSET,0,T4095r_SIZE,&(r._t4095))

/*******************************************************************************
 * End of 'T4095r'
 */




/*******************************************************************************
 * REGISTER:  T511
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T511r_OFFSET 0x00004300

#define T511r_SIZE 8

/*
 * This structure should be used to declare and program T511.
 */
typedef union T511r_s {
	uint32_t v[2];
	uint32_t t511[2];
	uint32_t _t511;
} T511r_t;

#define T511r_CLR(r) sal_memset(&((r)._t511), 0, sizeof(T511r_t))
#define T511r_SET(r,i,d) (r).t511[i] = d
#define T511r_GET(r,i) (r).t511[i]

/*
 * These macros can be used to access individual fields.
 */
#define T511r_COUNTf_GET(r,a) bcmpmac_field_get((r).t511,0,39,a)
#define T511r_COUNTf_SET(r,a) bcmpmac_field_set((r).t511,0,39,a)

/*
 * These macros can be used to access T511.
 */
#define READ_T511r(pa,p,r) bcmpmac_read(pa,p,T511r_OFFSET,0,T511r_SIZE,(r._t511))
#define WRITE_T511r(pa,p,r) bcmpmac_write(pa,p,T511r_OFFSET,0,T511r_SIZE,&(r._t511))

/*******************************************************************************
 * End of 'T511r'
 */




/*******************************************************************************
 * REGISTER:  T64
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T64r_OFFSET 0x00004000

#define T64r_SIZE 8

/*
 * This structure should be used to declare and program T64.
 */
typedef union T64r_s {
	uint32_t v[2];
	uint32_t t64[2];
	uint32_t _t64;
} T64r_t;

#define T64r_CLR(r) sal_memset(&((r)._t64), 0, sizeof(T64r_t))
#define T64r_SET(r,i,d) (r).t64[i] = d
#define T64r_GET(r,i) (r).t64[i]

/*
 * These macros can be used to access individual fields.
 */
#define T64r_COUNTf_GET(r,a) bcmpmac_field_get((r).t64,0,39,a)
#define T64r_COUNTf_SET(r,a) bcmpmac_field_set((r).t64,0,39,a)

/*
 * These macros can be used to access T64.
 */
#define READ_T64r(pa,p,r) bcmpmac_read(pa,p,T64r_OFFSET,0,T64r_SIZE,(r._t64))
#define WRITE_T64r(pa,p,r) bcmpmac_write(pa,p,T64r_OFFSET,0,T64r_SIZE,&(r._t64))

/*******************************************************************************
 * End of 'T64r'
 */




/*******************************************************************************
 * REGISTER:  T9216
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define T9216r_OFFSET 0x00004900

#define T9216r_SIZE 8

/*
 * This structure should be used to declare and program T9216.
 */
typedef union T9216r_s {
	uint32_t v[2];
	uint32_t t9216[2];
	uint32_t _t9216;
} T9216r_t;

#define T9216r_CLR(r) sal_memset(&((r)._t9216), 0, sizeof(T9216r_t))
#define T9216r_SET(r,i,d) (r).t9216[i] = d
#define T9216r_GET(r,i) (r).t9216[i]

/*
 * These macros can be used to access individual fields.
 */
#define T9216r_COUNTf_GET(r,a) bcmpmac_field_get((r).t9216,0,39,a)
#define T9216r_COUNTf_SET(r,a) bcmpmac_field_set((r).t9216,0,39,a)

/*
 * These macros can be used to access T9216.
 */
#define READ_T9216r(pa,p,r) bcmpmac_read(pa,p,T9216r_OFFSET,0,T9216r_SIZE,(r._t9216))
#define WRITE_T9216r(pa,p,r) bcmpmac_write(pa,p,T9216r_OFFSET,0,T9216r_SIZE,&(r._t9216))

/*******************************************************************************
 * End of 'T9216r'
 */




/*******************************************************************************
 * REGISTER:  TBCA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TBCAr_OFFSET 0x10004f00

#define TBCAr_SIZE 8

/*
 * This structure should be used to declare and program TBCA.
 */
typedef union TBCAr_s {
	uint32_t v[2];
	uint32_t tbca[2];
	uint32_t _tbca;
} TBCAr_t;

#define TBCAr_CLR(r) sal_memset(&((r)._tbca), 0, sizeof(TBCAr_t))
#define TBCAr_SET(r,i,d) (r).tbca[i] = d
#define TBCAr_GET(r,i) (r).tbca[i]

/*
 * These macros can be used to access individual fields.
 */
#define TBCAr_COUNTf_GET(r,a) bcmpmac_field_get((r).tbca,0,39,a)
#define TBCAr_COUNTf_SET(r,a) bcmpmac_field_set((r).tbca,0,39,a)

/*
 * These macros can be used to access TBCA.
 */
#define READ_TBCAr(pa,p,r) bcmpmac_read(pa,p,TBCAr_OFFSET,0,TBCAr_SIZE,(r._tbca))
#define WRITE_TBCAr(pa,p,r) bcmpmac_write(pa,p,TBCAr_OFFSET,0,TBCAr_SIZE,&(r._tbca))

/*******************************************************************************
 * End of 'TBCAr'
 */




/*******************************************************************************
 * REGISTER:  TBYT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TBYTr_OFFSET 0x10006f00

#define TBYTr_SIZE 8

/*
 * This structure should be used to declare and program TBYT.
 */
typedef union TBYTr_s {
	uint32_t v[2];
	uint32_t tbyt[2];
	uint32_t _tbyt;
} TBYTr_t;

#define TBYTr_CLR(r) sal_memset(&((r)._tbyt), 0, sizeof(TBYTr_t))
#define TBYTr_SET(r,i,d) (r).tbyt[i] = d
#define TBYTr_GET(r,i) (r).tbyt[i]

/*
 * These macros can be used to access individual fields.
 */
#define TBYTr_COUNTf_GET(r,a) bcmpmac_field_get((r).tbyt,0,47,a)
#define TBYTr_COUNTf_SET(r,a) bcmpmac_field_set((r).tbyt,0,47,a)

/*
 * These macros can be used to access TBYT.
 */
#define READ_TBYTr(pa,p,r) bcmpmac_read(pa,p,TBYTr_OFFSET,0,TBYTr_SIZE,(r._tbyt))
#define WRITE_TBYTr(pa,p,r) bcmpmac_write(pa,p,TBYTr_OFFSET,0,TBYTr_SIZE,&(r._tbyt))

/*******************************************************************************
 * End of 'TBYTr'
 */




/*******************************************************************************
 * REGISTER:  TDFR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TDFRr_OFFSET 0x10005600

#define TDFRr_SIZE 8

/*
 * This structure should be used to declare and program TDFR.
 */
typedef union TDFRr_s {
	uint32_t v[2];
	uint32_t tdfr[2];
	uint32_t _tdfr;
} TDFRr_t;

#define TDFRr_CLR(r) sal_memset(&((r)._tdfr), 0, sizeof(TDFRr_t))
#define TDFRr_SET(r,i,d) (r).tdfr[i] = d
#define TDFRr_GET(r,i) (r).tdfr[i]

/*
 * These macros can be used to access individual fields.
 */
#define TDFRr_COUNTf_GET(r,a) bcmpmac_field_get((r).tdfr,0,39,a)
#define TDFRr_COUNTf_SET(r,a) bcmpmac_field_set((r).tdfr,0,39,a)

/*
 * These macros can be used to access TDFR.
 */
#define READ_TDFRr(pa,p,r) bcmpmac_read(pa,p,TDFRr_OFFSET,0,TDFRr_SIZE,(r._tdfr))
#define WRITE_TDFRr(pa,p,r) bcmpmac_write(pa,p,TDFRr_OFFSET,0,TDFRr_SIZE,&(r._tdfr))

/*******************************************************************************
 * End of 'TDFRr'
 */




/*******************************************************************************
 * REGISTER:  TDVLN
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TDVLNr_OFFSET 0x10005f00

#define TDVLNr_SIZE 8

/*
 * This structure should be used to declare and program TDVLN.
 */
typedef union TDVLNr_s {
	uint32_t v[2];
	uint32_t tdvln[2];
	uint32_t _tdvln;
} TDVLNr_t;

#define TDVLNr_CLR(r) sal_memset(&((r)._tdvln), 0, sizeof(TDVLNr_t))
#define TDVLNr_SET(r,i,d) (r).tdvln[i] = d
#define TDVLNr_GET(r,i) (r).tdvln[i]

/*
 * These macros can be used to access individual fields.
 */
#define TDVLNr_COUNTf_GET(r,a) bcmpmac_field_get((r).tdvln,0,39,a)
#define TDVLNr_COUNTf_SET(r,a) bcmpmac_field_set((r).tdvln,0,39,a)

/*
 * These macros can be used to access TDVLN.
 */
#define READ_TDVLNr(pa,p,r) bcmpmac_read(pa,p,TDVLNr_OFFSET,0,TDVLNr_SIZE,(r._tdvln))
#define WRITE_TDVLNr(pa,p,r) bcmpmac_write(pa,p,TDVLNr_OFFSET,0,TDVLNr_SIZE,&(r._tdvln))

/*******************************************************************************
 * End of 'TDVLNr'
 */




/*******************************************************************************
 * REGISTER:  TEDF
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TEDFr_OFFSET 0x10005700

#define TEDFr_SIZE 8

/*
 * This structure should be used to declare and program TEDF.
 */
typedef union TEDFr_s {
	uint32_t v[2];
	uint32_t tedf[2];
	uint32_t _tedf;
} TEDFr_t;

#define TEDFr_CLR(r) sal_memset(&((r)._tedf), 0, sizeof(TEDFr_t))
#define TEDFr_SET(r,i,d) (r).tedf[i] = d
#define TEDFr_GET(r,i) (r).tedf[i]

/*
 * These macros can be used to access individual fields.
 */
#define TEDFr_COUNTf_GET(r,a) bcmpmac_field_get((r).tedf,0,39,a)
#define TEDFr_COUNTf_SET(r,a) bcmpmac_field_set((r).tedf,0,39,a)

/*
 * These macros can be used to access TEDF.
 */
#define READ_TEDFr(pa,p,r) bcmpmac_read(pa,p,TEDFr_OFFSET,0,TEDFr_SIZE,(r._tedf))
#define WRITE_TEDFr(pa,p,r) bcmpmac_write(pa,p,TEDFr_OFFSET,0,TEDFr_SIZE,&(r._tedf))

/*******************************************************************************
 * End of 'TEDFr'
 */




/*******************************************************************************
 * REGISTER:  TERR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TERRr_OFFSET 0x10005d00

#define TERRr_SIZE 8

/*
 * This structure should be used to declare and program TERR.
 */
typedef union TERRr_s {
	uint32_t v[2];
	uint32_t terr[2];
	uint32_t _terr;
} TERRr_t;

#define TERRr_CLR(r) sal_memset(&((r)._terr), 0, sizeof(TERRr_t))
#define TERRr_SET(r,i,d) (r).terr[i] = d
#define TERRr_GET(r,i) (r).terr[i]

/*
 * These macros can be used to access individual fields.
 */
#define TERRr_COUNTf_GET(r,a) bcmpmac_field_get((r).terr,0,39,a)
#define TERRr_COUNTf_SET(r,a) bcmpmac_field_set((r).terr,0,39,a)

/*
 * These macros can be used to access TERR.
 */
#define READ_TERRr(pa,p,r) bcmpmac_read(pa,p,TERRr_OFFSET,0,TERRr_SIZE,(r._terr))
#define WRITE_TERRr(pa,p,r) bcmpmac_write(pa,p,TERRr_OFFSET,0,TERRr_SIZE,&(r._terr))

/*******************************************************************************
 * End of 'TERRr'
 */




/*******************************************************************************
 * REGISTER:  TFCS
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TFCSr_OFFSET 0x10005300

#define TFCSr_SIZE 8

/*
 * This structure should be used to declare and program TFCS.
 */
typedef union TFCSr_s {
	uint32_t v[2];
	uint32_t tfcs[2];
	uint32_t _tfcs;
} TFCSr_t;

#define TFCSr_CLR(r) sal_memset(&((r)._tfcs), 0, sizeof(TFCSr_t))
#define TFCSr_SET(r,i,d) (r).tfcs[i] = d
#define TFCSr_GET(r,i) (r).tfcs[i]

/*
 * These macros can be used to access individual fields.
 */
#define TFCSr_COUNTf_GET(r,a) bcmpmac_field_get((r).tfcs,0,39,a)
#define TFCSr_COUNTf_SET(r,a) bcmpmac_field_set((r).tfcs,0,39,a)

/*
 * These macros can be used to access TFCS.
 */
#define READ_TFCSr(pa,p,r) bcmpmac_read(pa,p,TFCSr_OFFSET,0,TFCSr_SIZE,(r._tfcs))
#define WRITE_TFCSr(pa,p,r) bcmpmac_write(pa,p,TFCSr_OFFSET,0,TFCSr_SIZE,&(r._tfcs))

/*******************************************************************************
 * End of 'TFCSr'
 */




/*******************************************************************************
 * REGISTER:  TFRG
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TFRGr_OFFSET 0x10005c00

#define TFRGr_SIZE 8

/*
 * This structure should be used to declare and program TFRG.
 */
typedef union TFRGr_s {
	uint32_t v[2];
	uint32_t tfrg[2];
	uint32_t _tfrg;
} TFRGr_t;

#define TFRGr_CLR(r) sal_memset(&((r)._tfrg), 0, sizeof(TFRGr_t))
#define TFRGr_SET(r,i,d) (r).tfrg[i] = d
#define TFRGr_GET(r,i) (r).tfrg[i]

/*
 * These macros can be used to access individual fields.
 */
#define TFRGr_COUNTf_GET(r,a) bcmpmac_field_get((r).tfrg,0,39,a)
#define TFRGr_COUNTf_SET(r,a) bcmpmac_field_set((r).tfrg,0,39,a)

/*
 * These macros can be used to access TFRG.
 */
#define READ_TFRGr(pa,p,r) bcmpmac_read(pa,p,TFRGr_OFFSET,0,TFRGr_SIZE,(r._tfrg))
#define WRITE_TFRGr(pa,p,r) bcmpmac_write(pa,p,TFRGr_OFFSET,0,TFRGr_SIZE,&(r._tfrg))

/*******************************************************************************
 * End of 'TFRGr'
 */




/*******************************************************************************
 * REGISTER:  TJBR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TJBRr_OFFSET 0x10005200

#define TJBRr_SIZE 8

/*
 * This structure should be used to declare and program TJBR.
 */
typedef union TJBRr_s {
	uint32_t v[2];
	uint32_t tjbr[2];
	uint32_t _tjbr;
} TJBRr_t;

#define TJBRr_CLR(r) sal_memset(&((r)._tjbr), 0, sizeof(TJBRr_t))
#define TJBRr_SET(r,i,d) (r).tjbr[i] = d
#define TJBRr_GET(r,i) (r).tjbr[i]

/*
 * These macros can be used to access individual fields.
 */
#define TJBRr_COUNTf_GET(r,a) bcmpmac_field_get((r).tjbr,0,39,a)
#define TJBRr_COUNTf_SET(r,a) bcmpmac_field_set((r).tjbr,0,39,a)

/*
 * These macros can be used to access TJBR.
 */
#define READ_TJBRr(pa,p,r) bcmpmac_read(pa,p,TJBRr_OFFSET,0,TJBRr_SIZE,(r._tjbr))
#define WRITE_TJBRr(pa,p,r) bcmpmac_write(pa,p,TJBRr_OFFSET,0,TJBRr_SIZE,&(r._tjbr))

/*******************************************************************************
 * End of 'TJBRr'
 */




/*******************************************************************************
 * REGISTER:  TLCL
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TLCLr_OFFSET 0x10005a00

#define TLCLr_SIZE 8

/*
 * This structure should be used to declare and program TLCL.
 */
typedef union TLCLr_s {
	uint32_t v[2];
	uint32_t tlcl[2];
	uint32_t _tlcl;
} TLCLr_t;

#define TLCLr_CLR(r) sal_memset(&((r)._tlcl), 0, sizeof(TLCLr_t))
#define TLCLr_SET(r,i,d) (r).tlcl[i] = d
#define TLCLr_GET(r,i) (r).tlcl[i]

/*
 * These macros can be used to access individual fields.
 */
#define TLCLr_COUNTf_GET(r,a) bcmpmac_field_get((r).tlcl,0,39,a)
#define TLCLr_COUNTf_SET(r,a) bcmpmac_field_set((r).tlcl,0,39,a)

/*
 * These macros can be used to access TLCL.
 */
#define READ_TLCLr(pa,p,r) bcmpmac_read(pa,p,TLCLr_OFFSET,0,TLCLr_SIZE,(r._tlcl))
#define WRITE_TLCLr(pa,p,r) bcmpmac_write(pa,p,TLCLr_OFFSET,0,TLCLr_SIZE,&(r._tlcl))

/*******************************************************************************
 * End of 'TLCLr'
 */




/*******************************************************************************
 * REGISTER:  TMCA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TMCAr_OFFSET 0x10004e00

#define TMCAr_SIZE 8

/*
 * This structure should be used to declare and program TMCA.
 */
typedef union TMCAr_s {
	uint32_t v[2];
	uint32_t tmca[2];
	uint32_t _tmca;
} TMCAr_t;

#define TMCAr_CLR(r) sal_memset(&((r)._tmca), 0, sizeof(TMCAr_t))
#define TMCAr_SET(r,i,d) (r).tmca[i] = d
#define TMCAr_GET(r,i) (r).tmca[i]

/*
 * These macros can be used to access individual fields.
 */
#define TMCAr_COUNTf_GET(r,a) bcmpmac_field_get((r).tmca,0,39,a)
#define TMCAr_COUNTf_SET(r,a) bcmpmac_field_set((r).tmca,0,39,a)

/*
 * These macros can be used to access TMCA.
 */
#define READ_TMCAr(pa,p,r) bcmpmac_read(pa,p,TMCAr_OFFSET,0,TMCAr_SIZE,(r._tmca))
#define WRITE_TMCAr(pa,p,r) bcmpmac_write(pa,p,TMCAr_OFFSET,0,TMCAr_SIZE,&(r._tmca))

/*******************************************************************************
 * End of 'TMCAr'
 */




/*******************************************************************************
 * REGISTER:  TMCL
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TMCLr_OFFSET 0x10005900

#define TMCLr_SIZE 8

/*
 * This structure should be used to declare and program TMCL.
 */
typedef union TMCLr_s {
	uint32_t v[2];
	uint32_t tmcl[2];
	uint32_t _tmcl;
} TMCLr_t;

#define TMCLr_CLR(r) sal_memset(&((r)._tmcl), 0, sizeof(TMCLr_t))
#define TMCLr_SET(r,i,d) (r).tmcl[i] = d
#define TMCLr_GET(r,i) (r).tmcl[i]

/*
 * These macros can be used to access individual fields.
 */
#define TMCLr_COUNTf_GET(r,a) bcmpmac_field_get((r).tmcl,0,39,a)
#define TMCLr_COUNTf_SET(r,a) bcmpmac_field_set((r).tmcl,0,39,a)

/*
 * These macros can be used to access TMCL.
 */
#define READ_TMCLr(pa,p,r) bcmpmac_read(pa,p,TMCLr_OFFSET,0,TMCLr_SIZE,(r._tmcl))
#define WRITE_TMCLr(pa,p,r) bcmpmac_write(pa,p,TMCLr_OFFSET,0,TMCLr_SIZE,&(r._tmcl))

/*******************************************************************************
 * End of 'TMCLr'
 */




/*******************************************************************************
 * REGISTER:  TMGV
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TMGVr_OFFSET 0x00004600

#define TMGVr_SIZE 8

/*
 * This structure should be used to declare and program TMGV.
 */
typedef union TMGVr_s {
	uint32_t v[2];
	uint32_t tmgv[2];
	uint32_t _tmgv;
} TMGVr_t;

#define TMGVr_CLR(r) sal_memset(&((r)._tmgv), 0, sizeof(TMGVr_t))
#define TMGVr_SET(r,i,d) (r).tmgv[i] = d
#define TMGVr_GET(r,i) (r).tmgv[i]

/*
 * These macros can be used to access individual fields.
 */
#define TMGVr_COUNTf_GET(r,a) bcmpmac_field_get((r).tmgv,0,39,a)
#define TMGVr_COUNTf_SET(r,a) bcmpmac_field_set((r).tmgv,0,39,a)

/*
 * These macros can be used to access TMGV.
 */
#define READ_TMGVr(pa,p,r) bcmpmac_read(pa,p,TMGVr_OFFSET,0,TMGVr_SIZE,(r._tmgv))
#define WRITE_TMGVr(pa,p,r) bcmpmac_write(pa,p,TMGVr_OFFSET,0,TMGVr_SIZE,&(r._tmgv))

/*******************************************************************************
 * End of 'TMGVr'
 */




/*******************************************************************************
 * REGISTER:  TNCL
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TNCLr_OFFSET 0x10006e00

#define TNCLr_SIZE 8

/*
 * This structure should be used to declare and program TNCL.
 */
typedef union TNCLr_s {
	uint32_t v[2];
	uint32_t tncl[2];
	uint32_t _tncl;
} TNCLr_t;

#define TNCLr_CLR(r) sal_memset(&((r)._tncl), 0, sizeof(TNCLr_t))
#define TNCLr_SET(r,i,d) (r).tncl[i] = d
#define TNCLr_GET(r,i) (r).tncl[i]

/*
 * These macros can be used to access individual fields.
 */
#define TNCLr_COUNTf_GET(r,a) bcmpmac_field_get((r).tncl,0,39,a)
#define TNCLr_COUNTf_SET(r,a) bcmpmac_field_set((r).tncl,0,39,a)

/*
 * These macros can be used to access TNCL.
 */
#define READ_TNCLr(pa,p,r) bcmpmac_read(pa,p,TNCLr_OFFSET,0,TNCLr_SIZE,(r._tncl))
#define WRITE_TNCLr(pa,p,r) bcmpmac_write(pa,p,TNCLr_OFFSET,0,TNCLr_SIZE,&(r._tncl))

/*******************************************************************************
 * End of 'TNCLr'
 */




/*******************************************************************************
 * REGISTER:  TOVR
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TOVRr_OFFSET 0x10005500

#define TOVRr_SIZE 8

/*
 * This structure should be used to declare and program TOVR.
 */
typedef union TOVRr_s {
	uint32_t v[2];
	uint32_t tovr[2];
	uint32_t _tovr;
} TOVRr_t;

#define TOVRr_CLR(r) sal_memset(&((r)._tovr), 0, sizeof(TOVRr_t))
#define TOVRr_SET(r,i,d) (r).tovr[i] = d
#define TOVRr_GET(r,i) (r).tovr[i]

/*
 * These macros can be used to access individual fields.
 */
#define TOVRr_COUNTf_GET(r,a) bcmpmac_field_get((r).tovr,0,39,a)
#define TOVRr_COUNTf_SET(r,a) bcmpmac_field_set((r).tovr,0,39,a)

/*
 * These macros can be used to access TOVR.
 */
#define READ_TOVRr(pa,p,r) bcmpmac_read(pa,p,TOVRr_OFFSET,0,TOVRr_SIZE,(r._tovr))
#define WRITE_TOVRr(pa,p,r) bcmpmac_write(pa,p,TOVRr_OFFSET,0,TOVRr_SIZE,&(r._tovr))

/*******************************************************************************
 * End of 'TOVRr'
 */




/*******************************************************************************
 * REGISTER:  TPFC
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFCr_OFFSET 0x10006200

#define TPFCr_SIZE 8

/*
 * This structure should be used to declare and program TPFC.
 */
typedef union TPFCr_s {
	uint32_t v[2];
	uint32_t tpfc[2];
	uint32_t _tpfc;
} TPFCr_t;

#define TPFCr_CLR(r) sal_memset(&((r)._tpfc), 0, sizeof(TPFCr_t))
#define TPFCr_SET(r,i,d) (r).tpfc[i] = d
#define TPFCr_GET(r,i) (r).tpfc[i]

/*
 * These macros can be used to access individual fields.
 */
#define TPFCr_COUNTf_GET(r,a) bcmpmac_field_get((r).tpfc,0,39,a)
#define TPFCr_COUNTf_SET(r,a) bcmpmac_field_set((r).tpfc,0,39,a)

/*
 * These macros can be used to access TPFC.
 */
#define READ_TPFCr(pa,p,i,r) bcmpmac_read(pa,p,TPFCr_OFFSET,i,TPFCr_SIZE,(r._tpfc))
#define WRITE_TPFCr(pa,p,i,r) bcmpmac_write(pa,p,TPFCr_OFFSET,i,TPFCr_SIZE,&(r._tpfc))

/*******************************************************************************
 * End of 'TPFCr'
 */




/*******************************************************************************
 * REGISTER:  TPFC0
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC0r_OFFSET 0x10006200

#define TPFC0r_SIZE 8

/* TPFC0r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPFC1
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC1r_OFFSET 0x10006300

#define TPFC1r_SIZE 8

/* TPFC1r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPFC2
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC2r_OFFSET 0x10006400

#define TPFC2r_SIZE 8

/* TPFC2r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPFC3
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC3r_OFFSET 0x10006500

#define TPFC3r_SIZE 8

/* TPFC3r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPFC4
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC4r_OFFSET 0x10006600

#define TPFC4r_SIZE 8

/* TPFC4r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPFC5
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC5r_OFFSET 0x10006700

#define TPFC5r_SIZE 8

/* TPFC5r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPFC6
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC6r_OFFSET 0x10006800

#define TPFC6r_SIZE 8

/* TPFC6r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPFC7
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPFC7r_OFFSET 0x10006900

#define TPFC7r_SIZE 8

/* TPFC7r is element of TPFC */

/*******************************************************************************
 * REGISTER:  TPKT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPKTr_OFFSET 0x00004c00

#define TPKTr_SIZE 8

/*
 * This structure should be used to declare and program TPKT.
 */
typedef union TPKTr_s {
	uint32_t v[2];
	uint32_t tpkt[2];
	uint32_t _tpkt;
} TPKTr_t;

#define TPKTr_CLR(r) sal_memset(&((r)._tpkt), 0, sizeof(TPKTr_t))
#define TPKTr_SET(r,i,d) (r).tpkt[i] = d
#define TPKTr_GET(r,i) (r).tpkt[i]

/*
 * These macros can be used to access individual fields.
 */
#define TPKTr_COUNTf_GET(r,a) bcmpmac_field_get((r).tpkt,0,39,a)
#define TPKTr_COUNTf_SET(r,a) bcmpmac_field_set((r).tpkt,0,39,a)

/*
 * These macros can be used to access TPKT.
 */
#define READ_TPKTr(pa,p,r) bcmpmac_read(pa,p,TPKTr_OFFSET,0,TPKTr_SIZE,(r._tpkt))
#define WRITE_TPKTr(pa,p,r) bcmpmac_write(pa,p,TPKTr_OFFSET,0,TPKTr_SIZE,&(r._tpkt))

/*******************************************************************************
 * End of 'TPKTr'
 */




/*******************************************************************************
 * REGISTER:  TPOK
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TPOKr_OFFSET 0x10004b00

#define TPOKr_SIZE 8

/*
 * This structure should be used to declare and program TPOK.
 */
typedef union TPOKr_s {
	uint32_t v[2];
	uint32_t tpok[2];
	uint32_t _tpok;
} TPOKr_t;

#define TPOKr_CLR(r) sal_memset(&((r)._tpok), 0, sizeof(TPOKr_t))
#define TPOKr_SET(r,i,d) (r).tpok[i] = d
#define TPOKr_GET(r,i) (r).tpok[i]

/*
 * These macros can be used to access individual fields.
 */
#define TPOKr_COUNTf_GET(r,a) bcmpmac_field_get((r).tpok,0,39,a)
#define TPOKr_COUNTf_SET(r,a) bcmpmac_field_set((r).tpok,0,39,a)

/*
 * These macros can be used to access TPOK.
 */
#define READ_TPOKr(pa,p,r) bcmpmac_read(pa,p,TPOKr_OFFSET,0,TPOKr_SIZE,(r._tpok))
#define WRITE_TPOKr(pa,p,r) bcmpmac_write(pa,p,TPOKr_OFFSET,0,TPOKr_SIZE,&(r._tpok))

/*******************************************************************************
 * End of 'TPOKr'
 */




/*******************************************************************************
 * REGISTER:  TRPKT
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TRPKTr_OFFSET 0x10006000

#define TRPKTr_SIZE 8

/*
 * This structure should be used to declare and program TRPKT.
 */
typedef union TRPKTr_s {
	uint32_t v[2];
	uint32_t trpkt[2];
	uint32_t _trpkt;
} TRPKTr_t;

#define TRPKTr_CLR(r) sal_memset(&((r)._trpkt), 0, sizeof(TRPKTr_t))
#define TRPKTr_SET(r,i,d) (r).trpkt[i] = d
#define TRPKTr_GET(r,i) (r).trpkt[i]

/*
 * These macros can be used to access individual fields.
 */
#define TRPKTr_COUNTf_GET(r,a) bcmpmac_field_get((r).trpkt,0,39,a)
#define TRPKTr_COUNTf_SET(r,a) bcmpmac_field_set((r).trpkt,0,39,a)

/*
 * These macros can be used to access TRPKT.
 */
#define READ_TRPKTr(pa,p,r) bcmpmac_read(pa,p,TRPKTr_OFFSET,0,TRPKTr_SIZE,(r._trpkt))
#define WRITE_TRPKTr(pa,p,r) bcmpmac_write(pa,p,TRPKTr_OFFSET,0,TRPKTr_SIZE,&(r._trpkt))

/*******************************************************************************
 * End of 'TRPKTr'
 */




/*******************************************************************************
 * REGISTER:  TSCL
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TSCLr_OFFSET 0x10005800

#define TSCLr_SIZE 8

/*
 * This structure should be used to declare and program TSCL.
 */
typedef union TSCLr_s {
	uint32_t v[2];
	uint32_t tscl[2];
	uint32_t _tscl;
} TSCLr_t;

#define TSCLr_CLR(r) sal_memset(&((r)._tscl), 0, sizeof(TSCLr_t))
#define TSCLr_SET(r,i,d) (r).tscl[i] = d
#define TSCLr_GET(r,i) (r).tscl[i]

/*
 * These macros can be used to access individual fields.
 */
#define TSCLr_COUNTf_GET(r,a) bcmpmac_field_get((r).tscl,0,39,a)
#define TSCLr_COUNTf_SET(r,a) bcmpmac_field_set((r).tscl,0,39,a)

/*
 * These macros can be used to access TSCL.
 */
#define READ_TSCLr(pa,p,r) bcmpmac_read(pa,p,TSCLr_OFFSET,0,TSCLr_SIZE,(r._tscl))
#define WRITE_TSCLr(pa,p,r) bcmpmac_write(pa,p,TSCLr_OFFSET,0,TSCLr_SIZE,&(r._tscl))

/*******************************************************************************
 * End of 'TSCLr'
 */




/*******************************************************************************
 * REGISTER:  TUCA
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TUCAr_OFFSET 0x00004d00

#define TUCAr_SIZE 8

/*
 * This structure should be used to declare and program TUCA.
 */
typedef union TUCAr_s {
	uint32_t v[2];
	uint32_t tuca[2];
	uint32_t _tuca;
} TUCAr_t;

#define TUCAr_CLR(r) sal_memset(&((r)._tuca), 0, sizeof(TUCAr_t))
#define TUCAr_SET(r,i,d) (r).tuca[i] = d
#define TUCAr_GET(r,i) (r).tuca[i]

/*
 * These macros can be used to access individual fields.
 */
#define TUCAr_COUNTf_GET(r,a) bcmpmac_field_get((r).tuca,0,39,a)
#define TUCAr_COUNTf_SET(r,a) bcmpmac_field_set((r).tuca,0,39,a)

/*
 * These macros can be used to access TUCA.
 */
#define READ_TUCAr(pa,p,r) bcmpmac_read(pa,p,TUCAr_OFFSET,0,TUCAr_SIZE,(r._tuca))
#define WRITE_TUCAr(pa,p,r) bcmpmac_write(pa,p,TUCAr_OFFSET,0,TUCAr_SIZE,&(r._tuca))

/*******************************************************************************
 * End of 'TUCAr'
 */




/*******************************************************************************
 * REGISTER:  TUFL
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TUFLr_OFFSET 0x10006100

#define TUFLr_SIZE 8

/*
 * This structure should be used to declare and program TUFL.
 */
typedef union TUFLr_s {
	uint32_t v[2];
	uint32_t tufl[2];
	uint32_t _tufl;
} TUFLr_t;

#define TUFLr_CLR(r) sal_memset(&((r)._tufl), 0, sizeof(TUFLr_t))
#define TUFLr_SET(r,i,d) (r).tufl[i] = d
#define TUFLr_GET(r,i) (r).tufl[i]

/*
 * These macros can be used to access individual fields.
 */
#define TUFLr_COUNTf_GET(r,a) bcmpmac_field_get((r).tufl,0,39,a)
#define TUFLr_COUNTf_SET(r,a) bcmpmac_field_set((r).tufl,0,39,a)

/*
 * These macros can be used to access TUFL.
 */
#define READ_TUFLr(pa,p,r) bcmpmac_read(pa,p,TUFLr_OFFSET,0,TUFLr_SIZE,(r._tufl))
#define WRITE_TUFLr(pa,p,r) bcmpmac_write(pa,p,TUFLr_OFFSET,0,TUFLr_SIZE,&(r._tufl))

/*******************************************************************************
 * End of 'TUFLr'
 */




/*******************************************************************************
 * REGISTER:  TVLN
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TVLNr_OFFSET 0x10005e00

#define TVLNr_SIZE 8

/*
 * This structure should be used to declare and program TVLN.
 */
typedef union TVLNr_s {
	uint32_t v[2];
	uint32_t tvln[2];
	uint32_t _tvln;
} TVLNr_t;

#define TVLNr_CLR(r) sal_memset(&((r)._tvln), 0, sizeof(TVLNr_t))
#define TVLNr_SET(r,i,d) (r).tvln[i] = d
#define TVLNr_GET(r,i) (r).tvln[i]

/*
 * These macros can be used to access individual fields.
 */
#define TVLNr_COUNTf_GET(r,a) bcmpmac_field_get((r).tvln,0,39,a)
#define TVLNr_COUNTf_SET(r,a) bcmpmac_field_set((r).tvln,0,39,a)

/*
 * These macros can be used to access TVLN.
 */
#define READ_TVLNr(pa,p,r) bcmpmac_read(pa,p,TVLNr_OFFSET,0,TVLNr_SIZE,(r._tvln))
#define WRITE_TVLNr(pa,p,r) bcmpmac_write(pa,p,TVLNr_OFFSET,0,TVLNr_SIZE,&(r._tvln))

/*******************************************************************************
 * End of 'TVLNr'
 */




/*******************************************************************************
 * REGISTER:  TXCF
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TXCFr_OFFSET 0x10005400

#define TXCFr_SIZE 8

/*
 * This structure should be used to declare and program TXCF.
 */
typedef union TXCFr_s {
	uint32_t v[2];
	uint32_t txcf[2];
	uint32_t _txcf;
} TXCFr_t;

#define TXCFr_CLR(r) sal_memset(&((r)._txcf), 0, sizeof(TXCFr_t))
#define TXCFr_SET(r,i,d) (r).txcf[i] = d
#define TXCFr_GET(r,i) (r).txcf[i]

/*
 * These macros can be used to access individual fields.
 */
#define TXCFr_COUNTf_GET(r,a) bcmpmac_field_get((r).txcf,0,39,a)
#define TXCFr_COUNTf_SET(r,a) bcmpmac_field_set((r).txcf,0,39,a)

/*
 * These macros can be used to access TXCF.
 */
#define READ_TXCFr(pa,p,r) bcmpmac_read(pa,p,TXCFr_OFFSET,0,TXCFr_SIZE,(r._txcf))
#define WRITE_TXCFr(pa,p,r) bcmpmac_write(pa,p,TXCFr_OFFSET,0,TXCFr_SIZE,&(r._txcf))

/*******************************************************************************
 * End of 'TXCFr'
 */




/*******************************************************************************
 * REGISTER:  TXCL
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TXCLr_OFFSET 0x10005b00

#define TXCLr_SIZE 8

/*
 * This structure should be used to declare and program TXCL.
 */
typedef union TXCLr_s {
	uint32_t v[2];
	uint32_t txcl[2];
	uint32_t _txcl;
} TXCLr_t;

#define TXCLr_CLR(r) sal_memset(&((r)._txcl), 0, sizeof(TXCLr_t))
#define TXCLr_SET(r,i,d) (r).txcl[i] = d
#define TXCLr_GET(r,i) (r).txcl[i]

/*
 * These macros can be used to access individual fields.
 */
#define TXCLr_COUNTf_GET(r,a) bcmpmac_field_get((r).txcl,0,39,a)
#define TXCLr_COUNTf_SET(r,a) bcmpmac_field_set((r).txcl,0,39,a)

/*
 * These macros can be used to access TXCL.
 */
#define READ_TXCLr(pa,p,r) bcmpmac_read(pa,p,TXCLr_OFFSET,0,TXCLr_SIZE,(r._txcl))
#define WRITE_TXCLr(pa,p,r) bcmpmac_write(pa,p,TXCLr_OFFSET,0,TXCLr_SIZE,&(r._txcl))

/*******************************************************************************
 * End of 'TXCLr'
 */




/*******************************************************************************
 * REGISTER:  TXPF
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TXPFr_OFFSET 0x10005000

#define TXPFr_SIZE 8

/*
 * This structure should be used to declare and program TXPF.
 */
typedef union TXPFr_s {
	uint32_t v[2];
	uint32_t txpf[2];
	uint32_t _txpf;
} TXPFr_t;

#define TXPFr_CLR(r) sal_memset(&((r)._txpf), 0, sizeof(TXPFr_t))
#define TXPFr_SET(r,i,d) (r).txpf[i] = d
#define TXPFr_GET(r,i) (r).txpf[i]

/*
 * These macros can be used to access individual fields.
 */
#define TXPFr_COUNTf_GET(r,a) bcmpmac_field_get((r).txpf,0,39,a)
#define TXPFr_COUNTf_SET(r,a) bcmpmac_field_set((r).txpf,0,39,a)

/*
 * These macros can be used to access TXPF.
 */
#define READ_TXPFr(pa,p,r) bcmpmac_read(pa,p,TXPFr_OFFSET,0,TXPFr_SIZE,(r._txpf))
#define WRITE_TXPFr(pa,p,r) bcmpmac_write(pa,p,TXPFr_OFFSET,0,TXPFr_SIZE,&(r._txpf))

/*******************************************************************************
 * End of 'TXPFr'
 */




/*******************************************************************************
 * REGISTER:  TXPP
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TXPPr_OFFSET 0x10005100

#define TXPPr_SIZE 8

/*
 * This structure should be used to declare and program TXPP.
 */
typedef union TXPPr_s {
	uint32_t v[2];
	uint32_t txpp[2];
	uint32_t _txpp;
} TXPPr_t;

#define TXPPr_CLR(r) sal_memset(&((r)._txpp), 0, sizeof(TXPPr_t))
#define TXPPr_SET(r,i,d) (r).txpp[i] = d
#define TXPPr_GET(r,i) (r).txpp[i]

/*
 * These macros can be used to access individual fields.
 */
#define TXPPr_COUNTf_GET(r,a) bcmpmac_field_get((r).txpp,0,39,a)
#define TXPPr_COUNTf_SET(r,a) bcmpmac_field_set((r).txpp,0,39,a)

/*
 * These macros can be used to access TXPP.
 */
#define READ_TXPPr(pa,p,r) bcmpmac_read(pa,p,TXPPr_OFFSET,0,TXPPr_SIZE,(r._txpp))
#define WRITE_TXPPr(pa,p,r) bcmpmac_write(pa,p,TXPPr_OFFSET,0,TXPPr_SIZE,&(r._txpp))

/*******************************************************************************
 * End of 'TXPPr'
 */




/*******************************************************************************
 * REGISTER:  TX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TX_EEE_LPI_DURATION_COUNTERr_OFFSET 0x10006b00

#define TX_EEE_LPI_DURATION_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program TX_EEE_LPI_DURATION_COUNTER.
 */
typedef union TX_EEE_LPI_DURATION_COUNTERr_s {
	uint32_t v[2];
	uint32_t tx_eee_lpi_duration_counter[2];
	uint32_t _tx_eee_lpi_duration_counter;
} TX_EEE_LPI_DURATION_COUNTERr_t;

#define TX_EEE_LPI_DURATION_COUNTERr_CLR(r) sal_memset(&((r)._tx_eee_lpi_duration_counter), 0, sizeof(TX_EEE_LPI_DURATION_COUNTERr_t))
#define TX_EEE_LPI_DURATION_COUNTERr_SET(r,i,d) (r).tx_eee_lpi_duration_counter[i] = d
#define TX_EEE_LPI_DURATION_COUNTERr_GET(r,i) (r).tx_eee_lpi_duration_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_EEE_LPI_DURATION_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).tx_eee_lpi_duration_counter,0,39,a)
#define TX_EEE_LPI_DURATION_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).tx_eee_lpi_duration_counter,0,39,a)

/*
 * These macros can be used to access TX_EEE_LPI_DURATION_COUNTER.
 */
#define READ_TX_EEE_LPI_DURATION_COUNTERr(pa,p,r) bcmpmac_read(pa,p,TX_EEE_LPI_DURATION_COUNTERr_OFFSET,0,TX_EEE_LPI_DURATION_COUNTERr_SIZE,(r._tx_eee_lpi_duration_counter))
#define WRITE_TX_EEE_LPI_DURATION_COUNTERr(pa,p,r) bcmpmac_write(pa,p,TX_EEE_LPI_DURATION_COUNTERr_OFFSET,0,TX_EEE_LPI_DURATION_COUNTERr_SIZE,&(r._tx_eee_lpi_duration_counter))

/*******************************************************************************
 * End of 'TX_EEE_LPI_DURATION_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  TX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TX_EEE_LPI_EVENT_COUNTERr_OFFSET 0x10006a00

#define TX_EEE_LPI_EVENT_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program TX_EEE_LPI_EVENT_COUNTER.
 */
typedef union TX_EEE_LPI_EVENT_COUNTERr_s {
	uint32_t v[2];
	uint32_t tx_eee_lpi_event_counter[2];
	uint32_t _tx_eee_lpi_event_counter;
} TX_EEE_LPI_EVENT_COUNTERr_t;

#define TX_EEE_LPI_EVENT_COUNTERr_CLR(r) sal_memset(&((r)._tx_eee_lpi_event_counter), 0, sizeof(TX_EEE_LPI_EVENT_COUNTERr_t))
#define TX_EEE_LPI_EVENT_COUNTERr_SET(r,i,d) (r).tx_eee_lpi_event_counter[i] = d
#define TX_EEE_LPI_EVENT_COUNTERr_GET(r,i) (r).tx_eee_lpi_event_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_EEE_LPI_EVENT_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).tx_eee_lpi_event_counter,0,39,a)
#define TX_EEE_LPI_EVENT_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).tx_eee_lpi_event_counter,0,39,a)

/*
 * These macros can be used to access TX_EEE_LPI_EVENT_COUNTER.
 */
#define READ_TX_EEE_LPI_EVENT_COUNTERr(pa,p,r) bcmpmac_read(pa,p,TX_EEE_LPI_EVENT_COUNTERr_OFFSET,0,TX_EEE_LPI_EVENT_COUNTERr_SIZE,(r._tx_eee_lpi_event_counter))
#define WRITE_TX_EEE_LPI_EVENT_COUNTERr(pa,p,r) bcmpmac_write(pa,p,TX_EEE_LPI_EVENT_COUNTERr_OFFSET,0,TX_EEE_LPI_EVENT_COUNTERr_SIZE,&(r._tx_eee_lpi_event_counter))

/*******************************************************************************
 * End of 'TX_EEE_LPI_EVENT_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  TX_HCFC_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TX_HCFC_COUNTERr_OFFSET 0x10006d00

#define TX_HCFC_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program TX_HCFC_COUNTER.
 */
typedef union TX_HCFC_COUNTERr_s {
	uint32_t v[2];
	uint32_t tx_hcfc_counter[2];
	uint32_t _tx_hcfc_counter;
} TX_HCFC_COUNTERr_t;

#define TX_HCFC_COUNTERr_CLR(r) sal_memset(&((r)._tx_hcfc_counter), 0, sizeof(TX_HCFC_COUNTERr_t))
#define TX_HCFC_COUNTERr_SET(r,i,d) (r).tx_hcfc_counter[i] = d
#define TX_HCFC_COUNTERr_GET(r,i) (r).tx_hcfc_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_HCFC_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).tx_hcfc_counter,0,39,a)
#define TX_HCFC_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).tx_hcfc_counter,0,39,a)

/*
 * These macros can be used to access TX_HCFC_COUNTER.
 */
#define READ_TX_HCFC_COUNTERr(pa,p,r) bcmpmac_read(pa,p,TX_HCFC_COUNTERr_OFFSET,0,TX_HCFC_COUNTERr_SIZE,(r._tx_hcfc_counter))
#define WRITE_TX_HCFC_COUNTERr(pa,p,r) bcmpmac_write(pa,p,TX_HCFC_COUNTERr_OFFSET,0,TX_HCFC_COUNTERr_SIZE,&(r._tx_hcfc_counter))

/*******************************************************************************
 * End of 'TX_HCFC_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  TX_LLFC_LOG_COUNTER
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     64
 */
#define TX_LLFC_LOG_COUNTERr_OFFSET 0x10006c00

#define TX_LLFC_LOG_COUNTERr_SIZE 8

/*
 * This structure should be used to declare and program TX_LLFC_LOG_COUNTER.
 */
typedef union TX_LLFC_LOG_COUNTERr_s {
	uint32_t v[2];
	uint32_t tx_llfc_log_counter[2];
	uint32_t _tx_llfc_log_counter;
} TX_LLFC_LOG_COUNTERr_t;

#define TX_LLFC_LOG_COUNTERr_CLR(r) sal_memset(&((r)._tx_llfc_log_counter), 0, sizeof(TX_LLFC_LOG_COUNTERr_t))
#define TX_LLFC_LOG_COUNTERr_SET(r,i,d) (r).tx_llfc_log_counter[i] = d
#define TX_LLFC_LOG_COUNTERr_GET(r,i) (r).tx_llfc_log_counter[i]

/*
 * These macros can be used to access individual fields.
 */
#define TX_LLFC_LOG_COUNTERr_COUNTf_GET(r,a) bcmpmac_field_get((r).tx_llfc_log_counter,0,39,a)
#define TX_LLFC_LOG_COUNTERr_COUNTf_SET(r,a) bcmpmac_field_set((r).tx_llfc_log_counter,0,39,a)

/*
 * These macros can be used to access TX_LLFC_LOG_COUNTER.
 */
#define READ_TX_LLFC_LOG_COUNTERr(pa,p,r) bcmpmac_read(pa,p,TX_LLFC_LOG_COUNTERr_OFFSET,0,TX_LLFC_LOG_COUNTERr_SIZE,(r._tx_llfc_log_counter))
#define WRITE_TX_LLFC_LOG_COUNTERr(pa,p,r) bcmpmac_write(pa,p,TX_LLFC_LOG_COUNTERr_OFFSET,0,TX_LLFC_LOG_COUNTERr_SIZE,&(r._tx_llfc_log_counter))

/*******************************************************************************
 * End of 'TX_LLFC_LOG_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  XTHOL
 * BLOCKS:   CLPORT XLPORT
 * SIZE:     32
 */
#define XTHOLr_OFFSET 0x00007000

#define XTHOLr_SIZE 4

/*
 * This structure should be used to declare and program XTHOL.
 */
typedef union XTHOLr_s {
	uint32_t v[1];
	uint32_t xthol[1];
	uint32_t _xthol;
} XTHOLr_t;

#define XTHOLr_CLR(r) (r).xthol[0] = 0
#define XTHOLr_SET(r,d) (r).xthol[0] = d
#define XTHOLr_GET(r) (r).xthol[0]

/*
 * These macros can be used to access individual fields.
 */
#define XTHOLr_COUNTf_GET(r) ((r).xthol[0])
#define XTHOLr_COUNTf_SET(r,f) (r).xthol[0]=((uint32_t)f)

/*
 * These macros can be used to access XTHOL.
 */
#define READ_XTHOLr(pa,p,r) bcmpmac_read(pa,p,XTHOLr_OFFSET,0,XTHOLr_SIZE,(r._xthol))
#define WRITE_XTHOLr(pa,p,r) bcmpmac_write(pa,p,XTHOLr_OFFSET,0,XTHOLr_SIZE,&(r._xthol))

/*******************************************************************************
 * End of 'XTHOLr'
 */




#endif /* BCM56960_A0_CLPORT_DEFS_H */
