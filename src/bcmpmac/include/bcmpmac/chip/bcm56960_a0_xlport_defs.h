#ifndef BCM56960_A0_XLPORT_DEFS_H
#define BCM56960_A0_XLPORT_DEFS_H
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: $
 * Copyright: (c) 2018 Broadcom. All Rights Reserved. "Broadcom" refers to 
 * Broadcom Limited and/or its subsidiaries.
 * 
 * Broadcom Switch Software License
 * 
 * This license governs the use of the accompanying Broadcom software. Your 
 * use of the software indicates your acceptance of the terms and conditions 
 * of this license. If you do not agree to the terms and conditions of this 
 * license, do not use the software.
 * 1. Definitions
 *    "Licensor" means any person or entity that distributes its Work.
 *    "Software" means the original work of authorship made available under 
 *    this license.
 *    "Work" means the Software and any additions to or derivative works of 
 *    the Software that are made available under this license.
 *    The terms "reproduce," "reproduction," "derivative works," and 
 *    "distribution" have the meaning as provided under U.S. copyright law.
 *    Works, including the Software, are "made available" under this license 
 *    by including in or with the Work either (a) a copyright notice 
 *    referencing the applicability of this license to the Work, or (b) a copy 
 *    of this license.
 * 2. Grant of Copyright License
 *    Subject to the terms and conditions of this license, each Licensor 
 *    grants to you a perpetual, worldwide, non-exclusive, and royalty-free 
 *    copyright license to reproduce, prepare derivative works of, publicly 
 *    display, publicly perform, sublicense and distribute its Work and any 
 *    resulting derivative works in any form.
 * 3. Grant of Patent License
 *    Subject to the terms and conditions of this license, each Licensor 
 *    grants to you a perpetual, worldwide, non-exclusive, and royalty-free 
 *    patent license to make, have made, use, offer to sell, sell, import, and 
 *    otherwise transfer its Work, in whole or in part. This patent license 
 *    applies only to the patent claims licensable by Licensor that would be 
 *    infringed by Licensor's Work (or portion thereof) individually and 
 *    excluding any combinations with any other materials or technology.
 *    If you institute patent litigation against any Licensor (including a 
 *    cross-claim or counterclaim in a lawsuit) to enforce any patents that 
 *    you allege are infringed by any Work, then your patent license from such 
 *    Licensor to the Work shall terminate as of the date such litigation is 
 *    filed.
 * 4. Redistribution
 *    You may reproduce or distribute the Work only if (a) you do so under 
 *    this License, (b) you include a complete copy of this License with your 
 *    distribution, and (c) you retain without modification any copyright, 
 *    patent, trademark, or attribution notices that are present in the Work.
 * 5. Derivative Works
 *    You may specify that additional or different terms apply to the use, 
 *    reproduction, and distribution of your derivative works of the Work 
 *    ("Your Terms") only if (a) Your Terms provide that the limitations of 
 *    Section 7 apply to your derivative works, and (b) you identify the 
 *    specific derivative works that are subject to Your Terms. 
 *    Notwithstanding Your Terms, this license (including the redistribution 
 *    requirements in Section 4) will continue to apply to the Work itself.
 * 6. Trademarks
 *    This license does not grant any rights to use any Licensor's or its 
 *    affiliates' names, logos, or trademarks, except as necessary to 
 *    reproduce the notices described in this license.
 * 7. Limitations
 *    Platform. The Work and any derivative works thereof may only be used, or 
 *    intended for use, with a Broadcom switch integrated circuit.
 *    No Reverse Engineering. You will not use the Work to disassemble, 
 *    reverse engineer, decompile, or attempt to ascertain the underlying 
 *    technology of a Broadcom switch integrated circuit.
 * 8. Termination
 *    If you violate any term of this license, then your rights under this 
 *    license (including the license grants of Sections 2 and 3) will 
 *    terminate immediately.
 * 9. Disclaimer of Warranty
 *    THE WORK IS PROVIDED "AS IS" WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 *    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WARRANTIES OR CONDITIONS OF 
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR 
 *    NON-INFRINGEMENT. YOU BEAR THE RISK OF UNDERTAKING ANY ACTIVITIES UNDER 
 *    THIS LICENSE. SOME STATES' CONSUMER LAWS DO NOT ALLOW EXCLUSION OF AN 
 *    IMPLIED WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO YOU.
 * 10. Limitation of Liability
 *    EXCEPT AS PROHIBITED BY APPLICABLE LAW, IN NO EVENT AND UNDER NO LEGAL 
 *    THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE 
 *    SHALL ANY LICENSOR BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY DIRECT, 
 *    INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF 
 *    OR RELATED TO THIS LICENSE, THE USE OR INABILITY TO USE THE WORK 
 *    (INCLUDING BUT NOT LIMITED TO LOSS OF GOODWILL, BUSINESS INTERRUPTION, 
 *    LOST PROFITS OR DATA, COMPUTER FAILURE OR MALFUNCTION, OR ANY OTHER 
 *    COMMERCIAL DAMAGES OR LOSSES), EVEN IF THE LICENSOR HAS BEEN ADVISED OF 
 *    THE POSSIBILITY OF SUCH DAMAGES.
 * 
 * 
 *
 * Definition file for the BCM56960_A0.
 */

#include <sal/sal_libc.h>

/*******************************************************************************
 * REGISTER:  XLMAC_CLEAR_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_CLEAR_ECC_STATUSr_OFFSET 0x10063300

#define XLMAC_CLEAR_ECC_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_CLEAR_ECC_STATUS.
 */
typedef union XLMAC_CLEAR_ECC_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_clear_ecc_status[2];
	uint32_t _xlmac_clear_ecc_status;
} XLMAC_CLEAR_ECC_STATUSr_t;

#define XLMAC_CLEAR_ECC_STATUSr_CLR(r) sal_memset(&((r)._xlmac_clear_ecc_status), 0, sizeof(XLMAC_CLEAR_ECC_STATUSr_t))
#define XLMAC_CLEAR_ECC_STATUSr_SET(r,i,d) (r).xlmac_clear_ecc_status[i] = d
#define XLMAC_CLEAR_ECC_STATUSr_GET(r,i) (r).xlmac_clear_ecc_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_SINGLE_BIT_ERRf_GET(r) (((r).xlmac_clear_ecc_status[0]) & 0x1)
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).xlmac_clear_ecc_status[0]=(((r).xlmac_clear_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).xlmac_clear_ecc_status[0]) >> 1) & 0x1)
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_RX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).xlmac_clear_ecc_status[0]=(((r).xlmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_SINGLE_BIT_ERRf_GET(r) ((((r).xlmac_clear_ecc_status[0]) >> 2) & 0x1)
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).xlmac_clear_ecc_status[0]=(((r).xlmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).xlmac_clear_ecc_status[0]) >> 3) & 0x1)
#define XLMAC_CLEAR_ECC_STATUSr_CLEAR_TX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).xlmac_clear_ecc_status[0]=(((r).xlmac_clear_ecc_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access XLMAC_CLEAR_ECC_STATUS.
 */
#define READ_XLMAC_CLEAR_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_CLEAR_ECC_STATUSr_OFFSET,0,XLMAC_CLEAR_ECC_STATUSr_SIZE,(r._xlmac_clear_ecc_status))
#define WRITE_XLMAC_CLEAR_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_CLEAR_ECC_STATUSr_OFFSET,0,XLMAC_CLEAR_ECC_STATUSr_SIZE,&(r._xlmac_clear_ecc_status))

/*******************************************************************************
 * End of 'XLMAC_CLEAR_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_CLEAR_FIFO_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_CLEAR_FIFO_STATUSr_OFFSET 0x10061800

#define XLMAC_CLEAR_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_CLEAR_FIFO_STATUS.
 */
typedef union XLMAC_CLEAR_FIFO_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_clear_fifo_status[2];
	uint32_t _xlmac_clear_fifo_status;
} XLMAC_CLEAR_FIFO_STATUSr_t;

#define XLMAC_CLEAR_FIFO_STATUSr_CLR(r) sal_memset(&((r)._xlmac_clear_fifo_status), 0, sizeof(XLMAC_CLEAR_FIFO_STATUSr_t))
#define XLMAC_CLEAR_FIFO_STATUSr_SET(r,i,d) (r).xlmac_clear_fifo_status[i] = d
#define XLMAC_CLEAR_FIFO_STATUSr_GET(r,i) (r).xlmac_clear_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_CLEAR_FIFO_STATUSr_RSVD_1f_GET(r) (((r).xlmac_clear_fifo_status[0]) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_RSVD_1f_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_MSG_OVERFLOWf_GET(r) ((((r).xlmac_clear_fifo_status[0]) >> 1) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_MSG_OVERFLOWf_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_UNDERFLOWf_GET(r) ((((r).xlmac_clear_fifo_status[0]) >> 2) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_UNDERFLOWf_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_OVERFLOWf_GET(r) ((((r).xlmac_clear_fifo_status[0]) >> 3) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_PKT_OVERFLOWf_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_CLEAR_FIFO_STATUSr_RSVD_2f_GET(r) ((((r).xlmac_clear_fifo_status[0]) >> 4) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_RSVD_2f_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_LLFC_MSG_OVERFLOWf_GET(r) ((((r).xlmac_clear_fifo_status[0]) >> 5) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_LLFC_MSG_OVERFLOWf_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_TS_FIFO_OVERFLOWf_GET(r) ((((r).xlmac_clear_fifo_status[0]) >> 6) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_TX_TS_FIFO_OVERFLOWf_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_PKT_OVERFLOWf_GET(r) ((((r).xlmac_clear_fifo_status[0]) >> 7) & 0x1)
#define XLMAC_CLEAR_FIFO_STATUSr_CLEAR_RX_PKT_OVERFLOWf_SET(r,f) (r).xlmac_clear_fifo_status[0]=(((r).xlmac_clear_fifo_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access XLMAC_CLEAR_FIFO_STATUS.
 */
#define READ_XLMAC_CLEAR_FIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_CLEAR_FIFO_STATUSr_OFFSET,0,XLMAC_CLEAR_FIFO_STATUSr_SIZE,(r._xlmac_clear_fifo_status))
#define WRITE_XLMAC_CLEAR_FIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_CLEAR_FIFO_STATUSr_OFFSET,0,XLMAC_CLEAR_FIFO_STATUSr_SIZE,&(r._xlmac_clear_fifo_status))

/*******************************************************************************
 * End of 'XLMAC_CLEAR_FIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_CLEAR_RX_LSS_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_CLEAR_RX_LSS_STATUSr_OFFSET 0x10060c00

#define XLMAC_CLEAR_RX_LSS_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_CLEAR_RX_LSS_STATUS.
 */
typedef union XLMAC_CLEAR_RX_LSS_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_clear_rx_lss_status[2];
	uint32_t _xlmac_clear_rx_lss_status;
} XLMAC_CLEAR_RX_LSS_STATUSr_t;

#define XLMAC_CLEAR_RX_LSS_STATUSr_CLR(r) sal_memset(&((r)._xlmac_clear_rx_lss_status), 0, sizeof(XLMAC_CLEAR_RX_LSS_STATUSr_t))
#define XLMAC_CLEAR_RX_LSS_STATUSr_SET(r,i,d) (r).xlmac_clear_rx_lss_status[i] = d
#define XLMAC_CLEAR_RX_LSS_STATUSr_GET(r,i) (r).xlmac_clear_rx_lss_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LOCAL_FAULT_STATUSf_GET(r) (((r).xlmac_clear_rx_lss_status[0]) & 0x1)
#define XLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LOCAL_FAULT_STATUSf_SET(r,f) (r).xlmac_clear_rx_lss_status[0]=(((r).xlmac_clear_rx_lss_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_REMOTE_FAULT_STATUSf_GET(r) ((((r).xlmac_clear_rx_lss_status[0]) >> 1) & 0x1)
#define XLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_REMOTE_FAULT_STATUSf_SET(r,f) (r).xlmac_clear_rx_lss_status[0]=(((r).xlmac_clear_rx_lss_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).xlmac_clear_rx_lss_status[0]) >> 2) & 0x1)
#define XLMAC_CLEAR_RX_LSS_STATUSr_CLEAR_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).xlmac_clear_rx_lss_status[0]=(((r).xlmac_clear_rx_lss_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access XLMAC_CLEAR_RX_LSS_STATUS.
 */
#define READ_XLMAC_CLEAR_RX_LSS_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_CLEAR_RX_LSS_STATUSr_OFFSET,0,XLMAC_CLEAR_RX_LSS_STATUSr_SIZE,(r._xlmac_clear_rx_lss_status))
#define WRITE_XLMAC_CLEAR_RX_LSS_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_CLEAR_RX_LSS_STATUSr_OFFSET,0,XLMAC_CLEAR_RX_LSS_STATUSr_SIZE,&(r._xlmac_clear_rx_lss_status))

/*******************************************************************************
 * End of 'XLMAC_CLEAR_RX_LSS_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_CTRLr_OFFSET 0x10060000

#define XLMAC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_CTRL.
 */
typedef union XLMAC_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_ctrl[2];
	uint32_t _xlmac_ctrl;
} XLMAC_CTRLr_t;

#define XLMAC_CTRLr_CLR(r) sal_memset(&((r)._xlmac_ctrl), 0, sizeof(XLMAC_CTRLr_t))
#define XLMAC_CTRLr_SET(r,i,d) (r).xlmac_ctrl[i] = d
#define XLMAC_CTRLr_GET(r,i) (r).xlmac_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_CTRLr_TX_ENf_GET(r) (((r).xlmac_ctrl[0]) & 0x1)
#define XLMAC_CTRLr_TX_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_CTRLr_RX_ENf_GET(r) ((((r).xlmac_ctrl[0]) >> 1) & 0x1)
#define XLMAC_CTRLr_RX_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_CTRLr_LOCAL_LPBKf_GET(r) ((((r).xlmac_ctrl[0]) >> 2) & 0x1)
#define XLMAC_CTRLr_LOCAL_LPBKf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_CTRLr_RSVD_1f_GET(r) ((((r).xlmac_ctrl[0]) >> 3) & 0x1)
#define XLMAC_CTRLr_RSVD_1f_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_GET(r) ((((r).xlmac_ctrl[0]) >> 4) & 0x1)
#define XLMAC_CTRLr_REMOVE_FAILOVER_LPBKf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLMAC_CTRLr_LAG_FAILOVER_ENf_GET(r) ((((r).xlmac_ctrl[0]) >> 5) & 0x1)
#define XLMAC_CTRLr_LAG_FAILOVER_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define XLMAC_CTRLr_SOFT_RESETf_GET(r) ((((r).xlmac_ctrl[0]) >> 6) & 0x1)
#define XLMAC_CTRLr_SOFT_RESETf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define XLMAC_CTRLr_RSVD_4f_GET(r) ((((r).xlmac_ctrl[0]) >> 7) & 0x1)
#define XLMAC_CTRLr_RSVD_4f_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define XLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_GET(r) ((((r).xlmac_ctrl[0]) >> 8) & 0x1)
#define XLMAC_CTRLr_LOCAL_LPBK_LEAK_ENBf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define XLMAC_CTRLr_RSVD_5f_GET(r) ((((r).xlmac_ctrl[0]) >> 9) & 0x1)
#define XLMAC_CTRLr_RSVD_5f_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define XLMAC_CTRLr_RS_SOFT_RESETf_GET(r) ((((r).xlmac_ctrl[0]) >> 10) & 0x1)
#define XLMAC_CTRLr_RS_SOFT_RESETf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define XLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_GET(r) ((((r).xlmac_ctrl[0]) >> 11) & 0x1)
#define XLMAC_CTRLr_XGMII_IPG_CHECK_DISABLEf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define XLMAC_CTRLr_SW_LINK_STATUSf_GET(r) ((((r).xlmac_ctrl[0]) >> 12) & 0x1)
#define XLMAC_CTRLr_SW_LINK_STATUSf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define XLMAC_CTRLr_LINK_STATUS_SELECTf_GET(r) ((((r).xlmac_ctrl[0]) >> 13) & 0x1)
#define XLMAC_CTRLr_LINK_STATUS_SELECTf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define XLMAC_CTRLr_EXTENDED_HIG2_ENf_GET(r) ((((r).xlmac_ctrl[0]) >> 14) & 0x1)
#define XLMAC_CTRLr_EXTENDED_HIG2_ENf_SET(r,f) (r).xlmac_ctrl[0]=(((r).xlmac_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access XLMAC_CTRL.
 */
#define READ_XLMAC_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_CTRLr_OFFSET,0,XLMAC_CTRLr_SIZE,(r._xlmac_ctrl))
#define WRITE_XLMAC_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_CTRLr_OFFSET,0,XLMAC_CTRLr_SIZE,&(r._xlmac_ctrl))

/*******************************************************************************
 * End of 'XLMAC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2ECC_DATA_HDR_0
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2ECC_DATA_HDR_0r_OFFSET 0x10062500

#define XLMAC_E2ECC_DATA_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2ECC_DATA_HDR_0.
 */
typedef union XLMAC_E2ECC_DATA_HDR_0r_s {
	uint32_t v[2];
	uint32_t xlmac_e2ecc_data_hdr_0[2];
	uint32_t _xlmac_e2ecc_data_hdr_0;
} XLMAC_E2ECC_DATA_HDR_0r_t;

#define XLMAC_E2ECC_DATA_HDR_0r_CLR(r) sal_memset(&((r)._xlmac_e2ecc_data_hdr_0), 0, sizeof(XLMAC_E2ECC_DATA_HDR_0r_t))
#define XLMAC_E2ECC_DATA_HDR_0r_SET(r,i,d) (r).xlmac_e2ecc_data_hdr_0[i] = d
#define XLMAC_E2ECC_DATA_HDR_0r_GET(r,i) (r).xlmac_e2ecc_data_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0f_GET(r,a) bcmpmac_field_get((r).xlmac_e2ecc_data_hdr_0,0,63,a)
#define XLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0f_SET(r,a) bcmpmac_field_set((r).xlmac_e2ecc_data_hdr_0,0,63,a)
#define XLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_LOf_GET(r) ((r).xlmac_e2ecc_data_hdr_0[0])
#define XLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_LOf_SET(r,f) (r).xlmac_e2ecc_data_hdr_0[0]=((uint32_t)f)
#define XLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_HIf_GET(r) ((r).xlmac_e2ecc_data_hdr_0[1])
#define XLMAC_E2ECC_DATA_HDR_0r_E2ECC_DATA_HDR_0_HIf_SET(r,f) (r).xlmac_e2ecc_data_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2ECC_DATA_HDR_0.
 */
#define READ_XLMAC_E2ECC_DATA_HDR_0r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2ECC_DATA_HDR_0r_OFFSET,0,XLMAC_E2ECC_DATA_HDR_0r_SIZE,(r._xlmac_e2ecc_data_hdr_0))
#define WRITE_XLMAC_E2ECC_DATA_HDR_0r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2ECC_DATA_HDR_0r_OFFSET,0,XLMAC_E2ECC_DATA_HDR_0r_SIZE,&(r._xlmac_e2ecc_data_hdr_0))

/*******************************************************************************
 * End of 'XLMAC_E2ECC_DATA_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2ECC_DATA_HDR_1
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2ECC_DATA_HDR_1r_OFFSET 0x10062600

#define XLMAC_E2ECC_DATA_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2ECC_DATA_HDR_1.
 */
typedef union XLMAC_E2ECC_DATA_HDR_1r_s {
	uint32_t v[2];
	uint32_t xlmac_e2ecc_data_hdr_1[2];
	uint32_t _xlmac_e2ecc_data_hdr_1;
} XLMAC_E2ECC_DATA_HDR_1r_t;

#define XLMAC_E2ECC_DATA_HDR_1r_CLR(r) sal_memset(&((r)._xlmac_e2ecc_data_hdr_1), 0, sizeof(XLMAC_E2ECC_DATA_HDR_1r_t))
#define XLMAC_E2ECC_DATA_HDR_1r_SET(r,i,d) (r).xlmac_e2ecc_data_hdr_1[i] = d
#define XLMAC_E2ECC_DATA_HDR_1r_GET(r,i) (r).xlmac_e2ecc_data_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1f_GET(r,a) bcmpmac_field_get((r).xlmac_e2ecc_data_hdr_1,0,63,a)
#define XLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1f_SET(r,a) bcmpmac_field_set((r).xlmac_e2ecc_data_hdr_1,0,63,a)
#define XLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_LOf_GET(r) ((r).xlmac_e2ecc_data_hdr_1[0])
#define XLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_LOf_SET(r,f) (r).xlmac_e2ecc_data_hdr_1[0]=((uint32_t)f)
#define XLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_HIf_GET(r) ((r).xlmac_e2ecc_data_hdr_1[1])
#define XLMAC_E2ECC_DATA_HDR_1r_E2ECC_DATA_HDR_1_HIf_SET(r,f) (r).xlmac_e2ecc_data_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2ECC_DATA_HDR_1.
 */
#define READ_XLMAC_E2ECC_DATA_HDR_1r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2ECC_DATA_HDR_1r_OFFSET,0,XLMAC_E2ECC_DATA_HDR_1r_SIZE,(r._xlmac_e2ecc_data_hdr_1))
#define WRITE_XLMAC_E2ECC_DATA_HDR_1r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2ECC_DATA_HDR_1r_OFFSET,0,XLMAC_E2ECC_DATA_HDR_1r_SIZE,&(r._xlmac_e2ecc_data_hdr_1))

/*******************************************************************************
 * End of 'XLMAC_E2ECC_DATA_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2ECC_MODULE_HDR_0
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2ECC_MODULE_HDR_0r_OFFSET 0x10062300

#define XLMAC_E2ECC_MODULE_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2ECC_MODULE_HDR_0.
 */
typedef union XLMAC_E2ECC_MODULE_HDR_0r_s {
	uint32_t v[2];
	uint32_t xlmac_e2ecc_module_hdr_0[2];
	uint32_t _xlmac_e2ecc_module_hdr_0;
} XLMAC_E2ECC_MODULE_HDR_0r_t;

#define XLMAC_E2ECC_MODULE_HDR_0r_CLR(r) sal_memset(&((r)._xlmac_e2ecc_module_hdr_0), 0, sizeof(XLMAC_E2ECC_MODULE_HDR_0r_t))
#define XLMAC_E2ECC_MODULE_HDR_0r_SET(r,i,d) (r).xlmac_e2ecc_module_hdr_0[i] = d
#define XLMAC_E2ECC_MODULE_HDR_0r_GET(r,i) (r).xlmac_e2ecc_module_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0f_GET(r,a) bcmpmac_field_get((r).xlmac_e2ecc_module_hdr_0,0,63,a)
#define XLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0f_SET(r,a) bcmpmac_field_set((r).xlmac_e2ecc_module_hdr_0,0,63,a)
#define XLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_LOf_GET(r) ((r).xlmac_e2ecc_module_hdr_0[0])
#define XLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_LOf_SET(r,f) (r).xlmac_e2ecc_module_hdr_0[0]=((uint32_t)f)
#define XLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_HIf_GET(r) ((r).xlmac_e2ecc_module_hdr_0[1])
#define XLMAC_E2ECC_MODULE_HDR_0r_E2ECC_MODULE_HDR_0_HIf_SET(r,f) (r).xlmac_e2ecc_module_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2ECC_MODULE_HDR_0.
 */
#define READ_XLMAC_E2ECC_MODULE_HDR_0r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2ECC_MODULE_HDR_0r_OFFSET,0,XLMAC_E2ECC_MODULE_HDR_0r_SIZE,(r._xlmac_e2ecc_module_hdr_0))
#define WRITE_XLMAC_E2ECC_MODULE_HDR_0r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2ECC_MODULE_HDR_0r_OFFSET,0,XLMAC_E2ECC_MODULE_HDR_0r_SIZE,&(r._xlmac_e2ecc_module_hdr_0))

/*******************************************************************************
 * End of 'XLMAC_E2ECC_MODULE_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2ECC_MODULE_HDR_1
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2ECC_MODULE_HDR_1r_OFFSET 0x10062400

#define XLMAC_E2ECC_MODULE_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2ECC_MODULE_HDR_1.
 */
typedef union XLMAC_E2ECC_MODULE_HDR_1r_s {
	uint32_t v[2];
	uint32_t xlmac_e2ecc_module_hdr_1[2];
	uint32_t _xlmac_e2ecc_module_hdr_1;
} XLMAC_E2ECC_MODULE_HDR_1r_t;

#define XLMAC_E2ECC_MODULE_HDR_1r_CLR(r) sal_memset(&((r)._xlmac_e2ecc_module_hdr_1), 0, sizeof(XLMAC_E2ECC_MODULE_HDR_1r_t))
#define XLMAC_E2ECC_MODULE_HDR_1r_SET(r,i,d) (r).xlmac_e2ecc_module_hdr_1[i] = d
#define XLMAC_E2ECC_MODULE_HDR_1r_GET(r,i) (r).xlmac_e2ecc_module_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1f_GET(r,a) bcmpmac_field_get((r).xlmac_e2ecc_module_hdr_1,0,63,a)
#define XLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1f_SET(r,a) bcmpmac_field_set((r).xlmac_e2ecc_module_hdr_1,0,63,a)
#define XLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_LOf_GET(r) ((r).xlmac_e2ecc_module_hdr_1[0])
#define XLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_LOf_SET(r,f) (r).xlmac_e2ecc_module_hdr_1[0]=((uint32_t)f)
#define XLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_HIf_GET(r) ((r).xlmac_e2ecc_module_hdr_1[1])
#define XLMAC_E2ECC_MODULE_HDR_1r_E2ECC_MODULE_HDR_1_HIf_SET(r,f) (r).xlmac_e2ecc_module_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2ECC_MODULE_HDR_1.
 */
#define READ_XLMAC_E2ECC_MODULE_HDR_1r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2ECC_MODULE_HDR_1r_OFFSET,0,XLMAC_E2ECC_MODULE_HDR_1r_SIZE,(r._xlmac_e2ecc_module_hdr_1))
#define WRITE_XLMAC_E2ECC_MODULE_HDR_1r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2ECC_MODULE_HDR_1r_OFFSET,0,XLMAC_E2ECC_MODULE_HDR_1r_SIZE,&(r._xlmac_e2ecc_module_hdr_1))

/*******************************************************************************
 * End of 'XLMAC_E2ECC_MODULE_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2EFC_DATA_HDR_0
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2EFC_DATA_HDR_0r_OFFSET 0x10062900

#define XLMAC_E2EFC_DATA_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2EFC_DATA_HDR_0.
 */
typedef union XLMAC_E2EFC_DATA_HDR_0r_s {
	uint32_t v[2];
	uint32_t xlmac_e2efc_data_hdr_0[2];
	uint32_t _xlmac_e2efc_data_hdr_0;
} XLMAC_E2EFC_DATA_HDR_0r_t;

#define XLMAC_E2EFC_DATA_HDR_0r_CLR(r) sal_memset(&((r)._xlmac_e2efc_data_hdr_0), 0, sizeof(XLMAC_E2EFC_DATA_HDR_0r_t))
#define XLMAC_E2EFC_DATA_HDR_0r_SET(r,i,d) (r).xlmac_e2efc_data_hdr_0[i] = d
#define XLMAC_E2EFC_DATA_HDR_0r_GET(r,i) (r).xlmac_e2efc_data_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0f_GET(r,a) bcmpmac_field_get((r).xlmac_e2efc_data_hdr_0,0,63,a)
#define XLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0f_SET(r,a) bcmpmac_field_set((r).xlmac_e2efc_data_hdr_0,0,63,a)
#define XLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_LOf_GET(r) ((r).xlmac_e2efc_data_hdr_0[0])
#define XLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_LOf_SET(r,f) (r).xlmac_e2efc_data_hdr_0[0]=((uint32_t)f)
#define XLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_HIf_GET(r) ((r).xlmac_e2efc_data_hdr_0[1])
#define XLMAC_E2EFC_DATA_HDR_0r_E2EFC_DATA_HDR_0_HIf_SET(r,f) (r).xlmac_e2efc_data_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2EFC_DATA_HDR_0.
 */
#define READ_XLMAC_E2EFC_DATA_HDR_0r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2EFC_DATA_HDR_0r_OFFSET,0,XLMAC_E2EFC_DATA_HDR_0r_SIZE,(r._xlmac_e2efc_data_hdr_0))
#define WRITE_XLMAC_E2EFC_DATA_HDR_0r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2EFC_DATA_HDR_0r_OFFSET,0,XLMAC_E2EFC_DATA_HDR_0r_SIZE,&(r._xlmac_e2efc_data_hdr_0))

/*******************************************************************************
 * End of 'XLMAC_E2EFC_DATA_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2EFC_DATA_HDR_1
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2EFC_DATA_HDR_1r_OFFSET 0x10062a00

#define XLMAC_E2EFC_DATA_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2EFC_DATA_HDR_1.
 */
typedef union XLMAC_E2EFC_DATA_HDR_1r_s {
	uint32_t v[2];
	uint32_t xlmac_e2efc_data_hdr_1[2];
	uint32_t _xlmac_e2efc_data_hdr_1;
} XLMAC_E2EFC_DATA_HDR_1r_t;

#define XLMAC_E2EFC_DATA_HDR_1r_CLR(r) sal_memset(&((r)._xlmac_e2efc_data_hdr_1), 0, sizeof(XLMAC_E2EFC_DATA_HDR_1r_t))
#define XLMAC_E2EFC_DATA_HDR_1r_SET(r,i,d) (r).xlmac_e2efc_data_hdr_1[i] = d
#define XLMAC_E2EFC_DATA_HDR_1r_GET(r,i) (r).xlmac_e2efc_data_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1f_GET(r,a) bcmpmac_field_get((r).xlmac_e2efc_data_hdr_1,0,63,a)
#define XLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1f_SET(r,a) bcmpmac_field_set((r).xlmac_e2efc_data_hdr_1,0,63,a)
#define XLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_LOf_GET(r) ((r).xlmac_e2efc_data_hdr_1[0])
#define XLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_LOf_SET(r,f) (r).xlmac_e2efc_data_hdr_1[0]=((uint32_t)f)
#define XLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_HIf_GET(r) ((r).xlmac_e2efc_data_hdr_1[1])
#define XLMAC_E2EFC_DATA_HDR_1r_E2EFC_DATA_HDR_1_HIf_SET(r,f) (r).xlmac_e2efc_data_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2EFC_DATA_HDR_1.
 */
#define READ_XLMAC_E2EFC_DATA_HDR_1r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2EFC_DATA_HDR_1r_OFFSET,0,XLMAC_E2EFC_DATA_HDR_1r_SIZE,(r._xlmac_e2efc_data_hdr_1))
#define WRITE_XLMAC_E2EFC_DATA_HDR_1r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2EFC_DATA_HDR_1r_OFFSET,0,XLMAC_E2EFC_DATA_HDR_1r_SIZE,&(r._xlmac_e2efc_data_hdr_1))

/*******************************************************************************
 * End of 'XLMAC_E2EFC_DATA_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2EFC_MODULE_HDR_0
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2EFC_MODULE_HDR_0r_OFFSET 0x10062700

#define XLMAC_E2EFC_MODULE_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2EFC_MODULE_HDR_0.
 */
typedef union XLMAC_E2EFC_MODULE_HDR_0r_s {
	uint32_t v[2];
	uint32_t xlmac_e2efc_module_hdr_0[2];
	uint32_t _xlmac_e2efc_module_hdr_0;
} XLMAC_E2EFC_MODULE_HDR_0r_t;

#define XLMAC_E2EFC_MODULE_HDR_0r_CLR(r) sal_memset(&((r)._xlmac_e2efc_module_hdr_0), 0, sizeof(XLMAC_E2EFC_MODULE_HDR_0r_t))
#define XLMAC_E2EFC_MODULE_HDR_0r_SET(r,i,d) (r).xlmac_e2efc_module_hdr_0[i] = d
#define XLMAC_E2EFC_MODULE_HDR_0r_GET(r,i) (r).xlmac_e2efc_module_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0f_GET(r,a) bcmpmac_field_get((r).xlmac_e2efc_module_hdr_0,0,63,a)
#define XLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0f_SET(r,a) bcmpmac_field_set((r).xlmac_e2efc_module_hdr_0,0,63,a)
#define XLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_LOf_GET(r) ((r).xlmac_e2efc_module_hdr_0[0])
#define XLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_LOf_SET(r,f) (r).xlmac_e2efc_module_hdr_0[0]=((uint32_t)f)
#define XLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_HIf_GET(r) ((r).xlmac_e2efc_module_hdr_0[1])
#define XLMAC_E2EFC_MODULE_HDR_0r_E2EFC_MODULE_HDR_0_HIf_SET(r,f) (r).xlmac_e2efc_module_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2EFC_MODULE_HDR_0.
 */
#define READ_XLMAC_E2EFC_MODULE_HDR_0r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2EFC_MODULE_HDR_0r_OFFSET,0,XLMAC_E2EFC_MODULE_HDR_0r_SIZE,(r._xlmac_e2efc_module_hdr_0))
#define WRITE_XLMAC_E2EFC_MODULE_HDR_0r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2EFC_MODULE_HDR_0r_OFFSET,0,XLMAC_E2EFC_MODULE_HDR_0r_SIZE,&(r._xlmac_e2efc_module_hdr_0))

/*******************************************************************************
 * End of 'XLMAC_E2EFC_MODULE_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2EFC_MODULE_HDR_1
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2EFC_MODULE_HDR_1r_OFFSET 0x10062800

#define XLMAC_E2EFC_MODULE_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2EFC_MODULE_HDR_1.
 */
typedef union XLMAC_E2EFC_MODULE_HDR_1r_s {
	uint32_t v[2];
	uint32_t xlmac_e2efc_module_hdr_1[2];
	uint32_t _xlmac_e2efc_module_hdr_1;
} XLMAC_E2EFC_MODULE_HDR_1r_t;

#define XLMAC_E2EFC_MODULE_HDR_1r_CLR(r) sal_memset(&((r)._xlmac_e2efc_module_hdr_1), 0, sizeof(XLMAC_E2EFC_MODULE_HDR_1r_t))
#define XLMAC_E2EFC_MODULE_HDR_1r_SET(r,i,d) (r).xlmac_e2efc_module_hdr_1[i] = d
#define XLMAC_E2EFC_MODULE_HDR_1r_GET(r,i) (r).xlmac_e2efc_module_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1f_GET(r,a) bcmpmac_field_get((r).xlmac_e2efc_module_hdr_1,0,63,a)
#define XLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1f_SET(r,a) bcmpmac_field_set((r).xlmac_e2efc_module_hdr_1,0,63,a)
#define XLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_LOf_GET(r) ((r).xlmac_e2efc_module_hdr_1[0])
#define XLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_LOf_SET(r,f) (r).xlmac_e2efc_module_hdr_1[0]=((uint32_t)f)
#define XLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_HIf_GET(r) ((r).xlmac_e2efc_module_hdr_1[1])
#define XLMAC_E2EFC_MODULE_HDR_1r_E2EFC_MODULE_HDR_1_HIf_SET(r,f) (r).xlmac_e2efc_module_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_E2EFC_MODULE_HDR_1.
 */
#define READ_XLMAC_E2EFC_MODULE_HDR_1r(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2EFC_MODULE_HDR_1r_OFFSET,0,XLMAC_E2EFC_MODULE_HDR_1r_SIZE,(r._xlmac_e2efc_module_hdr_1))
#define WRITE_XLMAC_E2EFC_MODULE_HDR_1r(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2EFC_MODULE_HDR_1r_OFFSET,0,XLMAC_E2EFC_MODULE_HDR_1r_SIZE,&(r._xlmac_e2efc_module_hdr_1))

/*******************************************************************************
 * End of 'XLMAC_E2EFC_MODULE_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_E2E_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_E2E_CTRLr_OFFSET 0x10062200

#define XLMAC_E2E_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_E2E_CTRL.
 */
typedef union XLMAC_E2E_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_e2e_ctrl[2];
	uint32_t _xlmac_e2e_ctrl;
} XLMAC_E2E_CTRLr_t;

#define XLMAC_E2E_CTRLr_CLR(r) sal_memset(&((r)._xlmac_e2e_ctrl), 0, sizeof(XLMAC_E2E_CTRLr_t))
#define XLMAC_E2E_CTRLr_SET(r,i,d) (r).xlmac_e2e_ctrl[i] = d
#define XLMAC_E2E_CTRLr_GET(r,i) (r).xlmac_e2e_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_E2E_CTRLr_E2E_ENABLEf_GET(r) (((r).xlmac_e2e_ctrl[0]) & 0x1)
#define XLMAC_E2E_CTRLr_E2E_ENABLEf_SET(r,f) (r).xlmac_e2e_ctrl[0]=(((r).xlmac_e2e_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_E2E_CTRLr_HONOR_PAUSE_FOR_E2Ef_GET(r) ((((r).xlmac_e2e_ctrl[0]) >> 1) & 0x1)
#define XLMAC_E2E_CTRLr_HONOR_PAUSE_FOR_E2Ef_SET(r,f) (r).xlmac_e2e_ctrl[0]=(((r).xlmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_E2E_CTRLr_E2ECC_DUAL_MODID_ENf_GET(r) ((((r).xlmac_e2e_ctrl[0]) >> 2) & 0x1)
#define XLMAC_E2E_CTRLr_E2ECC_DUAL_MODID_ENf_SET(r,f) (r).xlmac_e2e_ctrl[0]=(((r).xlmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_E2E_CTRLr_E2ECC_LEGACY_IMP_ENf_GET(r) ((((r).xlmac_e2e_ctrl[0]) >> 3) & 0x1)
#define XLMAC_E2E_CTRLr_E2ECC_LEGACY_IMP_ENf_SET(r,f) (r).xlmac_e2e_ctrl[0]=(((r).xlmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_E2E_CTRLr_E2EFC_DUAL_MODID_ENf_GET(r) ((((r).xlmac_e2e_ctrl[0]) >> 4) & 0x1)
#define XLMAC_E2E_CTRLr_E2EFC_DUAL_MODID_ENf_SET(r,f) (r).xlmac_e2e_ctrl[0]=(((r).xlmac_e2e_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access XLMAC_E2E_CTRL.
 */
#define READ_XLMAC_E2E_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_E2E_CTRLr_OFFSET,0,XLMAC_E2E_CTRLr_SIZE,(r._xlmac_e2e_ctrl))
#define WRITE_XLMAC_E2E_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_E2E_CTRLr_OFFSET,0,XLMAC_E2E_CTRLr_SIZE,&(r._xlmac_e2e_ctrl))

/*******************************************************************************
 * End of 'XLMAC_E2E_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_ECC_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_ECC_CTRLr_OFFSET 0x10062e00

#define XLMAC_ECC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_ECC_CTRL.
 */
typedef union XLMAC_ECC_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_ecc_ctrl[2];
	uint32_t _xlmac_ecc_ctrl;
} XLMAC_ECC_CTRLr_t;

#define XLMAC_ECC_CTRLr_CLR(r) sal_memset(&((r)._xlmac_ecc_ctrl), 0, sizeof(XLMAC_ECC_CTRLr_t))
#define XLMAC_ECC_CTRLr_SET(r,i,d) (r).xlmac_ecc_ctrl[i] = d
#define XLMAC_ECC_CTRLr_GET(r,i) (r).xlmac_ecc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_ECC_CTRLr_RX_CDC_ECC_CTRL_ENf_GET(r) (((r).xlmac_ecc_ctrl[0]) & 0x1)
#define XLMAC_ECC_CTRLr_RX_CDC_ECC_CTRL_ENf_SET(r,f) (r).xlmac_ecc_ctrl[0]=(((r).xlmac_ecc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_ECC_CTRLr_TX_CDC_ECC_CTRL_ENf_GET(r) ((((r).xlmac_ecc_ctrl[0]) >> 1) & 0x1)
#define XLMAC_ECC_CTRLr_TX_CDC_ECC_CTRL_ENf_SET(r,f) (r).xlmac_ecc_ctrl[0]=(((r).xlmac_ecc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_ECC_CTRL.
 */
#define READ_XLMAC_ECC_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_ECC_CTRLr_OFFSET,0,XLMAC_ECC_CTRLr_SIZE,(r._xlmac_ecc_ctrl))
#define WRITE_XLMAC_ECC_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_ECC_CTRLr_OFFSET,0,XLMAC_ECC_CTRLr_SIZE,&(r._xlmac_ecc_ctrl))

/*******************************************************************************
 * End of 'XLMAC_ECC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_ECC_FORCE_DOUBLE_BIT_ERR
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_OFFSET 0x10062f00

#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_ECC_FORCE_DOUBLE_BIT_ERR.
 */
typedef union XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_s {
	uint32_t v[2];
	uint32_t xlmac_ecc_force_double_bit_err[2];
	uint32_t _xlmac_ecc_force_double_bit_err;
} XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_t;

#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_CLR(r) sal_memset(&((r)._xlmac_ecc_force_double_bit_err), 0, sizeof(XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_t))
#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SET(r,i,d) (r).xlmac_ecc_force_double_bit_err[i] = d
#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_GET(r,i) (r).xlmac_ecc_force_double_bit_err[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_RX_CDC_FORCE_DOUBLE_BIT_ERRf_GET(r) (((r).xlmac_ecc_force_double_bit_err[0]) & 0x1)
#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_RX_CDC_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).xlmac_ecc_force_double_bit_err[0]=(((r).xlmac_ecc_force_double_bit_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_TX_CDC_FORCE_DOUBLE_BIT_ERRf_GET(r) ((((r).xlmac_ecc_force_double_bit_err[0]) >> 1) & 0x1)
#define XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_TX_CDC_FORCE_DOUBLE_BIT_ERRf_SET(r,f) (r).xlmac_ecc_force_double_bit_err[0]=(((r).xlmac_ecc_force_double_bit_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_ECC_FORCE_DOUBLE_BIT_ERR.
 */
#define READ_XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr(pa,p,r) bcmpmac_read(pa,p,XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_OFFSET,0,XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SIZE,(r._xlmac_ecc_force_double_bit_err))
#define WRITE_XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr(pa,p,r) bcmpmac_write(pa,p,XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_OFFSET,0,XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr_SIZE,&(r._xlmac_ecc_force_double_bit_err))

/*******************************************************************************
 * End of 'XLMAC_ECC_FORCE_DOUBLE_BIT_ERRr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_ECC_FORCE_SINGLE_BIT_ERR
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_OFFSET 0x10063000

#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_ECC_FORCE_SINGLE_BIT_ERR.
 */
typedef union XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_s {
	uint32_t v[2];
	uint32_t xlmac_ecc_force_single_bit_err[2];
	uint32_t _xlmac_ecc_force_single_bit_err;
} XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_t;

#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_CLR(r) sal_memset(&((r)._xlmac_ecc_force_single_bit_err), 0, sizeof(XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_t))
#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SET(r,i,d) (r).xlmac_ecc_force_single_bit_err[i] = d
#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_GET(r,i) (r).xlmac_ecc_force_single_bit_err[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_RX_CDC_FORCE_SINGLE_BIT_ERRf_GET(r) (((r).xlmac_ecc_force_single_bit_err[0]) & 0x1)
#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_RX_CDC_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).xlmac_ecc_force_single_bit_err[0]=(((r).xlmac_ecc_force_single_bit_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_TX_CDC_FORCE_SINGLE_BIT_ERRf_GET(r) ((((r).xlmac_ecc_force_single_bit_err[0]) >> 1) & 0x1)
#define XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_TX_CDC_FORCE_SINGLE_BIT_ERRf_SET(r,f) (r).xlmac_ecc_force_single_bit_err[0]=(((r).xlmac_ecc_force_single_bit_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_ECC_FORCE_SINGLE_BIT_ERR.
 */
#define READ_XLMAC_ECC_FORCE_SINGLE_BIT_ERRr(pa,p,r) bcmpmac_read(pa,p,XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_OFFSET,0,XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SIZE,(r._xlmac_ecc_force_single_bit_err))
#define WRITE_XLMAC_ECC_FORCE_SINGLE_BIT_ERRr(pa,p,r) bcmpmac_write(pa,p,XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_OFFSET,0,XLMAC_ECC_FORCE_SINGLE_BIT_ERRr_SIZE,&(r._xlmac_ecc_force_single_bit_err))

/*******************************************************************************
 * End of 'XLMAC_ECC_FORCE_SINGLE_BIT_ERRr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_EEE_1_SEC_LINK_STATUS_TIMER
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_OFFSET 0x10061c00

#define XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_EEE_1_SEC_LINK_STATUS_TIMER.
 */
typedef union XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_s {
	uint32_t v[2];
	uint32_t xlmac_eee_1_sec_link_status_timer[2];
	uint32_t _xlmac_eee_1_sec_link_status_timer;
} XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_t;

#define XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_CLR(r) sal_memset(&((r)._xlmac_eee_1_sec_link_status_timer), 0, sizeof(XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_t))
#define XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SET(r,i,d) (r).xlmac_eee_1_sec_link_status_timer[i] = d
#define XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_GET(r,i) (r).xlmac_eee_1_sec_link_status_timer[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_ONE_SECOND_TIMERf_GET(r) (((r).xlmac_eee_1_sec_link_status_timer[0]) & 0xffffff)
#define XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_ONE_SECOND_TIMERf_SET(r,f) (r).xlmac_eee_1_sec_link_status_timer[0]=(((r).xlmac_eee_1_sec_link_status_timer[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access XLMAC_EEE_1_SEC_LINK_STATUS_TIMER.
 */
#define READ_XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr(pa,p,r) bcmpmac_read(pa,p,XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_OFFSET,0,XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SIZE,(r._xlmac_eee_1_sec_link_status_timer))
#define WRITE_XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr(pa,p,r) bcmpmac_write(pa,p,XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_OFFSET,0,XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr_SIZE,&(r._xlmac_eee_1_sec_link_status_timer))

/*******************************************************************************
 * End of 'XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_EEE_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_EEE_CTRLr_OFFSET 0x10061a00

#define XLMAC_EEE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_EEE_CTRL.
 */
typedef union XLMAC_EEE_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_eee_ctrl[2];
	uint32_t _xlmac_eee_ctrl;
} XLMAC_EEE_CTRLr_t;

#define XLMAC_EEE_CTRLr_CLR(r) sal_memset(&((r)._xlmac_eee_ctrl), 0, sizeof(XLMAC_EEE_CTRLr_t))
#define XLMAC_EEE_CTRLr_SET(r,i,d) (r).xlmac_eee_ctrl[i] = d
#define XLMAC_EEE_CTRLr_GET(r,i) (r).xlmac_eee_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_EEE_CTRLr_EEE_ENf_GET(r) (((r).xlmac_eee_ctrl[0]) & 0x1)
#define XLMAC_EEE_CTRLr_EEE_ENf_SET(r,f) (r).xlmac_eee_ctrl[0]=(((r).xlmac_eee_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_EEE_CTRLr_RSVDf_GET(r) ((((r).xlmac_eee_ctrl[0]) >> 1) & 0x1)
#define XLMAC_EEE_CTRLr_RSVDf_SET(r,f) (r).xlmac_eee_ctrl[0]=(((r).xlmac_eee_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_EEE_CTRL.
 */
#define READ_XLMAC_EEE_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_EEE_CTRLr_OFFSET,0,XLMAC_EEE_CTRLr_SIZE,(r._xlmac_eee_ctrl))
#define WRITE_XLMAC_EEE_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_EEE_CTRLr_OFFSET,0,XLMAC_EEE_CTRLr_SIZE,&(r._xlmac_eee_ctrl))

/*******************************************************************************
 * End of 'XLMAC_EEE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_EEE_TIMERS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_EEE_TIMERSr_OFFSET 0x10061b00

#define XLMAC_EEE_TIMERSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_EEE_TIMERS.
 */
typedef union XLMAC_EEE_TIMERSr_s {
	uint32_t v[2];
	uint32_t xlmac_eee_timers[2];
	uint32_t _xlmac_eee_timers;
} XLMAC_EEE_TIMERSr_t;

#define XLMAC_EEE_TIMERSr_CLR(r) sal_memset(&((r)._xlmac_eee_timers), 0, sizeof(XLMAC_EEE_TIMERSr_t))
#define XLMAC_EEE_TIMERSr_SET(r,i,d) (r).xlmac_eee_timers[i] = d
#define XLMAC_EEE_TIMERSr_GET(r,i) (r).xlmac_eee_timers[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_GET(r) ((r).xlmac_eee_timers[0])
#define XLMAC_EEE_TIMERSr_EEE_DELAY_ENTRY_TIMERf_SET(r,f) (r).xlmac_eee_timers[0]=((uint32_t)f)
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_LOf_GET(r) ((r).xlmac_eee_timers[0])
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_LOf_SET(r,f) (r).xlmac_eee_timers[0]=((uint32_t)f)
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_HIf_GET(r) ((r).xlmac_eee_timers[1])
#define XLMAC_EEE_TIMERSr_XLMAC_EEE_TIMERS_HIf_SET(r,f) (r).xlmac_eee_timers[1]=((uint32_t)f)
#define XLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_GET(r) (((r).xlmac_eee_timers[1]) & 0xffff)
#define XLMAC_EEE_TIMERSr_EEE_WAKE_TIMERf_SET(r,f) (r).xlmac_eee_timers[1]=(((r).xlmac_eee_timers[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define XLMAC_EEE_TIMERSr_EEE_REF_COUNTf_GET(r) ((((r).xlmac_eee_timers[1]) >> 16) & 0xffff)
#define XLMAC_EEE_TIMERSr_EEE_REF_COUNTf_SET(r,f) (r).xlmac_eee_timers[1]=(((r).xlmac_eee_timers[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access XLMAC_EEE_TIMERS.
 */
#define READ_XLMAC_EEE_TIMERSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_EEE_TIMERSr_OFFSET,0,XLMAC_EEE_TIMERSr_SIZE,(r._xlmac_eee_timers))
#define WRITE_XLMAC_EEE_TIMERSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_EEE_TIMERSr_OFFSET,0,XLMAC_EEE_TIMERSr_SIZE,&(r._xlmac_eee_timers))

/*******************************************************************************
 * End of 'XLMAC_EEE_TIMERSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_FIFO_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_FIFO_STATUSr_OFFSET 0x10061700

#define XLMAC_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_FIFO_STATUS.
 */
typedef union XLMAC_FIFO_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_fifo_status[2];
	uint32_t _xlmac_fifo_status;
} XLMAC_FIFO_STATUSr_t;

#define XLMAC_FIFO_STATUSr_CLR(r) sal_memset(&((r)._xlmac_fifo_status), 0, sizeof(XLMAC_FIFO_STATUSr_t))
#define XLMAC_FIFO_STATUSr_SET(r,i,d) (r).xlmac_fifo_status[i] = d
#define XLMAC_FIFO_STATUSr_GET(r,i) (r).xlmac_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_FIFO_STATUSr_RSVD_1f_GET(r) (((r).xlmac_fifo_status[0]) & 0x1)
#define XLMAC_FIFO_STATUSr_RSVD_1f_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_FIFO_STATUSr_RX_MSG_OVERFLOWf_GET(r) ((((r).xlmac_fifo_status[0]) >> 1) & 0x1)
#define XLMAC_FIFO_STATUSr_RX_MSG_OVERFLOWf_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_FIFO_STATUSr_TX_PKT_UNDERFLOWf_GET(r) ((((r).xlmac_fifo_status[0]) >> 2) & 0x1)
#define XLMAC_FIFO_STATUSr_TX_PKT_UNDERFLOWf_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_FIFO_STATUSr_TX_PKT_OVERFLOWf_GET(r) ((((r).xlmac_fifo_status[0]) >> 3) & 0x1)
#define XLMAC_FIFO_STATUSr_TX_PKT_OVERFLOWf_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_FIFO_STATUSr_RSVD_2f_GET(r) ((((r).xlmac_fifo_status[0]) >> 4) & 0x1)
#define XLMAC_FIFO_STATUSr_RSVD_2f_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLMAC_FIFO_STATUSr_TX_LLFC_MSG_OVERFLOWf_GET(r) ((((r).xlmac_fifo_status[0]) >> 5) & 0x1)
#define XLMAC_FIFO_STATUSr_TX_LLFC_MSG_OVERFLOWf_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define XLMAC_FIFO_STATUSr_TX_TS_FIFO_OVERFLOWf_GET(r) ((((r).xlmac_fifo_status[0]) >> 6) & 0x1)
#define XLMAC_FIFO_STATUSr_TX_TS_FIFO_OVERFLOWf_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define XLMAC_FIFO_STATUSr_RX_PKT_OVERFLOWf_GET(r) ((((r).xlmac_fifo_status[0]) >> 7) & 0x1)
#define XLMAC_FIFO_STATUSr_RX_PKT_OVERFLOWf_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define XLMAC_FIFO_STATUSr_LINK_STATUSf_GET(r) ((((r).xlmac_fifo_status[0]) >> 8) & 0x1)
#define XLMAC_FIFO_STATUSr_LINK_STATUSf_SET(r,f) (r).xlmac_fifo_status[0]=(((r).xlmac_fifo_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access XLMAC_FIFO_STATUS.
 */
#define READ_XLMAC_FIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_FIFO_STATUSr_OFFSET,0,XLMAC_FIFO_STATUSr_SIZE,(r._xlmac_fifo_status))
#define WRITE_XLMAC_FIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_FIFO_STATUSr_OFFSET,0,XLMAC_FIFO_STATUSr_SIZE,&(r._xlmac_fifo_status))

/*******************************************************************************
 * End of 'XLMAC_FIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_GMII_EEE_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_GMII_EEE_CTRLr_OFFSET 0x10061f00

#define XLMAC_GMII_EEE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_GMII_EEE_CTRL.
 */
typedef union XLMAC_GMII_EEE_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_gmii_eee_ctrl[2];
	uint32_t _xlmac_gmii_eee_ctrl;
} XLMAC_GMII_EEE_CTRLr_t;

#define XLMAC_GMII_EEE_CTRLr_CLR(r) sal_memset(&((r)._xlmac_gmii_eee_ctrl), 0, sizeof(XLMAC_GMII_EEE_CTRLr_t))
#define XLMAC_GMII_EEE_CTRLr_SET(r,i,d) (r).xlmac_gmii_eee_ctrl[i] = d
#define XLMAC_GMII_EEE_CTRLr_GET(r,i) (r).xlmac_gmii_eee_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_THRESHOLDf_GET(r) (((r).xlmac_gmii_eee_ctrl[0]) & 0xffff)
#define XLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_THRESHOLDf_SET(r,f) (r).xlmac_gmii_eee_ctrl[0]=(((r).xlmac_gmii_eee_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define XLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_MODE_ENf_GET(r) ((((r).xlmac_gmii_eee_ctrl[0]) >> 16) & 0x1)
#define XLMAC_GMII_EEE_CTRLr_GMII_LPI_PREDICT_MODE_ENf_SET(r,f) (r).xlmac_gmii_eee_ctrl[0]=(((r).xlmac_gmii_eee_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access XLMAC_GMII_EEE_CTRL.
 */
#define READ_XLMAC_GMII_EEE_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_GMII_EEE_CTRLr_OFFSET,0,XLMAC_GMII_EEE_CTRLr_SIZE,(r._xlmac_gmii_eee_ctrl))
#define WRITE_XLMAC_GMII_EEE_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_GMII_EEE_CTRLr_OFFSET,0,XLMAC_GMII_EEE_CTRLr_SIZE,&(r._xlmac_gmii_eee_ctrl))

/*******************************************************************************
 * End of 'XLMAC_GMII_EEE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_HIGIG_HDR_0
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_HIGIG_HDR_0r_OFFSET 0x10061d00

#define XLMAC_HIGIG_HDR_0r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_HIGIG_HDR_0.
 */
typedef union XLMAC_HIGIG_HDR_0r_s {
	uint32_t v[2];
	uint32_t xlmac_higig_hdr_0[2];
	uint32_t _xlmac_higig_hdr_0;
} XLMAC_HIGIG_HDR_0r_t;

#define XLMAC_HIGIG_HDR_0r_CLR(r) sal_memset(&((r)._xlmac_higig_hdr_0), 0, sizeof(XLMAC_HIGIG_HDR_0r_t))
#define XLMAC_HIGIG_HDR_0r_SET(r,i,d) (r).xlmac_higig_hdr_0[i] = d
#define XLMAC_HIGIG_HDR_0r_GET(r,i) (r).xlmac_higig_hdr_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_HIGIG_HDR_0r_HIGIG_HDR_0f_GET(r,a) bcmpmac_field_get((r).xlmac_higig_hdr_0,0,63,a)
#define XLMAC_HIGIG_HDR_0r_HIGIG_HDR_0f_SET(r,a) bcmpmac_field_set((r).xlmac_higig_hdr_0,0,63,a)
#define XLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_LOf_GET(r) ((r).xlmac_higig_hdr_0[0])
#define XLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_LOf_SET(r,f) (r).xlmac_higig_hdr_0[0]=((uint32_t)f)
#define XLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_HIf_GET(r) ((r).xlmac_higig_hdr_0[1])
#define XLMAC_HIGIG_HDR_0r_HIGIG_HDR_0_HIf_SET(r,f) (r).xlmac_higig_hdr_0[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_HIGIG_HDR_0.
 */
#define READ_XLMAC_HIGIG_HDR_0r(pa,p,r) bcmpmac_read(pa,p,XLMAC_HIGIG_HDR_0r_OFFSET,0,XLMAC_HIGIG_HDR_0r_SIZE,(r._xlmac_higig_hdr_0))
#define WRITE_XLMAC_HIGIG_HDR_0r(pa,p,r) bcmpmac_write(pa,p,XLMAC_HIGIG_HDR_0r_OFFSET,0,XLMAC_HIGIG_HDR_0r_SIZE,&(r._xlmac_higig_hdr_0))

/*******************************************************************************
 * End of 'XLMAC_HIGIG_HDR_0r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_HIGIG_HDR_1
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_HIGIG_HDR_1r_OFFSET 0x10061e00

#define XLMAC_HIGIG_HDR_1r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_HIGIG_HDR_1.
 */
typedef union XLMAC_HIGIG_HDR_1r_s {
	uint32_t v[2];
	uint32_t xlmac_higig_hdr_1[2];
	uint32_t _xlmac_higig_hdr_1;
} XLMAC_HIGIG_HDR_1r_t;

#define XLMAC_HIGIG_HDR_1r_CLR(r) sal_memset(&((r)._xlmac_higig_hdr_1), 0, sizeof(XLMAC_HIGIG_HDR_1r_t))
#define XLMAC_HIGIG_HDR_1r_SET(r,i,d) (r).xlmac_higig_hdr_1[i] = d
#define XLMAC_HIGIG_HDR_1r_GET(r,i) (r).xlmac_higig_hdr_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_HIGIG_HDR_1r_HIGIG_HDR_1f_GET(r,a) bcmpmac_field_get((r).xlmac_higig_hdr_1,0,63,a)
#define XLMAC_HIGIG_HDR_1r_HIGIG_HDR_1f_SET(r,a) bcmpmac_field_set((r).xlmac_higig_hdr_1,0,63,a)
#define XLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_LOf_GET(r) ((r).xlmac_higig_hdr_1[0])
#define XLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_LOf_SET(r,f) (r).xlmac_higig_hdr_1[0]=((uint32_t)f)
#define XLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_HIf_GET(r) ((r).xlmac_higig_hdr_1[1])
#define XLMAC_HIGIG_HDR_1r_HIGIG_HDR_1_HIf_SET(r,f) (r).xlmac_higig_hdr_1[1]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_HIGIG_HDR_1.
 */
#define READ_XLMAC_HIGIG_HDR_1r(pa,p,r) bcmpmac_read(pa,p,XLMAC_HIGIG_HDR_1r_OFFSET,0,XLMAC_HIGIG_HDR_1r_SIZE,(r._xlmac_higig_hdr_1))
#define WRITE_XLMAC_HIGIG_HDR_1r(pa,p,r) bcmpmac_write(pa,p,XLMAC_HIGIG_HDR_1r_OFFSET,0,XLMAC_HIGIG_HDR_1r_SIZE,&(r._xlmac_higig_hdr_1))

/*******************************************************************************
 * End of 'XLMAC_HIGIG_HDR_1r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_LAG_FAILOVER_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_LAG_FAILOVER_STATUSr_OFFSET 0x10061900

#define XLMAC_LAG_FAILOVER_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_LAG_FAILOVER_STATUS.
 */
typedef union XLMAC_LAG_FAILOVER_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_lag_failover_status[2];
	uint32_t _xlmac_lag_failover_status;
} XLMAC_LAG_FAILOVER_STATUSr_t;

#define XLMAC_LAG_FAILOVER_STATUSr_CLR(r) sal_memset(&((r)._xlmac_lag_failover_status), 0, sizeof(XLMAC_LAG_FAILOVER_STATUSr_t))
#define XLMAC_LAG_FAILOVER_STATUSr_SET(r,i,d) (r).xlmac_lag_failover_status[i] = d
#define XLMAC_LAG_FAILOVER_STATUSr_GET(r,i) (r).xlmac_lag_failover_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_GET(r) (((r).xlmac_lag_failover_status[0]) & 0x1)
#define XLMAC_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_SET(r,f) (r).xlmac_lag_failover_status[0]=(((r).xlmac_lag_failover_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_LAG_FAILOVER_STATUSr_RSVDf_GET(r) ((((r).xlmac_lag_failover_status[0]) >> 1) & 0x1)
#define XLMAC_LAG_FAILOVER_STATUSr_RSVDf_SET(r,f) (r).xlmac_lag_failover_status[0]=(((r).xlmac_lag_failover_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_LAG_FAILOVER_STATUS.
 */
#define READ_XLMAC_LAG_FAILOVER_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_LAG_FAILOVER_STATUSr_OFFSET,0,XLMAC_LAG_FAILOVER_STATUSr_SIZE,(r._xlmac_lag_failover_status))
#define WRITE_XLMAC_LAG_FAILOVER_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_LAG_FAILOVER_STATUSr_OFFSET,0,XLMAC_LAG_FAILOVER_STATUSr_SIZE,&(r._xlmac_lag_failover_status))

/*******************************************************************************
 * End of 'XLMAC_LAG_FAILOVER_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_LLFC_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_LLFC_CTRLr_OFFSET 0x10061200

#define XLMAC_LLFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_LLFC_CTRL.
 */
typedef union XLMAC_LLFC_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_llfc_ctrl[2];
	uint32_t _xlmac_llfc_ctrl;
} XLMAC_LLFC_CTRLr_t;

#define XLMAC_LLFC_CTRLr_CLR(r) sal_memset(&((r)._xlmac_llfc_ctrl), 0, sizeof(XLMAC_LLFC_CTRLr_t))
#define XLMAC_LLFC_CTRLr_SET(r,i,d) (r).xlmac_llfc_ctrl[i] = d
#define XLMAC_LLFC_CTRLr_GET(r,i) (r).xlmac_llfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_LLFC_CTRLr_TX_LLFC_ENf_GET(r) (((r).xlmac_llfc_ctrl[0]) & 0x1)
#define XLMAC_LLFC_CTRLr_TX_LLFC_ENf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_LLFC_CTRLr_RX_LLFC_ENf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 1) & 0x1)
#define XLMAC_LLFC_CTRLr_RX_LLFC_ENf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 2) & 0x1)
#define XLMAC_LLFC_CTRLr_LLFC_IN_IPG_ONLYf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 3) & 0x1)
#define XLMAC_LLFC_CTRLr_LLFC_CUT_THROUGH_MODEf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 4) & 0x1)
#define XLMAC_LLFC_CTRLr_LLFC_CRC_IGNOREf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 5) & 0x1)
#define XLMAC_LLFC_CTRLr_NO_SOM_FOR_CRC_LLFCf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define XLMAC_LLFC_CTRLr_LLFC_IMGf_GET(r) ((((r).xlmac_llfc_ctrl[0]) >> 6) & 0xff)
#define XLMAC_LLFC_CTRLr_LLFC_IMGf_SET(r,f) (r).xlmac_llfc_ctrl[0]=(((r).xlmac_llfc_ctrl[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))

/*
 * These macros can be used to access XLMAC_LLFC_CTRL.
 */
#define READ_XLMAC_LLFC_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_LLFC_CTRLr_OFFSET,0,XLMAC_LLFC_CTRLr_SIZE,(r._xlmac_llfc_ctrl))
#define WRITE_XLMAC_LLFC_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_LLFC_CTRLr_OFFSET,0,XLMAC_LLFC_CTRLr_SIZE,&(r._xlmac_llfc_ctrl))

/*******************************************************************************
 * End of 'XLMAC_LLFC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_MEM_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_MEM_CTRLr_OFFSET 0x10062d00

#define XLMAC_MEM_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_MEM_CTRL.
 */
typedef union XLMAC_MEM_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_mem_ctrl[2];
	uint32_t _xlmac_mem_ctrl;
} XLMAC_MEM_CTRLr_t;

#define XLMAC_MEM_CTRLr_CLR(r) sal_memset(&((r)._xlmac_mem_ctrl), 0, sizeof(XLMAC_MEM_CTRLr_t))
#define XLMAC_MEM_CTRLr_SET(r,i,d) (r).xlmac_mem_ctrl[i] = d
#define XLMAC_MEM_CTRLr_GET(r,i) (r).xlmac_mem_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_MEM_CTRLr_RX_CDC_MEM_CTRL_TMf_GET(r) (((r).xlmac_mem_ctrl[0]) & 0xfff)
#define XLMAC_MEM_CTRLr_RX_CDC_MEM_CTRL_TMf_SET(r,f) (r).xlmac_mem_ctrl[0]=(((r).xlmac_mem_ctrl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define XLMAC_MEM_CTRLr_TX_CDC_MEM_CTRL_TMf_GET(r) ((((r).xlmac_mem_ctrl[0]) >> 12) & 0xfff)
#define XLMAC_MEM_CTRLr_TX_CDC_MEM_CTRL_TMf_SET(r,f) (r).xlmac_mem_ctrl[0]=(((r).xlmac_mem_ctrl[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access XLMAC_MEM_CTRL.
 */
#define READ_XLMAC_MEM_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_MEM_CTRLr_OFFSET,0,XLMAC_MEM_CTRLr_SIZE,(r._xlmac_mem_ctrl))
#define WRITE_XLMAC_MEM_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_MEM_CTRLr_OFFSET,0,XLMAC_MEM_CTRLr_SIZE,&(r._xlmac_mem_ctrl))

/*******************************************************************************
 * End of 'XLMAC_MEM_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_MODE
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_MODEr_OFFSET 0x10060100

#define XLMAC_MODEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_MODE.
 */
typedef union XLMAC_MODEr_s {
	uint32_t v[2];
	uint32_t xlmac_mode[2];
	uint32_t _xlmac_mode;
} XLMAC_MODEr_t;

#define XLMAC_MODEr_CLR(r) sal_memset(&((r)._xlmac_mode), 0, sizeof(XLMAC_MODEr_t))
#define XLMAC_MODEr_SET(r,i,d) (r).xlmac_mode[i] = d
#define XLMAC_MODEr_GET(r,i) (r).xlmac_mode[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_MODEr_HDR_MODEf_GET(r) (((r).xlmac_mode[0]) & 0x7)
#define XLMAC_MODEr_HDR_MODEf_SET(r,f) (r).xlmac_mode[0]=(((r).xlmac_mode[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define XLMAC_MODEr_NO_SOP_FOR_CRC_HGf_GET(r) ((((r).xlmac_mode[0]) >> 3) & 0x1)
#define XLMAC_MODEr_NO_SOP_FOR_CRC_HGf_SET(r,f) (r).xlmac_mode[0]=(((r).xlmac_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_MODEr_SPEED_MODEf_GET(r) ((((r).xlmac_mode[0]) >> 4) & 0x7)
#define XLMAC_MODEr_SPEED_MODEf_SET(r,f) (r).xlmac_mode[0]=(((r).xlmac_mode[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))

/*
 * These macros can be used to access XLMAC_MODE.
 */
#define READ_XLMAC_MODEr(pa,p,r) bcmpmac_read(pa,p,XLMAC_MODEr_OFFSET,0,XLMAC_MODEr_SIZE,(r._xlmac_mode))
#define WRITE_XLMAC_MODEr(pa,p,r) bcmpmac_write(pa,p,XLMAC_MODEr_OFFSET,0,XLMAC_MODEr_SIZE,&(r._xlmac_mode))

/*******************************************************************************
 * End of 'XLMAC_MODEr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_PAUSE_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_PAUSE_CTRLr_OFFSET 0x10060d00

#define XLMAC_PAUSE_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PAUSE_CTRL.
 */
typedef union XLMAC_PAUSE_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_pause_ctrl[2];
	uint32_t _xlmac_pause_ctrl;
} XLMAC_PAUSE_CTRLr_t;

#define XLMAC_PAUSE_CTRLr_CLR(r) sal_memset(&((r)._xlmac_pause_ctrl), 0, sizeof(XLMAC_PAUSE_CTRLr_t))
#define XLMAC_PAUSE_CTRLr_SET(r,i,d) (r).xlmac_pause_ctrl[i] = d
#define XLMAC_PAUSE_CTRLr_GET(r,i) (r).xlmac_pause_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_LOf_GET(r) ((r).xlmac_pause_ctrl[0])
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_LOf_SET(r,f) (r).xlmac_pause_ctrl[0]=((uint32_t)f)
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_GET(r) (((r).xlmac_pause_ctrl[0]) & 0xffff)
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_TIMERf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 16) & 0x1)
#define XLMAC_PAUSE_CTRLr_PAUSE_REFRESH_ENf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define XLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 17) & 0x1)
#define XLMAC_PAUSE_CTRLr_TX_PAUSE_ENf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define XLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 18) & 0x1)
#define XLMAC_PAUSE_CTRLr_RX_PAUSE_ENf_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define XLMAC_PAUSE_CTRLr_RSVD_1f_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 19) & 0x1)
#define XLMAC_PAUSE_CTRLr_RSVD_1f_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define XLMAC_PAUSE_CTRLr_RSVD_2f_GET(r) ((((r).xlmac_pause_ctrl[0]) >> 20) & 0x1)
#define XLMAC_PAUSE_CTRLr_RSVD_2f_SET(r,f) (r).xlmac_pause_ctrl[0]=(((r).xlmac_pause_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define XLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_GET(r) bcmpmac_field32_get((r).xlmac_pause_ctrl,21,36)
#define XLMAC_PAUSE_CTRLr_PAUSE_XOFF_TIMERf_SET(r,f) bcmpmac_field32_set((r).xlmac_pause_ctrl,21,36,f)
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_HIf_GET(r) (((r).xlmac_pause_ctrl[1]) & 0x1f)
#define XLMAC_PAUSE_CTRLr_XLMAC_PAUSE_CTRL_HIf_SET(r,f) (r).xlmac_pause_ctrl[1]=(((r).xlmac_pause_ctrl[1] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access XLMAC_PAUSE_CTRL.
 */
#define READ_XLMAC_PAUSE_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_PAUSE_CTRLr_OFFSET,0,XLMAC_PAUSE_CTRLr_SIZE,(r._xlmac_pause_ctrl))
#define WRITE_XLMAC_PAUSE_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_PAUSE_CTRLr_OFFSET,0,XLMAC_PAUSE_CTRLr_SIZE,&(r._xlmac_pause_ctrl))

/*******************************************************************************
 * End of 'XLMAC_PAUSE_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_PFC_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_PFC_CTRLr_OFFSET 0x10060e00

#define XLMAC_PFC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_CTRL.
 */
typedef union XLMAC_PFC_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_pfc_ctrl[2];
	uint32_t _xlmac_pfc_ctrl;
} XLMAC_PFC_CTRLr_t;

#define XLMAC_PFC_CTRLr_CLR(r) sal_memset(&((r)._xlmac_pfc_ctrl), 0, sizeof(XLMAC_PFC_CTRLr_t))
#define XLMAC_PFC_CTRLr_SET(r,i,d) (r).xlmac_pfc_ctrl[i] = d
#define XLMAC_PFC_CTRLr_GET(r,i) (r).xlmac_pfc_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_GET(r) (((r).xlmac_pfc_ctrl[0]) & 0xffff)
#define XLMAC_PFC_CTRLr_PFC_REFRESH_TIMERf_SET(r,f) (r).xlmac_pfc_ctrl[0]=(((r).xlmac_pfc_ctrl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define XLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_GET(r) ((((r).xlmac_pfc_ctrl[0]) >> 16) & 0xffff)
#define XLMAC_PFC_CTRLr_PFC_XOFF_TIMERf_SET(r,f) (r).xlmac_pfc_ctrl[0]=(((r).xlmac_pfc_ctrl[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define XLMAC_PFC_CTRLr_PFC_REFRESH_ENf_GET(r) (((r).xlmac_pfc_ctrl[1]) & 0x1)
#define XLMAC_PFC_CTRLr_PFC_REFRESH_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_PFC_CTRLr_FORCE_PFC_XONf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 1) & 0x1)
#define XLMAC_PFC_CTRLr_FORCE_PFC_XONf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_PFC_CTRLr_RSVDf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 2) & 0x1)
#define XLMAC_PFC_CTRLr_RSVDf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_PFC_CTRLr_PFC_STATS_ENf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 3) & 0x1)
#define XLMAC_PFC_CTRLr_PFC_STATS_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_PFC_CTRLr_RX_PFC_ENf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 4) & 0x1)
#define XLMAC_PFC_CTRLr_RX_PFC_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLMAC_PFC_CTRLr_TX_PFC_ENf_GET(r) ((((r).xlmac_pfc_ctrl[1]) >> 5) & 0x1)
#define XLMAC_PFC_CTRLr_TX_PFC_ENf_SET(r,f) (r).xlmac_pfc_ctrl[1]=(((r).xlmac_pfc_ctrl[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access XLMAC_PFC_CTRL.
 */
#define READ_XLMAC_PFC_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_PFC_CTRLr_OFFSET,0,XLMAC_PFC_CTRLr_SIZE,(r._xlmac_pfc_ctrl))
#define WRITE_XLMAC_PFC_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_PFC_CTRLr_OFFSET,0,XLMAC_PFC_CTRLr_SIZE,&(r._xlmac_pfc_ctrl))

/*******************************************************************************
 * End of 'XLMAC_PFC_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_PFC_DA
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_PFC_DAr_OFFSET 0x10061100

#define XLMAC_PFC_DAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_DA.
 */
typedef union XLMAC_PFC_DAr_s {
	uint32_t v[2];
	uint32_t xlmac_pfc_da[2];
	uint32_t _xlmac_pfc_da;
} XLMAC_PFC_DAr_t;

#define XLMAC_PFC_DAr_CLR(r) sal_memset(&((r)._xlmac_pfc_da), 0, sizeof(XLMAC_PFC_DAr_t))
#define XLMAC_PFC_DAr_SET(r,i,d) (r).xlmac_pfc_da[i] = d
#define XLMAC_PFC_DAr_GET(r,i) (r).xlmac_pfc_da[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_DAr_PFC_MACDAf_GET(r,a) bcmpmac_field_get((r).xlmac_pfc_da,0,47,a)
#define XLMAC_PFC_DAr_PFC_MACDAf_SET(r,a) bcmpmac_field_set((r).xlmac_pfc_da,0,47,a)
#define XLMAC_PFC_DAr_PFC_MACDA_LOf_GET(r) ((r).xlmac_pfc_da[0])
#define XLMAC_PFC_DAr_PFC_MACDA_LOf_SET(r,f) (r).xlmac_pfc_da[0]=((uint32_t)f)
#define XLMAC_PFC_DAr_PFC_MACDA_HIf_GET(r) (((r).xlmac_pfc_da[1]) & 0xffff)
#define XLMAC_PFC_DAr_PFC_MACDA_HIf_SET(r,f) (r).xlmac_pfc_da[1]=(((r).xlmac_pfc_da[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_PFC_DA.
 */
#define READ_XLMAC_PFC_DAr(pa,p,r) bcmpmac_read(pa,p,XLMAC_PFC_DAr_OFFSET,0,XLMAC_PFC_DAr_SIZE,(r._xlmac_pfc_da))
#define WRITE_XLMAC_PFC_DAr(pa,p,r) bcmpmac_write(pa,p,XLMAC_PFC_DAr_OFFSET,0,XLMAC_PFC_DAr_SIZE,&(r._xlmac_pfc_da))

/*******************************************************************************
 * End of 'XLMAC_PFC_DAr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_PFC_OPCODE
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_PFC_OPCODEr_OFFSET 0x10061000

#define XLMAC_PFC_OPCODEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_OPCODE.
 */
typedef union XLMAC_PFC_OPCODEr_s {
	uint32_t v[2];
	uint32_t xlmac_pfc_opcode[2];
	uint32_t _xlmac_pfc_opcode;
} XLMAC_PFC_OPCODEr_t;

#define XLMAC_PFC_OPCODEr_CLR(r) sal_memset(&((r)._xlmac_pfc_opcode), 0, sizeof(XLMAC_PFC_OPCODEr_t))
#define XLMAC_PFC_OPCODEr_SET(r,i,d) (r).xlmac_pfc_opcode[i] = d
#define XLMAC_PFC_OPCODEr_GET(r,i) (r).xlmac_pfc_opcode[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_OPCODEr_PFC_OPCODEf_GET(r) (((r).xlmac_pfc_opcode[0]) & 0xffff)
#define XLMAC_PFC_OPCODEr_PFC_OPCODEf_SET(r,f) (r).xlmac_pfc_opcode[0]=(((r).xlmac_pfc_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_PFC_OPCODE.
 */
#define READ_XLMAC_PFC_OPCODEr(pa,p,r) bcmpmac_read(pa,p,XLMAC_PFC_OPCODEr_OFFSET,0,XLMAC_PFC_OPCODEr_SIZE,(r._xlmac_pfc_opcode))
#define WRITE_XLMAC_PFC_OPCODEr(pa,p,r) bcmpmac_write(pa,p,XLMAC_PFC_OPCODEr_OFFSET,0,XLMAC_PFC_OPCODEr_SIZE,&(r._xlmac_pfc_opcode))

/*******************************************************************************
 * End of 'XLMAC_PFC_OPCODEr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_PFC_TYPE
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_PFC_TYPEr_OFFSET 0x10060f00

#define XLMAC_PFC_TYPEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_PFC_TYPE.
 */
typedef union XLMAC_PFC_TYPEr_s {
	uint32_t v[2];
	uint32_t xlmac_pfc_type[2];
	uint32_t _xlmac_pfc_type;
} XLMAC_PFC_TYPEr_t;

#define XLMAC_PFC_TYPEr_CLR(r) sal_memset(&((r)._xlmac_pfc_type), 0, sizeof(XLMAC_PFC_TYPEr_t))
#define XLMAC_PFC_TYPEr_SET(r,i,d) (r).xlmac_pfc_type[i] = d
#define XLMAC_PFC_TYPEr_GET(r,i) (r).xlmac_pfc_type[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_PFC_TYPEr_PFC_ETH_TYPEf_GET(r) (((r).xlmac_pfc_type[0]) & 0xffff)
#define XLMAC_PFC_TYPEr_PFC_ETH_TYPEf_SET(r,f) (r).xlmac_pfc_type[0]=(((r).xlmac_pfc_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_PFC_TYPE.
 */
#define READ_XLMAC_PFC_TYPEr(pa,p,r) bcmpmac_read(pa,p,XLMAC_PFC_TYPEr_OFFSET,0,XLMAC_PFC_TYPEr_SIZE,(r._xlmac_pfc_type))
#define WRITE_XLMAC_PFC_TYPEr(pa,p,r) bcmpmac_write(pa,p,XLMAC_PFC_TYPEr_OFFSET,0,XLMAC_PFC_TYPEr_SIZE,&(r._xlmac_pfc_type))

/*******************************************************************************
 * End of 'XLMAC_PFC_TYPEr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_CDC_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_CDC_ECC_STATUSr_OFFSET 0x10063100

#define XLMAC_RX_CDC_ECC_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_CDC_ECC_STATUS.
 */
typedef union XLMAC_RX_CDC_ECC_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_cdc_ecc_status[2];
	uint32_t _xlmac_rx_cdc_ecc_status;
} XLMAC_RX_CDC_ECC_STATUSr_t;

#define XLMAC_RX_CDC_ECC_STATUSr_CLR(r) sal_memset(&((r)._xlmac_rx_cdc_ecc_status), 0, sizeof(XLMAC_RX_CDC_ECC_STATUSr_t))
#define XLMAC_RX_CDC_ECC_STATUSr_SET(r,i,d) (r).xlmac_rx_cdc_ecc_status[i] = d
#define XLMAC_RX_CDC_ECC_STATUSr_GET(r,i) (r).xlmac_rx_cdc_ecc_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_CDC_ECC_STATUSr_RX_CDC_SINGLE_BIT_ERRf_GET(r) (((r).xlmac_rx_cdc_ecc_status[0]) & 0x1)
#define XLMAC_RX_CDC_ECC_STATUSr_RX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).xlmac_rx_cdc_ecc_status[0]=(((r).xlmac_rx_cdc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_RX_CDC_ECC_STATUSr_RX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).xlmac_rx_cdc_ecc_status[0]) >> 1) & 0x1)
#define XLMAC_RX_CDC_ECC_STATUSr_RX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).xlmac_rx_cdc_ecc_status[0]=(((r).xlmac_rx_cdc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_RX_CDC_ECC_STATUS.
 */
#define READ_XLMAC_RX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_CDC_ECC_STATUSr_OFFSET,0,XLMAC_RX_CDC_ECC_STATUSr_SIZE,(r._xlmac_rx_cdc_ecc_status))
#define WRITE_XLMAC_RX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_CDC_ECC_STATUSr_OFFSET,0,XLMAC_RX_CDC_ECC_STATUSr_SIZE,&(r._xlmac_rx_cdc_ecc_status))

/*******************************************************************************
 * End of 'XLMAC_RX_CDC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_CTRLr_OFFSET 0x10060600

#define XLMAC_RX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_CTRL.
 */
typedef union XLMAC_RX_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_ctrl[2];
	uint32_t _xlmac_rx_ctrl;
} XLMAC_RX_CTRLr_t;

#define XLMAC_RX_CTRLr_CLR(r) sal_memset(&((r)._xlmac_rx_ctrl), 0, sizeof(XLMAC_RX_CTRLr_t))
#define XLMAC_RX_CTRLr_SET(r,i,d) (r).xlmac_rx_ctrl[i] = d
#define XLMAC_RX_CTRLr_GET(r,i) (r).xlmac_rx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_CTRLr_RSVD_1f_GET(r) (((r).xlmac_rx_ctrl[0]) & 0x1)
#define XLMAC_RX_CTRLr_RSVD_1f_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_RX_CTRLr_RX_ANY_STARTf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 1) & 0x1)
#define XLMAC_RX_CTRLr_RX_ANY_STARTf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_RX_CTRLr_STRIP_CRCf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 2) & 0x1)
#define XLMAC_RX_CTRLr_STRIP_CRCf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_RX_CTRLr_STRICT_PREAMBLEf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 3) & 0x1)
#define XLMAC_RX_CTRLr_STRICT_PREAMBLEf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_RX_CTRLr_RUNT_THRESHOLDf_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 4) & 0x7f)
#define XLMAC_RX_CTRLr_RUNT_THRESHOLDf_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32_t)0x7f << 4)) | ((((uint32_t)f) & 0x7f) << 4))
#define XLMAC_RX_CTRLr_RSVD_2f_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 11) & 0x1)
#define XLMAC_RX_CTRLr_RSVD_2f_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define XLMAC_RX_CTRLr_RSVD_3f_GET(r) ((((r).xlmac_rx_ctrl[0]) >> 12) & 0x1)
#define XLMAC_RX_CTRLr_RSVD_3f_SET(r,f) (r).xlmac_rx_ctrl[0]=(((r).xlmac_rx_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access XLMAC_RX_CTRL.
 */
#define READ_XLMAC_RX_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_CTRLr_OFFSET,0,XLMAC_RX_CTRLr_SIZE,(r._xlmac_rx_ctrl))
#define WRITE_XLMAC_RX_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_CTRLr_OFFSET,0,XLMAC_RX_CTRLr_SIZE,&(r._xlmac_rx_ctrl))

/*******************************************************************************
 * End of 'XLMAC_RX_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_LLFC_MSG_FIELDS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_LLFC_MSG_FIELDSr_OFFSET 0x10061400

#define XLMAC_RX_LLFC_MSG_FIELDSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_LLFC_MSG_FIELDS.
 */
typedef union XLMAC_RX_LLFC_MSG_FIELDSr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_llfc_msg_fields[2];
	uint32_t _xlmac_rx_llfc_msg_fields;
} XLMAC_RX_LLFC_MSG_FIELDSr_t;

#define XLMAC_RX_LLFC_MSG_FIELDSr_CLR(r) sal_memset(&((r)._xlmac_rx_llfc_msg_fields), 0, sizeof(XLMAC_RX_LLFC_MSG_FIELDSr_t))
#define XLMAC_RX_LLFC_MSG_FIELDSr_SET(r,i,d) (r).xlmac_rx_llfc_msg_fields[i] = d
#define XLMAC_RX_LLFC_MSG_FIELDSr_GET(r,i) (r).xlmac_rx_llfc_msg_fields[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_LOGICALf_GET(r) (((r).xlmac_rx_llfc_msg_fields[0]) & 0xff)
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_LOGICALf_SET(r,f) (r).xlmac_rx_llfc_msg_fields[0]=(((r).xlmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_LOGICALf_GET(r) ((((r).xlmac_rx_llfc_msg_fields[0]) >> 8) & 0xf)
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_LOGICALf_SET(r,f) (r).xlmac_rx_llfc_msg_fields[0]=(((r).xlmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_PHYSICALf_GET(r) ((((r).xlmac_rx_llfc_msg_fields[0]) >> 12) & 0xff)
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_MSG_TYPE_PHYSICALf_SET(r,f) (r).xlmac_rx_llfc_msg_fields[0]=(((r).xlmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xff << 12)) | ((((uint32_t)f) & 0xff) << 12))
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_PHYSICALf_GET(r) ((((r).xlmac_rx_llfc_msg_fields[0]) >> 20) & 0xf)
#define XLMAC_RX_LLFC_MSG_FIELDSr_RX_LLFC_FC_OBJ_PHYSICALf_SET(r,f) (r).xlmac_rx_llfc_msg_fields[0]=(((r).xlmac_rx_llfc_msg_fields[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))

/*
 * These macros can be used to access XLMAC_RX_LLFC_MSG_FIELDS.
 */
#define READ_XLMAC_RX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_LLFC_MSG_FIELDSr_OFFSET,0,XLMAC_RX_LLFC_MSG_FIELDSr_SIZE,(r._xlmac_rx_llfc_msg_fields))
#define WRITE_XLMAC_RX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_LLFC_MSG_FIELDSr_OFFSET,0,XLMAC_RX_LLFC_MSG_FIELDSr_SIZE,&(r._xlmac_rx_llfc_msg_fields))

/*******************************************************************************
 * End of 'XLMAC_RX_LLFC_MSG_FIELDSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_LSS_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_LSS_CTRLr_OFFSET 0x10060a00

#define XLMAC_RX_LSS_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_LSS_CTRL.
 */
typedef union XLMAC_RX_LSS_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_lss_ctrl[2];
	uint32_t _xlmac_rx_lss_ctrl;
} XLMAC_RX_LSS_CTRLr_t;

#define XLMAC_RX_LSS_CTRLr_CLR(r) sal_memset(&((r)._xlmac_rx_lss_ctrl), 0, sizeof(XLMAC_RX_LSS_CTRLr_t))
#define XLMAC_RX_LSS_CTRLr_SET(r,i,d) (r).xlmac_rx_lss_ctrl[i] = d
#define XLMAC_RX_LSS_CTRLr_GET(r,i) (r).xlmac_rx_lss_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_GET(r) (((r).xlmac_rx_lss_ctrl[0]) & 0x1)
#define XLMAC_RX_LSS_CTRLr_LOCAL_FAULT_DISABLEf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 1) & 0x1)
#define XLMAC_RX_LSS_CTRLr_REMOTE_FAULT_DISABLEf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_RX_LSS_CTRLr_USE_EXTERNAL_FAULTS_FOR_TXf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 2) & 0x1)
#define XLMAC_RX_LSS_CTRLr_USE_EXTERNAL_FAULTS_FOR_TXf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 3) & 0x1)
#define XLMAC_RX_LSS_CTRLr_LINK_INTERRUPTION_DISABLEf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 4) & 0x1)
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LOCAL_FAULTf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 5) & 0x1)
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_REMOTE_FAULTf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 6) & 0x1)
#define XLMAC_RX_LSS_CTRLr_DROP_TX_DATA_ON_LINK_INTERRUPTf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define XLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_GET(r) ((((r).xlmac_rx_lss_ctrl[0]) >> 7) & 0x1)
#define XLMAC_RX_LSS_CTRLr_RESET_FLOW_CONTROL_TIMERS_ON_LINK_DOWNf_SET(r,f) (r).xlmac_rx_lss_ctrl[0]=(((r).xlmac_rx_lss_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access XLMAC_RX_LSS_CTRL.
 */
#define READ_XLMAC_RX_LSS_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_LSS_CTRLr_OFFSET,0,XLMAC_RX_LSS_CTRLr_SIZE,(r._xlmac_rx_lss_ctrl))
#define WRITE_XLMAC_RX_LSS_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_LSS_CTRLr_OFFSET,0,XLMAC_RX_LSS_CTRLr_SIZE,&(r._xlmac_rx_lss_ctrl))

/*******************************************************************************
 * End of 'XLMAC_RX_LSS_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_LSS_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_LSS_STATUSr_OFFSET 0x10060b00

#define XLMAC_RX_LSS_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_LSS_STATUS.
 */
typedef union XLMAC_RX_LSS_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_lss_status[2];
	uint32_t _xlmac_rx_lss_status;
} XLMAC_RX_LSS_STATUSr_t;

#define XLMAC_RX_LSS_STATUSr_CLR(r) sal_memset(&((r)._xlmac_rx_lss_status), 0, sizeof(XLMAC_RX_LSS_STATUSr_t))
#define XLMAC_RX_LSS_STATUSr_SET(r,i,d) (r).xlmac_rx_lss_status[i] = d
#define XLMAC_RX_LSS_STATUSr_GET(r,i) (r).xlmac_rx_lss_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_GET(r) (((r).xlmac_rx_lss_status[0]) & 0x1)
#define XLMAC_RX_LSS_STATUSr_LOCAL_FAULT_STATUSf_SET(r,f) (r).xlmac_rx_lss_status[0]=(((r).xlmac_rx_lss_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_GET(r) ((((r).xlmac_rx_lss_status[0]) >> 1) & 0x1)
#define XLMAC_RX_LSS_STATUSr_REMOTE_FAULT_STATUSf_SET(r,f) (r).xlmac_rx_lss_status[0]=(((r).xlmac_rx_lss_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_GET(r) ((((r).xlmac_rx_lss_status[0]) >> 2) & 0x1)
#define XLMAC_RX_LSS_STATUSr_LINK_INTERRUPTION_STATUSf_SET(r,f) (r).xlmac_rx_lss_status[0]=(((r).xlmac_rx_lss_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access XLMAC_RX_LSS_STATUS.
 */
#define READ_XLMAC_RX_LSS_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_LSS_STATUSr_OFFSET,0,XLMAC_RX_LSS_STATUSr_SIZE,(r._xlmac_rx_lss_status))
#define WRITE_XLMAC_RX_LSS_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_LSS_STATUSr_OFFSET,0,XLMAC_RX_LSS_STATUSr_SIZE,&(r._xlmac_rx_lss_status))

/*******************************************************************************
 * End of 'XLMAC_RX_LSS_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_MAC_SA
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_MAC_SAr_OFFSET 0x10060700

#define XLMAC_RX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_MAC_SA.
 */
typedef union XLMAC_RX_MAC_SAr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_mac_sa[2];
	uint32_t _xlmac_rx_mac_sa;
} XLMAC_RX_MAC_SAr_t;

#define XLMAC_RX_MAC_SAr_CLR(r) sal_memset(&((r)._xlmac_rx_mac_sa), 0, sizeof(XLMAC_RX_MAC_SAr_t))
#define XLMAC_RX_MAC_SAr_SET(r,i,d) (r).xlmac_rx_mac_sa[i] = d
#define XLMAC_RX_MAC_SAr_GET(r,i) (r).xlmac_rx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_MAC_SAr_RX_SAf_GET(r,a) bcmpmac_field_get((r).xlmac_rx_mac_sa,0,47,a)
#define XLMAC_RX_MAC_SAr_RX_SAf_SET(r,a) bcmpmac_field_set((r).xlmac_rx_mac_sa,0,47,a)
#define XLMAC_RX_MAC_SAr_SA_LOf_GET(r) ((r).xlmac_rx_mac_sa[0])
#define XLMAC_RX_MAC_SAr_SA_LOf_SET(r,f) (r).xlmac_rx_mac_sa[0]=((uint32_t)f)
#define XLMAC_RX_MAC_SAr_SA_HIf_GET(r) (((r).xlmac_rx_mac_sa[1]) & 0xffff)
#define XLMAC_RX_MAC_SAr_SA_HIf_SET(r,f) (r).xlmac_rx_mac_sa[1]=(((r).xlmac_rx_mac_sa[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_RX_MAC_SA.
 */
#define READ_XLMAC_RX_MAC_SAr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_MAC_SAr_OFFSET,0,XLMAC_RX_MAC_SAr_SIZE,(r._xlmac_rx_mac_sa))
#define WRITE_XLMAC_RX_MAC_SAr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_MAC_SAr_OFFSET,0,XLMAC_RX_MAC_SAr_SIZE,&(r._xlmac_rx_mac_sa))

/*******************************************************************************
 * End of 'XLMAC_RX_MAC_SAr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_MAX_SIZE
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_MAX_SIZEr_OFFSET 0x10060800

#define XLMAC_RX_MAX_SIZEr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_MAX_SIZE.
 */
typedef union XLMAC_RX_MAX_SIZEr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_max_size[2];
	uint32_t _xlmac_rx_max_size;
} XLMAC_RX_MAX_SIZEr_t;

#define XLMAC_RX_MAX_SIZEr_CLR(r) sal_memset(&((r)._xlmac_rx_max_size), 0, sizeof(XLMAC_RX_MAX_SIZEr_t))
#define XLMAC_RX_MAX_SIZEr_SET(r,i,d) (r).xlmac_rx_max_size[i] = d
#define XLMAC_RX_MAX_SIZEr_GET(r,i) (r).xlmac_rx_max_size[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_GET(r) (((r).xlmac_rx_max_size[0]) & 0x3fff)
#define XLMAC_RX_MAX_SIZEr_RX_MAX_SIZEf_SET(r,f) (r).xlmac_rx_max_size[0]=(((r).xlmac_rx_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access XLMAC_RX_MAX_SIZE.
 */
#define READ_XLMAC_RX_MAX_SIZEr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_MAX_SIZEr_OFFSET,0,XLMAC_RX_MAX_SIZEr_SIZE,(r._xlmac_rx_max_size))
#define WRITE_XLMAC_RX_MAX_SIZEr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_MAX_SIZEr_OFFSET,0,XLMAC_RX_MAX_SIZEr_SIZE,&(r._xlmac_rx_max_size))

/*******************************************************************************
 * End of 'XLMAC_RX_MAX_SIZEr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_RX_VLAN_TAG
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_RX_VLAN_TAGr_OFFSET 0x10060900

#define XLMAC_RX_VLAN_TAGr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_RX_VLAN_TAG.
 */
typedef union XLMAC_RX_VLAN_TAGr_s {
	uint32_t v[2];
	uint32_t xlmac_rx_vlan_tag[2];
	uint32_t _xlmac_rx_vlan_tag;
} XLMAC_RX_VLAN_TAGr_t;

#define XLMAC_RX_VLAN_TAGr_CLR(r) sal_memset(&((r)._xlmac_rx_vlan_tag), 0, sizeof(XLMAC_RX_VLAN_TAGr_t))
#define XLMAC_RX_VLAN_TAGr_SET(r,i,d) (r).xlmac_rx_vlan_tag[i] = d
#define XLMAC_RX_VLAN_TAGr_GET(r,i) (r).xlmac_rx_vlan_tag[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_GET(r) (((r).xlmac_rx_vlan_tag[0]) & 0xffff)
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAGf_SET(r,f) (r).xlmac_rx_vlan_tag[0]=(((r).xlmac_rx_vlan_tag[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_GET(r) ((((r).xlmac_rx_vlan_tag[0]) >> 16) & 0xffff)
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAGf_SET(r,f) (r).xlmac_rx_vlan_tag[0]=(((r).xlmac_rx_vlan_tag[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_GET(r) (((r).xlmac_rx_vlan_tag[1]) & 0x1)
#define XLMAC_RX_VLAN_TAGr_INNER_VLAN_TAG_ENABLEf_SET(r,f) (r).xlmac_rx_vlan_tag[1]=(((r).xlmac_rx_vlan_tag[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_GET(r) ((((r).xlmac_rx_vlan_tag[1]) >> 1) & 0x1)
#define XLMAC_RX_VLAN_TAGr_OUTER_VLAN_TAG_ENABLEf_SET(r,f) (r).xlmac_rx_vlan_tag[1]=(((r).xlmac_rx_vlan_tag[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_RX_VLAN_TAG.
 */
#define READ_XLMAC_RX_VLAN_TAGr(pa,p,r) bcmpmac_read(pa,p,XLMAC_RX_VLAN_TAGr_OFFSET,0,XLMAC_RX_VLAN_TAGr_SIZE,(r._xlmac_rx_vlan_tag))
#define WRITE_XLMAC_RX_VLAN_TAGr(pa,p,r) bcmpmac_write(pa,p,XLMAC_RX_VLAN_TAGr_OFFSET,0,XLMAC_RX_VLAN_TAGr_SIZE,&(r._xlmac_rx_vlan_tag))

/*******************************************************************************
 * End of 'XLMAC_RX_VLAN_TAGr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_SPARE0
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_SPARE0r_OFFSET 0x10060200

#define XLMAC_SPARE0r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_SPARE0.
 */
typedef union XLMAC_SPARE0r_s {
	uint32_t v[2];
	uint32_t xlmac_spare0[2];
	uint32_t _xlmac_spare0;
} XLMAC_SPARE0r_t;

#define XLMAC_SPARE0r_CLR(r) sal_memset(&((r)._xlmac_spare0), 0, sizeof(XLMAC_SPARE0r_t))
#define XLMAC_SPARE0r_SET(r,i,d) (r).xlmac_spare0[i] = d
#define XLMAC_SPARE0r_GET(r,i) (r).xlmac_spare0[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_SPARE0r_RSVDf_GET(r) ((r).xlmac_spare0[0])
#define XLMAC_SPARE0r_RSVDf_SET(r,f) (r).xlmac_spare0[0]=((uint32_t)f)

/*
 * These macros can be used to access XLMAC_SPARE0.
 */
#define READ_XLMAC_SPARE0r(pa,p,r) bcmpmac_read(pa,p,XLMAC_SPARE0r_OFFSET,0,XLMAC_SPARE0r_SIZE,(r._xlmac_spare0))
#define WRITE_XLMAC_SPARE0r(pa,p,r) bcmpmac_write(pa,p,XLMAC_SPARE0r_OFFSET,0,XLMAC_SPARE0r_SIZE,&(r._xlmac_spare0))

/*******************************************************************************
 * End of 'XLMAC_SPARE0r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_SPARE1
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_SPARE1r_OFFSET 0x10060300

#define XLMAC_SPARE1r_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_SPARE1.
 */
typedef union XLMAC_SPARE1r_s {
	uint32_t v[2];
	uint32_t xlmac_spare1[2];
	uint32_t _xlmac_spare1;
} XLMAC_SPARE1r_t;

#define XLMAC_SPARE1r_CLR(r) sal_memset(&((r)._xlmac_spare1), 0, sizeof(XLMAC_SPARE1r_t))
#define XLMAC_SPARE1r_SET(r,i,d) (r).xlmac_spare1[i] = d
#define XLMAC_SPARE1r_GET(r,i) (r).xlmac_spare1[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_SPARE1r_RSVDf_GET(r) (((r).xlmac_spare1[0]) & 0x3)
#define XLMAC_SPARE1r_RSVDf_SET(r,f) (r).xlmac_spare1[0]=(((r).xlmac_spare1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access XLMAC_SPARE1.
 */
#define READ_XLMAC_SPARE1r(pa,p,r) bcmpmac_read(pa,p,XLMAC_SPARE1r_OFFSET,0,XLMAC_SPARE1r_SIZE,(r._xlmac_spare1))
#define WRITE_XLMAC_SPARE1r(pa,p,r) bcmpmac_write(pa,p,XLMAC_SPARE1r_OFFSET,0,XLMAC_SPARE1r_SIZE,&(r._xlmac_spare1))

/*******************************************************************************
 * End of 'XLMAC_SPARE1r'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TIMESTAMP_ADJUST
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TIMESTAMP_ADJUSTr_OFFSET 0x10062000

#define XLMAC_TIMESTAMP_ADJUSTr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TIMESTAMP_ADJUST.
 */
typedef union XLMAC_TIMESTAMP_ADJUSTr_s {
	uint32_t v[2];
	uint32_t xlmac_timestamp_adjust[2];
	uint32_t _xlmac_timestamp_adjust;
} XLMAC_TIMESTAMP_ADJUSTr_t;

#define XLMAC_TIMESTAMP_ADJUSTr_CLR(r) sal_memset(&((r)._xlmac_timestamp_adjust), 0, sizeof(XLMAC_TIMESTAMP_ADJUSTr_t))
#define XLMAC_TIMESTAMP_ADJUSTr_SET(r,i,d) (r).xlmac_timestamp_adjust[i] = d
#define XLMAC_TIMESTAMP_ADJUSTr_GET(r,i) (r).xlmac_timestamp_adjust[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TIMESTAMP_ADJUSTr_TS_OSTS_ADJUSTf_GET(r) (((r).xlmac_timestamp_adjust[0]) & 0x1ff)
#define XLMAC_TIMESTAMP_ADJUSTr_TS_OSTS_ADJUSTf_SET(r,f) (r).xlmac_timestamp_adjust[0]=(((r).xlmac_timestamp_adjust[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define XLMAC_TIMESTAMP_ADJUSTr_TS_TSTS_ADJUSTf_GET(r) ((((r).xlmac_timestamp_adjust[0]) >> 9) & 0x3f)
#define XLMAC_TIMESTAMP_ADJUSTr_TS_TSTS_ADJUSTf_SET(r,f) (r).xlmac_timestamp_adjust[0]=(((r).xlmac_timestamp_adjust[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define XLMAC_TIMESTAMP_ADJUSTr_TS_USE_CS_OFFSETf_GET(r) ((((r).xlmac_timestamp_adjust[0]) >> 15) & 0x1)
#define XLMAC_TIMESTAMP_ADJUSTr_TS_USE_CS_OFFSETf_SET(r,f) (r).xlmac_timestamp_adjust[0]=(((r).xlmac_timestamp_adjust[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access XLMAC_TIMESTAMP_ADJUST.
 */
#define READ_XLMAC_TIMESTAMP_ADJUSTr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TIMESTAMP_ADJUSTr_OFFSET,0,XLMAC_TIMESTAMP_ADJUSTr_SIZE,(r._xlmac_timestamp_adjust))
#define WRITE_XLMAC_TIMESTAMP_ADJUSTr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TIMESTAMP_ADJUSTr_OFFSET,0,XLMAC_TIMESTAMP_ADJUSTr_SIZE,&(r._xlmac_timestamp_adjust))

/*******************************************************************************
 * End of 'XLMAC_TIMESTAMP_ADJUSTr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TXFIFO_CELL_CNT
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TXFIFO_CELL_CNTr_OFFSET 0x10062b00

#define XLMAC_TXFIFO_CELL_CNTr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TXFIFO_CELL_CNT.
 */
typedef union XLMAC_TXFIFO_CELL_CNTr_s {
	uint32_t v[2];
	uint32_t xlmac_txfifo_cell_cnt[2];
	uint32_t _xlmac_txfifo_cell_cnt;
} XLMAC_TXFIFO_CELL_CNTr_t;

#define XLMAC_TXFIFO_CELL_CNTr_CLR(r) sal_memset(&((r)._xlmac_txfifo_cell_cnt), 0, sizeof(XLMAC_TXFIFO_CELL_CNTr_t))
#define XLMAC_TXFIFO_CELL_CNTr_SET(r,i,d) (r).xlmac_txfifo_cell_cnt[i] = d
#define XLMAC_TXFIFO_CELL_CNTr_GET(r,i) (r).xlmac_txfifo_cell_cnt[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_GET(r) (((r).xlmac_txfifo_cell_cnt[0]) & 0x3f)
#define XLMAC_TXFIFO_CELL_CNTr_CELL_CNTf_SET(r,f) (r).xlmac_txfifo_cell_cnt[0]=(((r).xlmac_txfifo_cell_cnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access XLMAC_TXFIFO_CELL_CNT.
 */
#define READ_XLMAC_TXFIFO_CELL_CNTr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TXFIFO_CELL_CNTr_OFFSET,0,XLMAC_TXFIFO_CELL_CNTr_SIZE,(r._xlmac_txfifo_cell_cnt))
#define WRITE_XLMAC_TXFIFO_CELL_CNTr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TXFIFO_CELL_CNTr_OFFSET,0,XLMAC_TXFIFO_CELL_CNTr_SIZE,&(r._xlmac_txfifo_cell_cnt))

/*******************************************************************************
 * End of 'XLMAC_TXFIFO_CELL_CNTr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TXFIFO_CELL_REQ_CNT
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TXFIFO_CELL_REQ_CNTr_OFFSET 0x10062c00

#define XLMAC_TXFIFO_CELL_REQ_CNTr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TXFIFO_CELL_REQ_CNT.
 */
typedef union XLMAC_TXFIFO_CELL_REQ_CNTr_s {
	uint32_t v[2];
	uint32_t xlmac_txfifo_cell_req_cnt[2];
	uint32_t _xlmac_txfifo_cell_req_cnt;
} XLMAC_TXFIFO_CELL_REQ_CNTr_t;

#define XLMAC_TXFIFO_CELL_REQ_CNTr_CLR(r) sal_memset(&((r)._xlmac_txfifo_cell_req_cnt), 0, sizeof(XLMAC_TXFIFO_CELL_REQ_CNTr_t))
#define XLMAC_TXFIFO_CELL_REQ_CNTr_SET(r,i,d) (r).xlmac_txfifo_cell_req_cnt[i] = d
#define XLMAC_TXFIFO_CELL_REQ_CNTr_GET(r,i) (r).xlmac_txfifo_cell_req_cnt[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TXFIFO_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).xlmac_txfifo_cell_req_cnt[0]) & 0x3f)
#define XLMAC_TXFIFO_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).xlmac_txfifo_cell_req_cnt[0]=(((r).xlmac_txfifo_cell_req_cnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access XLMAC_TXFIFO_CELL_REQ_CNT.
 */
#define READ_XLMAC_TXFIFO_CELL_REQ_CNTr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TXFIFO_CELL_REQ_CNTr_OFFSET,0,XLMAC_TXFIFO_CELL_REQ_CNTr_SIZE,(r._xlmac_txfifo_cell_req_cnt))
#define WRITE_XLMAC_TXFIFO_CELL_REQ_CNTr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TXFIFO_CELL_REQ_CNTr_OFFSET,0,XLMAC_TXFIFO_CELL_REQ_CNTr_SIZE,&(r._xlmac_txfifo_cell_req_cnt))

/*******************************************************************************
 * End of 'XLMAC_TXFIFO_CELL_REQ_CNTr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TX_CDC_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TX_CDC_ECC_STATUSr_OFFSET 0x10063200

#define XLMAC_TX_CDC_ECC_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_CDC_ECC_STATUS.
 */
typedef union XLMAC_TX_CDC_ECC_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_tx_cdc_ecc_status[2];
	uint32_t _xlmac_tx_cdc_ecc_status;
} XLMAC_TX_CDC_ECC_STATUSr_t;

#define XLMAC_TX_CDC_ECC_STATUSr_CLR(r) sal_memset(&((r)._xlmac_tx_cdc_ecc_status), 0, sizeof(XLMAC_TX_CDC_ECC_STATUSr_t))
#define XLMAC_TX_CDC_ECC_STATUSr_SET(r,i,d) (r).xlmac_tx_cdc_ecc_status[i] = d
#define XLMAC_TX_CDC_ECC_STATUSr_GET(r,i) (r).xlmac_tx_cdc_ecc_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_CDC_ECC_STATUSr_TX_CDC_SINGLE_BIT_ERRf_GET(r) (((r).xlmac_tx_cdc_ecc_status[0]) & 0x1)
#define XLMAC_TX_CDC_ECC_STATUSr_TX_CDC_SINGLE_BIT_ERRf_SET(r,f) (r).xlmac_tx_cdc_ecc_status[0]=(((r).xlmac_tx_cdc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_TX_CDC_ECC_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_GET(r) ((((r).xlmac_tx_cdc_ecc_status[0]) >> 1) & 0x1)
#define XLMAC_TX_CDC_ECC_STATUSr_TX_CDC_DOUBLE_BIT_ERRf_SET(r,f) (r).xlmac_tx_cdc_ecc_status[0]=(((r).xlmac_tx_cdc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLMAC_TX_CDC_ECC_STATUS.
 */
#define READ_XLMAC_TX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TX_CDC_ECC_STATUSr_OFFSET,0,XLMAC_TX_CDC_ECC_STATUSr_SIZE,(r._xlmac_tx_cdc_ecc_status))
#define WRITE_XLMAC_TX_CDC_ECC_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TX_CDC_ECC_STATUSr_OFFSET,0,XLMAC_TX_CDC_ECC_STATUSr_SIZE,&(r._xlmac_tx_cdc_ecc_status))

/*******************************************************************************
 * End of 'XLMAC_TX_CDC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TX_CRC_CORRUPT_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TX_CRC_CORRUPT_CTRLr_OFFSET 0x10062100

#define XLMAC_TX_CRC_CORRUPT_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_CRC_CORRUPT_CTRL.
 */
typedef union XLMAC_TX_CRC_CORRUPT_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_tx_crc_corrupt_ctrl[2];
	uint32_t _xlmac_tx_crc_corrupt_ctrl;
} XLMAC_TX_CRC_CORRUPT_CTRLr_t;

#define XLMAC_TX_CRC_CORRUPT_CTRLr_CLR(r) sal_memset(&((r)._xlmac_tx_crc_corrupt_ctrl), 0, sizeof(XLMAC_TX_CRC_CORRUPT_CTRLr_t))
#define XLMAC_TX_CRC_CORRUPT_CTRLr_SET(r,i,d) (r).xlmac_tx_crc_corrupt_ctrl[i] = d
#define XLMAC_TX_CRC_CORRUPT_CTRLr_GET(r,i) (r).xlmac_tx_crc_corrupt_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_CRC_CORRUPT_CTRLr_XLMAC_TX_CRC_CORRUPT_CTRL_LOf_GET(r) ((r).xlmac_tx_crc_corrupt_ctrl[0])
#define XLMAC_TX_CRC_CORRUPT_CTRLr_XLMAC_TX_CRC_CORRUPT_CTRL_LOf_SET(r,f) (r).xlmac_tx_crc_corrupt_ctrl[0]=((uint32_t)f)
#define XLMAC_TX_CRC_CORRUPT_CTRLr_TX_ERR_CORRUPTS_CRCf_GET(r) (((r).xlmac_tx_crc_corrupt_ctrl[0]) & 0x1)
#define XLMAC_TX_CRC_CORRUPT_CTRLr_TX_ERR_CORRUPTS_CRCf_SET(r,f) (r).xlmac_tx_crc_corrupt_ctrl[0]=(((r).xlmac_tx_crc_corrupt_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPT_ENf_GET(r) ((((r).xlmac_tx_crc_corrupt_ctrl[0]) >> 1) & 0x1)
#define XLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPT_ENf_SET(r,f) (r).xlmac_tx_crc_corrupt_ctrl[0]=(((r).xlmac_tx_crc_corrupt_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPTION_MODEf_GET(r) ((((r).xlmac_tx_crc_corrupt_ctrl[0]) >> 2) & 0x1)
#define XLMAC_TX_CRC_CORRUPT_CTRLr_TX_CRC_CORRUPTION_MODEf_SET(r,f) (r).xlmac_tx_crc_corrupt_ctrl[0]=(((r).xlmac_tx_crc_corrupt_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_TX_CRC_CORRUPT_CTRLr_PROG_TX_CRCf_GET(r) bcmpmac_field32_get((r).xlmac_tx_crc_corrupt_ctrl,3,34)
#define XLMAC_TX_CRC_CORRUPT_CTRLr_PROG_TX_CRCf_SET(r,f) bcmpmac_field32_set((r).xlmac_tx_crc_corrupt_ctrl,3,34,f)
#define XLMAC_TX_CRC_CORRUPT_CTRLr_XLMAC_TX_CRC_CORRUPT_CTRL_HIf_GET(r) (((r).xlmac_tx_crc_corrupt_ctrl[1]) & 0x7)
#define XLMAC_TX_CRC_CORRUPT_CTRLr_XLMAC_TX_CRC_CORRUPT_CTRL_HIf_SET(r,f) (r).xlmac_tx_crc_corrupt_ctrl[1]=(((r).xlmac_tx_crc_corrupt_ctrl[1] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access XLMAC_TX_CRC_CORRUPT_CTRL.
 */
#define READ_XLMAC_TX_CRC_CORRUPT_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TX_CRC_CORRUPT_CTRLr_OFFSET,0,XLMAC_TX_CRC_CORRUPT_CTRLr_SIZE,(r._xlmac_tx_crc_corrupt_ctrl))
#define WRITE_XLMAC_TX_CRC_CORRUPT_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TX_CRC_CORRUPT_CTRLr_OFFSET,0,XLMAC_TX_CRC_CORRUPT_CTRLr_SIZE,&(r._xlmac_tx_crc_corrupt_ctrl))

/*******************************************************************************
 * End of 'XLMAC_TX_CRC_CORRUPT_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TX_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TX_CTRLr_OFFSET 0x10060400

#define XLMAC_TX_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_CTRL.
 */
typedef union XLMAC_TX_CTRLr_s {
	uint32_t v[2];
	uint32_t xlmac_tx_ctrl[2];
	uint32_t _xlmac_tx_ctrl;
} XLMAC_TX_CTRLr_t;

#define XLMAC_TX_CTRLr_CLR(r) sal_memset(&((r)._xlmac_tx_ctrl), 0, sizeof(XLMAC_TX_CTRLr_t))
#define XLMAC_TX_CTRLr_SET(r,i,d) (r).xlmac_tx_ctrl[i] = d
#define XLMAC_TX_CTRLr_GET(r,i) (r).xlmac_tx_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_LOf_GET(r) ((r).xlmac_tx_ctrl[0])
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_LOf_SET(r,f) (r).xlmac_tx_ctrl[0]=((uint32_t)f)
#define XLMAC_TX_CTRLr_CRC_MODEf_GET(r) (((r).xlmac_tx_ctrl[0]) & 0x3)
#define XLMAC_TX_CTRLr_CRC_MODEf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define XLMAC_TX_CTRLr_DISCARDf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 2) & 0x1)
#define XLMAC_TX_CTRLr_DISCARDf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLMAC_TX_CTRLr_TX_ANY_STARTf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 3) & 0x1)
#define XLMAC_TX_CTRLr_TX_ANY_STARTf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLMAC_TX_CTRLr_PAD_ENf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 4) & 0x1)
#define XLMAC_TX_CTRLr_PAD_ENf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLMAC_TX_CTRLr_PAD_THRESHOLDf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 5) & 0x7f)
#define XLMAC_TX_CTRLr_PAD_THRESHOLDf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define XLMAC_TX_CTRLr_AVERAGE_IPGf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 12) & 0x7f)
#define XLMAC_TX_CTRLr_AVERAGE_IPGf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32_t)0x7f << 12)) | ((((uint32_t)f) & 0x7f) << 12))
#define XLMAC_TX_CTRLr_THROT_NUMf_GET(r) ((((r).xlmac_tx_ctrl[0]) >> 19) & 0x3f)
#define XLMAC_TX_CTRLr_THROT_NUMf_SET(r,f) (r).xlmac_tx_ctrl[0]=(((r).xlmac_tx_ctrl[0] & ~((uint32_t)0x3f << 19)) | ((((uint32_t)f) & 0x3f) << 19))
#define XLMAC_TX_CTRLr_THROT_DENOMf_GET(r) bcmpmac_field32_get((r).xlmac_tx_ctrl,25,32)
#define XLMAC_TX_CTRLr_THROT_DENOMf_SET(r,f) bcmpmac_field32_set((r).xlmac_tx_ctrl,25,32,f)
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_HIf_GET(r) (((r).xlmac_tx_ctrl[1]) & 0x3ff)
#define XLMAC_TX_CTRLr_XLMAC_TX_CTRL_HIf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define XLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_GET(r) ((((r).xlmac_tx_ctrl[1]) >> 1) & 0xf)
#define XLMAC_TX_CTRLr_TX_PREAMBLE_LENGTHf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define XLMAC_TX_CTRLr_EP_DISCARDf_GET(r) ((((r).xlmac_tx_ctrl[1]) >> 5) & 0x1)
#define XLMAC_TX_CTRLr_EP_DISCARDf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define XLMAC_TX_CTRLr_TX_THRESHOLDf_GET(r) ((((r).xlmac_tx_ctrl[1]) >> 6) & 0xf)
#define XLMAC_TX_CTRLr_TX_THRESHOLDf_SET(r,f) (r).xlmac_tx_ctrl[1]=(((r).xlmac_tx_ctrl[1] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))

/*
 * These macros can be used to access XLMAC_TX_CTRL.
 */
#define READ_XLMAC_TX_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TX_CTRLr_OFFSET,0,XLMAC_TX_CTRLr_SIZE,(r._xlmac_tx_ctrl))
#define WRITE_XLMAC_TX_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TX_CTRLr_OFFSET,0,XLMAC_TX_CTRLr_SIZE,&(r._xlmac_tx_ctrl))

/*******************************************************************************
 * End of 'XLMAC_TX_CTRLr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TX_LLFC_MSG_FIELDS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TX_LLFC_MSG_FIELDSr_OFFSET 0x10061300

#define XLMAC_TX_LLFC_MSG_FIELDSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_LLFC_MSG_FIELDS.
 */
typedef union XLMAC_TX_LLFC_MSG_FIELDSr_s {
	uint32_t v[2];
	uint32_t xlmac_tx_llfc_msg_fields[2];
	uint32_t _xlmac_tx_llfc_msg_fields;
} XLMAC_TX_LLFC_MSG_FIELDSr_t;

#define XLMAC_TX_LLFC_MSG_FIELDSr_CLR(r) sal_memset(&((r)._xlmac_tx_llfc_msg_fields), 0, sizeof(XLMAC_TX_LLFC_MSG_FIELDSr_t))
#define XLMAC_TX_LLFC_MSG_FIELDSr_SET(r,i,d) (r).xlmac_tx_llfc_msg_fields[i] = d
#define XLMAC_TX_LLFC_MSG_FIELDSr_GET(r,i) (r).xlmac_tx_llfc_msg_fields[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_MSG_TYPE_LOGICALf_GET(r) (((r).xlmac_tx_llfc_msg_fields[0]) & 0xff)
#define XLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_MSG_TYPE_LOGICALf_SET(r,f) (r).xlmac_tx_llfc_msg_fields[0]=(((r).xlmac_tx_llfc_msg_fields[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define XLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_FC_OBJ_LOGICALf_GET(r) ((((r).xlmac_tx_llfc_msg_fields[0]) >> 8) & 0xf)
#define XLMAC_TX_LLFC_MSG_FIELDSr_TX_LLFC_FC_OBJ_LOGICALf_SET(r,f) (r).xlmac_tx_llfc_msg_fields[0]=(((r).xlmac_tx_llfc_msg_fields[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define XLMAC_TX_LLFC_MSG_FIELDSr_LLFC_XOFF_TIMEf_GET(r) ((((r).xlmac_tx_llfc_msg_fields[0]) >> 12) & 0xffff)
#define XLMAC_TX_LLFC_MSG_FIELDSr_LLFC_XOFF_TIMEf_SET(r,f) (r).xlmac_tx_llfc_msg_fields[0]=(((r).xlmac_tx_llfc_msg_fields[0] & ~((uint32_t)0xffff << 12)) | ((((uint32_t)f) & 0xffff) << 12))

/*
 * These macros can be used to access XLMAC_TX_LLFC_MSG_FIELDS.
 */
#define READ_XLMAC_TX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TX_LLFC_MSG_FIELDSr_OFFSET,0,XLMAC_TX_LLFC_MSG_FIELDSr_SIZE,(r._xlmac_tx_llfc_msg_fields))
#define WRITE_XLMAC_TX_LLFC_MSG_FIELDSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TX_LLFC_MSG_FIELDSr_OFFSET,0,XLMAC_TX_LLFC_MSG_FIELDSr_SIZE,&(r._xlmac_tx_llfc_msg_fields))

/*******************************************************************************
 * End of 'XLMAC_TX_LLFC_MSG_FIELDSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TX_MAC_SA
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TX_MAC_SAr_OFFSET 0x10060500

#define XLMAC_TX_MAC_SAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_MAC_SA.
 */
typedef union XLMAC_TX_MAC_SAr_s {
	uint32_t v[2];
	uint32_t xlmac_tx_mac_sa[2];
	uint32_t _xlmac_tx_mac_sa;
} XLMAC_TX_MAC_SAr_t;

#define XLMAC_TX_MAC_SAr_CLR(r) sal_memset(&((r)._xlmac_tx_mac_sa), 0, sizeof(XLMAC_TX_MAC_SAr_t))
#define XLMAC_TX_MAC_SAr_SET(r,i,d) (r).xlmac_tx_mac_sa[i] = d
#define XLMAC_TX_MAC_SAr_GET(r,i) (r).xlmac_tx_mac_sa[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_MAC_SAr_CTRL_SAf_GET(r,a) bcmpmac_field_get((r).xlmac_tx_mac_sa,0,47,a)
#define XLMAC_TX_MAC_SAr_CTRL_SAf_SET(r,a) bcmpmac_field_set((r).xlmac_tx_mac_sa,0,47,a)
#define XLMAC_TX_MAC_SAr_SA_LOf_GET(r) ((r).xlmac_tx_mac_sa[0])
#define XLMAC_TX_MAC_SAr_SA_LOf_SET(r,f) (r).xlmac_tx_mac_sa[0]=((uint32_t)f)
#define XLMAC_TX_MAC_SAr_SA_HIf_GET(r) (((r).xlmac_tx_mac_sa[1]) & 0xffff)
#define XLMAC_TX_MAC_SAr_SA_HIf_SET(r,f) (r).xlmac_tx_mac_sa[1]=(((r).xlmac_tx_mac_sa[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_TX_MAC_SA.
 */
#define READ_XLMAC_TX_MAC_SAr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TX_MAC_SAr_OFFSET,0,XLMAC_TX_MAC_SAr_SIZE,(r._xlmac_tx_mac_sa))
#define WRITE_XLMAC_TX_MAC_SAr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TX_MAC_SAr_OFFSET,0,XLMAC_TX_MAC_SAr_SIZE,&(r._xlmac_tx_mac_sa))

/*******************************************************************************
 * End of 'XLMAC_TX_MAC_SAr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TX_TIMESTAMP_FIFO_DATA
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_OFFSET 0x10061500

#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
typedef union XLMAC_TX_TIMESTAMP_FIFO_DATAr_s {
	uint32_t v[2];
	uint32_t xlmac_tx_timestamp_fifo_data[2];
	uint32_t _xlmac_tx_timestamp_fifo_data;
} XLMAC_TX_TIMESTAMP_FIFO_DATAr_t;

#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_CLR(r) sal_memset(&((r)._xlmac_tx_timestamp_fifo_data), 0, sizeof(XLMAC_TX_TIMESTAMP_FIFO_DATAr_t))
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SET(r,i,d) (r).xlmac_tx_timestamp_fifo_data[i] = d
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_GET(r,i) (r).xlmac_tx_timestamp_fifo_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_GET(r) ((r).xlmac_tx_timestamp_fifo_data[0])
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TIME_STAMPf_SET(r,f) (r).xlmac_tx_timestamp_fifo_data[0]=((uint32_t)f)
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_GET(r) (((r).xlmac_tx_timestamp_fifo_data[1]) & 0xffff)
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_SEQUENCE_IDf_SET(r,f) (r).xlmac_tx_timestamp_fifo_data[1]=(((r).xlmac_tx_timestamp_fifo_data[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_GET(r) ((((r).xlmac_tx_timestamp_fifo_data[1]) >> 16) & 0x1)
#define XLMAC_TX_TIMESTAMP_FIFO_DATAr_TS_ENTRY_VALIDf_SET(r,f) (r).xlmac_tx_timestamp_fifo_data[1]=(((r).xlmac_tx_timestamp_fifo_data[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access XLMAC_TX_TIMESTAMP_FIFO_DATA.
 */
#define READ_XLMAC_TX_TIMESTAMP_FIFO_DATAr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TX_TIMESTAMP_FIFO_DATAr_OFFSET,0,XLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE,(r._xlmac_tx_timestamp_fifo_data))
#define WRITE_XLMAC_TX_TIMESTAMP_FIFO_DATAr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TX_TIMESTAMP_FIFO_DATAr_OFFSET,0,XLMAC_TX_TIMESTAMP_FIFO_DATAr_SIZE,&(r._xlmac_tx_timestamp_fifo_data))

/*******************************************************************************
 * End of 'XLMAC_TX_TIMESTAMP_FIFO_DATAr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_TX_TIMESTAMP_FIFO_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_OFFSET 0x10061600

#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
typedef union XLMAC_TX_TIMESTAMP_FIFO_STATUSr_s {
	uint32_t v[2];
	uint32_t xlmac_tx_timestamp_fifo_status[2];
	uint32_t _xlmac_tx_timestamp_fifo_status;
} XLMAC_TX_TIMESTAMP_FIFO_STATUSr_t;

#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_CLR(r) sal_memset(&((r)._xlmac_tx_timestamp_fifo_status), 0, sizeof(XLMAC_TX_TIMESTAMP_FIFO_STATUSr_t))
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_SET(r,i,d) (r).xlmac_tx_timestamp_fifo_status[i] = d
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_GET(r,i) (r).xlmac_tx_timestamp_fifo_status[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_GET(r) (((r).xlmac_tx_timestamp_fifo_status[0]) & 0x7)
#define XLMAC_TX_TIMESTAMP_FIFO_STATUSr_ENTRY_COUNTf_SET(r,f) (r).xlmac_tx_timestamp_fifo_status[0]=(((r).xlmac_tx_timestamp_fifo_status[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access XLMAC_TX_TIMESTAMP_FIFO_STATUS.
 */
#define READ_XLMAC_TX_TIMESTAMP_FIFO_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLMAC_TX_TIMESTAMP_FIFO_STATUSr_OFFSET,0,XLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE,(r._xlmac_tx_timestamp_fifo_status))
#define WRITE_XLMAC_TX_TIMESTAMP_FIFO_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLMAC_TX_TIMESTAMP_FIFO_STATUSr_OFFSET,0,XLMAC_TX_TIMESTAMP_FIFO_STATUSr_SIZE,&(r._xlmac_tx_timestamp_fifo_status))

/*******************************************************************************
 * End of 'XLMAC_TX_TIMESTAMP_FIFO_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLMAC_VERSION_ID
 * BLOCKS:   XLPORT
 * SIZE:     64
 */
#define XLMAC_VERSION_IDr_OFFSET 0x10063400

#define XLMAC_VERSION_IDr_SIZE 8

/*
 * This structure should be used to declare and program XLMAC_VERSION_ID.
 */
typedef union XLMAC_VERSION_IDr_s {
	uint32_t v[2];
	uint32_t xlmac_version_id[2];
	uint32_t _xlmac_version_id;
} XLMAC_VERSION_IDr_t;

#define XLMAC_VERSION_IDr_CLR(r) sal_memset(&((r)._xlmac_version_id), 0, sizeof(XLMAC_VERSION_IDr_t))
#define XLMAC_VERSION_IDr_SET(r,i,d) (r).xlmac_version_id[i] = d
#define XLMAC_VERSION_IDr_GET(r,i) (r).xlmac_version_id[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLMAC_VERSION_IDr_XLMAC_VERSIONf_GET(r) (((r).xlmac_version_id[0]) & 0xffff)
#define XLMAC_VERSION_IDr_XLMAC_VERSIONf_SET(r,f) (r).xlmac_version_id[0]=(((r).xlmac_version_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XLMAC_VERSION_ID.
 */
#define READ_XLMAC_VERSION_IDr(pa,p,r) bcmpmac_read(pa,p,XLMAC_VERSION_IDr_OFFSET,0,XLMAC_VERSION_IDr_SIZE,(r._xlmac_version_id))
#define WRITE_XLMAC_VERSION_IDr(pa,p,r) bcmpmac_write(pa,p,XLMAC_VERSION_IDr_OFFSET,0,XLMAC_VERSION_IDr_SIZE,&(r._xlmac_version_id))

/*******************************************************************************
 * End of 'XLMAC_VERSION_IDr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_CNTMAXSIZE
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_CNTMAXSIZEr_OFFSET 0x10020100

#define XLPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_CNTMAXSIZE.
 */
typedef union XLPORT_CNTMAXSIZEr_s {
	uint32_t v[1];
	uint32_t xlport_cntmaxsize[1];
	uint32_t _xlport_cntmaxsize;
} XLPORT_CNTMAXSIZEr_t;

#define XLPORT_CNTMAXSIZEr_CLR(r) (r).xlport_cntmaxsize[0] = 0
#define XLPORT_CNTMAXSIZEr_SET(r,d) (r).xlport_cntmaxsize[0] = d
#define XLPORT_CNTMAXSIZEr_GET(r) (r).xlport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).xlport_cntmaxsize[0]) & 0x3fff)
#define XLPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).xlport_cntmaxsize[0]=(((r).xlport_cntmaxsize[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access XLPORT_CNTMAXSIZE.
 */
#define READ_XLPORT_CNTMAXSIZEr(pa,p,r) bcmpmac_read(pa,p,XLPORT_CNTMAXSIZEr_OFFSET,0,XLPORT_CNTMAXSIZEr_SIZE,(r._xlport_cntmaxsize))
#define WRITE_XLPORT_CNTMAXSIZEr(pa,p,r) bcmpmac_write(pa,p,XLPORT_CNTMAXSIZEr_OFFSET,0,XLPORT_CNTMAXSIZEr_SIZE,&(r._xlport_cntmaxsize))

/*******************************************************************************
 * End of 'XLPORT_CNTMAXSIZEr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_CONFIG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_CONFIGr_OFFSET 0x10020000

#define XLPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_CONFIG.
 */
typedef union XLPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t xlport_config[1];
	uint32_t _xlport_config;
} XLPORT_CONFIGr_t;

#define XLPORT_CONFIGr_CLR(r) (r).xlport_config[0] = 0
#define XLPORT_CONFIGr_SET(r,d) (r).xlport_config[0] = d
#define XLPORT_CONFIGr_GET(r) (r).xlport_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_CONFIGr_RESERVED_0f_GET(r) (((r).xlport_config[0]) & 0x1)
#define XLPORT_CONFIGr_RESERVED_0f_SET(r,f) (r).xlport_config[0]=(((r).xlport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_CONFIGr_MY_MODIDf_GET(r) ((((r).xlport_config[0]) >> 1) & 0xff)
#define XLPORT_CONFIGr_MY_MODIDf_SET(r,f) (r).xlport_config[0]=(((r).xlport_config[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define XLPORT_CONFIGr_RESERVED_9f_GET(r) ((((r).xlport_config[0]) >> 9) & 0x1)
#define XLPORT_CONFIGr_RESERVED_9f_SET(r,f) (r).xlport_config[0]=(((r).xlport_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define XLPORT_CONFIGr_HIGIG_MODEf_GET(r) ((((r).xlport_config[0]) >> 10) & 0x1)
#define XLPORT_CONFIGr_HIGIG_MODEf_SET(r,f) (r).xlport_config[0]=(((r).xlport_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define XLPORT_CONFIGr_HIGIG2_MODEf_GET(r) ((((r).xlport_config[0]) >> 11) & 0x1)
#define XLPORT_CONFIGr_HIGIG2_MODEf_SET(r,f) (r).xlport_config[0]=(((r).xlport_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define XLPORT_CONFIGr_RESERVED_15_12f_GET(r) ((((r).xlport_config[0]) >> 12) & 0xf)
#define XLPORT_CONFIGr_RESERVED_15_12f_SET(r,f) (r).xlport_config[0]=(((r).xlport_config[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access XLPORT_CONFIG.
 */
#define READ_XLPORT_CONFIGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_CONFIGr_OFFSET,0,XLPORT_CONFIGr_SIZE,(r._xlport_config))
#define WRITE_XLPORT_CONFIGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_CONFIGr_OFFSET,0,XLPORT_CONFIGr_SIZE,&(r._xlport_config))

/*******************************************************************************
 * End of 'XLPORT_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_ECC_CONTROL
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_ECC_CONTROLr_OFFSET 0x00021a00

#define XLPORT_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_ECC_CONTROL.
 */
typedef union XLPORT_ECC_CONTROLr_s {
	uint32_t v[1];
	uint32_t xlport_ecc_control[1];
	uint32_t _xlport_ecc_control;
} XLPORT_ECC_CONTROLr_t;

#define XLPORT_ECC_CONTROLr_CLR(r) (r).xlport_ecc_control[0] = 0
#define XLPORT_ECC_CONTROLr_SET(r,d) (r).xlport_ecc_control[0] = d
#define XLPORT_ECC_CONTROLr_GET(r) (r).xlport_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_ECC_CONTROLr_MIB_TSC_MEM_ENf_GET(r) (((r).xlport_ecc_control[0]) & 0x1)
#define XLPORT_ECC_CONTROLr_MIB_TSC_MEM_ENf_SET(r,f) (r).xlport_ecc_control[0]=(((r).xlport_ecc_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_ECC_CONTROLr_MIB_TSC0_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).xlport_ecc_control[0]) >> 1) & 0x1)
#define XLPORT_ECC_CONTROLr_MIB_TSC0_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).xlport_ecc_control[0]=(((r).xlport_ecc_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_ECC_CONTROLr_MIB_TSC1_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).xlport_ecc_control[0]) >> 2) & 0x1)
#define XLPORT_ECC_CONTROLr_MIB_TSC1_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).xlport_ecc_control[0]=(((r).xlport_ecc_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_ECC_CONTROLr_MIB_RSC_MEM_ENf_GET(r) ((((r).xlport_ecc_control[0]) >> 3) & 0x1)
#define XLPORT_ECC_CONTROLr_MIB_RSC_MEM_ENf_SET(r,f) (r).xlport_ecc_control[0]=(((r).xlport_ecc_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLPORT_ECC_CONTROLr_MIB_RSC0_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).xlport_ecc_control[0]) >> 4) & 0x1)
#define XLPORT_ECC_CONTROLr_MIB_RSC0_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).xlport_ecc_control[0]=(((r).xlport_ecc_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLPORT_ECC_CONTROLr_MIB_RSC1_MEM_EN_COR_ERR_RPTf_GET(r) ((((r).xlport_ecc_control[0]) >> 5) & 0x1)
#define XLPORT_ECC_CONTROLr_MIB_RSC1_MEM_EN_COR_ERR_RPTf_SET(r,f) (r).xlport_ecc_control[0]=(((r).xlport_ecc_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access XLPORT_ECC_CONTROL.
 */
#define READ_XLPORT_ECC_CONTROLr(pa,p,r) bcmpmac_read(pa,p,XLPORT_ECC_CONTROLr_OFFSET,0,XLPORT_ECC_CONTROLr_SIZE,(r._xlport_ecc_control))
#define WRITE_XLPORT_ECC_CONTROLr(pa,p,r) bcmpmac_write(pa,p,XLPORT_ECC_CONTROLr_OFFSET,0,XLPORT_ECC_CONTROLr_SIZE,&(r._xlport_ecc_control))

/*******************************************************************************
 * End of 'XLPORT_ECC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_EEE_CLOCK_GATE
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_EEE_CLOCK_GATEr_OFFSET 0x00020e00

#define XLPORT_EEE_CLOCK_GATEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_EEE_CLOCK_GATE.
 */
typedef union XLPORT_EEE_CLOCK_GATEr_s {
	uint32_t v[1];
	uint32_t xlport_eee_clock_gate[1];
	uint32_t _xlport_eee_clock_gate;
} XLPORT_EEE_CLOCK_GATEr_t;

#define XLPORT_EEE_CLOCK_GATEr_CLR(r) (r).xlport_eee_clock_gate[0] = 0
#define XLPORT_EEE_CLOCK_GATEr_SET(r,d) (r).xlport_eee_clock_gate[0] = d
#define XLPORT_EEE_CLOCK_GATEr_GET(r) (r).xlport_eee_clock_gate[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_EEE_CLOCK_GATEr_CORE0f_GET(r) (((r).xlport_eee_clock_gate[0]) & 0x1)
#define XLPORT_EEE_CLOCK_GATEr_CORE0f_SET(r,f) (r).xlport_eee_clock_gate[0]=(((r).xlport_eee_clock_gate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XLPORT_EEE_CLOCK_GATE.
 */
#define READ_XLPORT_EEE_CLOCK_GATEr(pa,p,r) bcmpmac_read(pa,p,XLPORT_EEE_CLOCK_GATEr_OFFSET,0,XLPORT_EEE_CLOCK_GATEr_SIZE,(r._xlport_eee_clock_gate))
#define WRITE_XLPORT_EEE_CLOCK_GATEr(pa,p,r) bcmpmac_write(pa,p,XLPORT_EEE_CLOCK_GATEr_OFFSET,0,XLPORT_EEE_CLOCK_GATEr_SIZE,&(r._xlport_eee_clock_gate))

/*******************************************************************************
 * End of 'XLPORT_EEE_CLOCK_GATEr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_EEE_CORE0_CLOCK_GATE_COUNTER
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_OFFSET 0x00020f00

#define XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_EEE_CORE0_CLOCK_GATE_COUNTER.
 */
typedef union XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_s {
	uint32_t v[1];
	uint32_t xlport_eee_core0_clock_gate_counter[1];
	uint32_t _xlport_eee_core0_clock_gate_counter;
} XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_t;

#define XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_CLR(r) (r).xlport_eee_core0_clock_gate_counter[0] = 0
#define XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SET(r,d) (r).xlport_eee_core0_clock_gate_counter[0] = d
#define XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_GET(r) (r).xlport_eee_core0_clock_gate_counter[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_COUNTf_GET(r) ((r).xlport_eee_core0_clock_gate_counter[0])
#define XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_COUNTf_SET(r,f) (r).xlport_eee_core0_clock_gate_counter[0]=((uint32_t)f)

/*
 * These macros can be used to access XLPORT_EEE_CORE0_CLOCK_GATE_COUNTER.
 */
#define READ_XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr(pa,p,r) bcmpmac_read(pa,p,XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_OFFSET,0,XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SIZE,(r._xlport_eee_core0_clock_gate_counter))
#define WRITE_XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr(pa,p,r) bcmpmac_write(pa,p,XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_OFFSET,0,XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr_SIZE,&(r._xlport_eee_core0_clock_gate_counter))

/*******************************************************************************
 * End of 'XLPORT_EEE_CORE0_CLOCK_GATE_COUNTERr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_EEE_COUNTER_MODE
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_EEE_COUNTER_MODEr_OFFSET 0x10020300

#define XLPORT_EEE_COUNTER_MODEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_EEE_COUNTER_MODE.
 */
typedef union XLPORT_EEE_COUNTER_MODEr_s {
	uint32_t v[1];
	uint32_t xlport_eee_counter_mode[1];
	uint32_t _xlport_eee_counter_mode;
} XLPORT_EEE_COUNTER_MODEr_t;

#define XLPORT_EEE_COUNTER_MODEr_CLR(r) (r).xlport_eee_counter_mode[0] = 0
#define XLPORT_EEE_COUNTER_MODEr_SET(r,d) (r).xlport_eee_counter_mode[0] = d
#define XLPORT_EEE_COUNTER_MODEr_GET(r) (r).xlport_eee_counter_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_EEE_COUNTER_MODEr_MODE_BITf_GET(r) (((r).xlport_eee_counter_mode[0]) & 0x1)
#define XLPORT_EEE_COUNTER_MODEr_MODE_BITf_SET(r,f) (r).xlport_eee_counter_mode[0]=(((r).xlport_eee_counter_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XLPORT_EEE_COUNTER_MODE.
 */
#define READ_XLPORT_EEE_COUNTER_MODEr(pa,p,r) bcmpmac_read(pa,p,XLPORT_EEE_COUNTER_MODEr_OFFSET,0,XLPORT_EEE_COUNTER_MODEr_SIZE,(r._xlport_eee_counter_mode))
#define WRITE_XLPORT_EEE_COUNTER_MODEr(pa,p,r) bcmpmac_write(pa,p,XLPORT_EEE_COUNTER_MODEr_OFFSET,0,XLPORT_EEE_COUNTER_MODEr_SIZE,&(r._xlport_eee_counter_mode))

/*******************************************************************************
 * End of 'XLPORT_EEE_COUNTER_MODEr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_EEE_DURATION_TIMER_PULSE
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_EEE_DURATION_TIMER_PULSEr_OFFSET 0x00021200

#define XLPORT_EEE_DURATION_TIMER_PULSEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_EEE_DURATION_TIMER_PULSE.
 */
typedef union XLPORT_EEE_DURATION_TIMER_PULSEr_s {
	uint32_t v[1];
	uint32_t xlport_eee_duration_timer_pulse[1];
	uint32_t _xlport_eee_duration_timer_pulse;
} XLPORT_EEE_DURATION_TIMER_PULSEr_t;

#define XLPORT_EEE_DURATION_TIMER_PULSEr_CLR(r) (r).xlport_eee_duration_timer_pulse[0] = 0
#define XLPORT_EEE_DURATION_TIMER_PULSEr_SET(r,d) (r).xlport_eee_duration_timer_pulse[0] = d
#define XLPORT_EEE_DURATION_TIMER_PULSEr_GET(r) (r).xlport_eee_duration_timer_pulse[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_EEE_DURATION_TIMER_PULSEr_CNT_VALUEf_GET(r) (((r).xlport_eee_duration_timer_pulse[0]) & 0xff)
#define XLPORT_EEE_DURATION_TIMER_PULSEr_CNT_VALUEf_SET(r,f) (r).xlport_eee_duration_timer_pulse[0]=(((r).xlport_eee_duration_timer_pulse[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access XLPORT_EEE_DURATION_TIMER_PULSE.
 */
#define READ_XLPORT_EEE_DURATION_TIMER_PULSEr(pa,p,r) bcmpmac_read(pa,p,XLPORT_EEE_DURATION_TIMER_PULSEr_OFFSET,0,XLPORT_EEE_DURATION_TIMER_PULSEr_SIZE,(r._xlport_eee_duration_timer_pulse))
#define WRITE_XLPORT_EEE_DURATION_TIMER_PULSEr(pa,p,r) bcmpmac_write(pa,p,XLPORT_EEE_DURATION_TIMER_PULSEr_OFFSET,0,XLPORT_EEE_DURATION_TIMER_PULSEr_SIZE,&(r._xlport_eee_duration_timer_pulse))

/*******************************************************************************
 * End of 'XLPORT_EEE_DURATION_TIMER_PULSEr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_ENABLE_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_ENABLE_REGr_OFFSET 0x00020b00

#define XLPORT_ENABLE_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_ENABLE_REG.
 */
typedef union XLPORT_ENABLE_REGr_s {
	uint32_t v[1];
	uint32_t xlport_enable_reg[1];
	uint32_t _xlport_enable_reg;
} XLPORT_ENABLE_REGr_t;

#define XLPORT_ENABLE_REGr_CLR(r) (r).xlport_enable_reg[0] = 0
#define XLPORT_ENABLE_REGr_SET(r,d) (r).xlport_enable_reg[0] = d
#define XLPORT_ENABLE_REGr_GET(r) (r).xlport_enable_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_ENABLE_REGr_PORT0f_GET(r) (((r).xlport_enable_reg[0]) & 0x1)
#define XLPORT_ENABLE_REGr_PORT0f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_ENABLE_REGr_PORT1f_GET(r) ((((r).xlport_enable_reg[0]) >> 1) & 0x1)
#define XLPORT_ENABLE_REGr_PORT1f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_ENABLE_REGr_PORT2f_GET(r) ((((r).xlport_enable_reg[0]) >> 2) & 0x1)
#define XLPORT_ENABLE_REGr_PORT2f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_ENABLE_REGr_PORT3f_GET(r) ((((r).xlport_enable_reg[0]) >> 3) & 0x1)
#define XLPORT_ENABLE_REGr_PORT3f_SET(r,f) (r).xlport_enable_reg[0]=(((r).xlport_enable_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access XLPORT_ENABLE_REG.
 */
#define READ_XLPORT_ENABLE_REGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_ENABLE_REGr_OFFSET,0,XLPORT_ENABLE_REGr_SIZE,(r._xlport_enable_reg))
#define WRITE_XLPORT_ENABLE_REGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_ENABLE_REGr_OFFSET,0,XLPORT_ENABLE_REGr_SIZE,&(r._xlport_enable_reg))

/*******************************************************************************
 * End of 'XLPORT_ENABLE_REGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_FAULT_LINK_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_FAULT_LINK_STATUSr_OFFSET 0x10020500

#define XLPORT_FAULT_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_FAULT_LINK_STATUS.
 */
typedef union XLPORT_FAULT_LINK_STATUSr_s {
	uint32_t v[1];
	uint32_t xlport_fault_link_status[1];
	uint32_t _xlport_fault_link_status;
} XLPORT_FAULT_LINK_STATUSr_t;

#define XLPORT_FAULT_LINK_STATUSr_CLR(r) (r).xlport_fault_link_status[0] = 0
#define XLPORT_FAULT_LINK_STATUSr_SET(r,d) (r).xlport_fault_link_status[0] = d
#define XLPORT_FAULT_LINK_STATUSr_GET(r) (r).xlport_fault_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_GET(r) (((r).xlport_fault_link_status[0]) & 0x1)
#define XLPORT_FAULT_LINK_STATUSr_REMOTE_FAULTf_SET(r,f) (r).xlport_fault_link_status[0]=(((r).xlport_fault_link_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_GET(r) ((((r).xlport_fault_link_status[0]) >> 1) & 0x1)
#define XLPORT_FAULT_LINK_STATUSr_LOCAL_FAULTf_SET(r,f) (r).xlport_fault_link_status[0]=(((r).xlport_fault_link_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLPORT_FAULT_LINK_STATUS.
 */
#define READ_XLPORT_FAULT_LINK_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLPORT_FAULT_LINK_STATUSr_OFFSET,0,XLPORT_FAULT_LINK_STATUSr_SIZE,(r._xlport_fault_link_status))
#define WRITE_XLPORT_FAULT_LINK_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLPORT_FAULT_LINK_STATUSr_OFFSET,0,XLPORT_FAULT_LINK_STATUSr_SIZE,&(r._xlport_fault_link_status))

/*******************************************************************************
 * End of 'XLPORT_FAULT_LINK_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_FLOW_CONTROL_CONFIG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_FLOW_CONTROL_CONFIGr_OFFSET 0x10020700

#define XLPORT_FLOW_CONTROL_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_FLOW_CONTROL_CONFIG.
 */
typedef union XLPORT_FLOW_CONTROL_CONFIGr_s {
	uint32_t v[1];
	uint32_t xlport_flow_control_config[1];
	uint32_t _xlport_flow_control_config;
} XLPORT_FLOW_CONTROL_CONFIGr_t;

#define XLPORT_FLOW_CONTROL_CONFIGr_CLR(r) (r).xlport_flow_control_config[0] = 0
#define XLPORT_FLOW_CONTROL_CONFIGr_SET(r,d) (r).xlport_flow_control_config[0] = d
#define XLPORT_FLOW_CONTROL_CONFIGr_GET(r) (r).xlport_flow_control_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_FLOW_CONTROL_CONFIGr_PARALLEL_FC_ENf_GET(r) (((r).xlport_flow_control_config[0]) & 0x1)
#define XLPORT_FLOW_CONTROL_CONFIGr_PARALLEL_FC_ENf_SET(r,f) (r).xlport_flow_control_config[0]=(((r).xlport_flow_control_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_FLOW_CONTROL_CONFIGr_MERGE_MODE_ENf_GET(r) ((((r).xlport_flow_control_config[0]) >> 1) & 0x1)
#define XLPORT_FLOW_CONTROL_CONFIGr_MERGE_MODE_ENf_SET(r,f) (r).xlport_flow_control_config[0]=(((r).xlport_flow_control_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLPORT_FLOW_CONTROL_CONFIG.
 */
#define READ_XLPORT_FLOW_CONTROL_CONFIGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_FLOW_CONTROL_CONFIGr_OFFSET,0,XLPORT_FLOW_CONTROL_CONFIGr_SIZE,(r._xlport_flow_control_config))
#define WRITE_XLPORT_FLOW_CONTROL_CONFIGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_FLOW_CONTROL_CONFIGr_OFFSET,0,XLPORT_FLOW_CONTROL_CONFIGr_SIZE,&(r._xlport_flow_control_config))

/*******************************************************************************
 * End of 'XLPORT_FLOW_CONTROL_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_FORCE_DOUBLE_BIT_ERROR
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_OFFSET 0x00021b00

#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_FORCE_DOUBLE_BIT_ERROR.
 */
typedef union XLPORT_FORCE_DOUBLE_BIT_ERRORr_s {
	uint32_t v[1];
	uint32_t xlport_force_double_bit_error[1];
	uint32_t _xlport_force_double_bit_error;
} XLPORT_FORCE_DOUBLE_BIT_ERRORr_t;

#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_CLR(r) (r).xlport_force_double_bit_error[0] = 0
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_SET(r,d) (r).xlport_force_double_bit_error[0] = d
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_GET(r) (r).xlport_force_double_bit_error[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC0_MEMf_GET(r) (((r).xlport_force_double_bit_error[0]) & 0x1)
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC0_MEMf_SET(r,f) (r).xlport_force_double_bit_error[0]=(((r).xlport_force_double_bit_error[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC1_MEMf_GET(r) ((((r).xlport_force_double_bit_error[0]) >> 1) & 0x1)
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_TSC1_MEMf_SET(r,f) (r).xlport_force_double_bit_error[0]=(((r).xlport_force_double_bit_error[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC0_MEMf_GET(r) ((((r).xlport_force_double_bit_error[0]) >> 2) & 0x1)
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC0_MEMf_SET(r,f) (r).xlport_force_double_bit_error[0]=(((r).xlport_force_double_bit_error[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC1_MEMf_GET(r) ((((r).xlport_force_double_bit_error[0]) >> 3) & 0x1)
#define XLPORT_FORCE_DOUBLE_BIT_ERRORr_MIB_RSC1_MEMf_SET(r,f) (r).xlport_force_double_bit_error[0]=(((r).xlport_force_double_bit_error[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access XLPORT_FORCE_DOUBLE_BIT_ERROR.
 */
#define READ_XLPORT_FORCE_DOUBLE_BIT_ERRORr(pa,p,r) bcmpmac_read(pa,p,XLPORT_FORCE_DOUBLE_BIT_ERRORr_OFFSET,0,XLPORT_FORCE_DOUBLE_BIT_ERRORr_SIZE,(r._xlport_force_double_bit_error))
#define WRITE_XLPORT_FORCE_DOUBLE_BIT_ERRORr(pa,p,r) bcmpmac_write(pa,p,XLPORT_FORCE_DOUBLE_BIT_ERRORr_OFFSET,0,XLPORT_FORCE_DOUBLE_BIT_ERRORr_SIZE,&(r._xlport_force_double_bit_error))

/*******************************************************************************
 * End of 'XLPORT_FORCE_DOUBLE_BIT_ERRORr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_FORCE_SINGLE_BIT_ERROR
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_OFFSET 0x00021c00

#define XLPORT_FORCE_SINGLE_BIT_ERRORr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_FORCE_SINGLE_BIT_ERROR.
 */
typedef union XLPORT_FORCE_SINGLE_BIT_ERRORr_s {
	uint32_t v[1];
	uint32_t xlport_force_single_bit_error[1];
	uint32_t _xlport_force_single_bit_error;
} XLPORT_FORCE_SINGLE_BIT_ERRORr_t;

#define XLPORT_FORCE_SINGLE_BIT_ERRORr_CLR(r) (r).xlport_force_single_bit_error[0] = 0
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_SET(r,d) (r).xlport_force_single_bit_error[0] = d
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_GET(r) (r).xlport_force_single_bit_error[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC0_MEMf_GET(r) (((r).xlport_force_single_bit_error[0]) & 0x1)
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC0_MEMf_SET(r,f) (r).xlport_force_single_bit_error[0]=(((r).xlport_force_single_bit_error[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC1_MEMf_GET(r) ((((r).xlport_force_single_bit_error[0]) >> 1) & 0x1)
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_TSC1_MEMf_SET(r,f) (r).xlport_force_single_bit_error[0]=(((r).xlport_force_single_bit_error[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC0_MEMf_GET(r) ((((r).xlport_force_single_bit_error[0]) >> 2) & 0x1)
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC0_MEMf_SET(r,f) (r).xlport_force_single_bit_error[0]=(((r).xlport_force_single_bit_error[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC1_MEMf_GET(r) ((((r).xlport_force_single_bit_error[0]) >> 3) & 0x1)
#define XLPORT_FORCE_SINGLE_BIT_ERRORr_MIB_RSC1_MEMf_SET(r,f) (r).xlport_force_single_bit_error[0]=(((r).xlport_force_single_bit_error[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access XLPORT_FORCE_SINGLE_BIT_ERROR.
 */
#define READ_XLPORT_FORCE_SINGLE_BIT_ERRORr(pa,p,r) bcmpmac_read(pa,p,XLPORT_FORCE_SINGLE_BIT_ERRORr_OFFSET,0,XLPORT_FORCE_SINGLE_BIT_ERRORr_SIZE,(r._xlport_force_single_bit_error))
#define WRITE_XLPORT_FORCE_SINGLE_BIT_ERRORr(pa,p,r) bcmpmac_write(pa,p,XLPORT_FORCE_SINGLE_BIT_ERRORr_OFFSET,0,XLPORT_FORCE_SINGLE_BIT_ERRORr_SIZE,&(r._xlport_force_single_bit_error))

/*******************************************************************************
 * End of 'XLPORT_FORCE_SINGLE_BIT_ERRORr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_INTR_ENABLE
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_INTR_ENABLEr_OFFSET 0x00022a00

#define XLPORT_INTR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_INTR_ENABLE.
 */
typedef union XLPORT_INTR_ENABLEr_s {
	uint32_t v[1];
	uint32_t xlport_intr_enable[1];
	uint32_t _xlport_intr_enable;
} XLPORT_INTR_ENABLEr_t;

#define XLPORT_INTR_ENABLEr_CLR(r) (r).xlport_intr_enable[0] = 0
#define XLPORT_INTR_ENABLEr_SET(r,d) (r).xlport_intr_enable[0] = d
#define XLPORT_INTR_ENABLEr_GET(r) (r).xlport_intr_enable[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_INTR_ENABLEr_MIB_TX_MEM_ERRf_GET(r) (((r).xlport_intr_enable[0]) & 0x1)
#define XLPORT_INTR_ENABLEr_MIB_TX_MEM_ERRf_SET(r,f) (r).xlport_intr_enable[0]=(((r).xlport_intr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_INTR_ENABLEr_MIB_RX_MEM_ERRf_GET(r) ((((r).xlport_intr_enable[0]) >> 1) & 0x1)
#define XLPORT_INTR_ENABLEr_MIB_RX_MEM_ERRf_SET(r,f) (r).xlport_intr_enable[0]=(((r).xlport_intr_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_INTR_ENABLEr_MAC_TX_CDC_MEM_ERRf_GET(r) ((((r).xlport_intr_enable[0]) >> 2) & 0x1)
#define XLPORT_INTR_ENABLEr_MAC_TX_CDC_MEM_ERRf_SET(r,f) (r).xlport_intr_enable[0]=(((r).xlport_intr_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_INTR_ENABLEr_MAC_RX_CDC_MEM_ERRf_GET(r) ((((r).xlport_intr_enable[0]) >> 3) & 0x1)
#define XLPORT_INTR_ENABLEr_MAC_RX_CDC_MEM_ERRf_SET(r,f) (r).xlport_intr_enable[0]=(((r).xlport_intr_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLPORT_INTR_ENABLEr_TSC_ERRf_GET(r) ((((r).xlport_intr_enable[0]) >> 4) & 0x1)
#define XLPORT_INTR_ENABLEr_TSC_ERRf_SET(r,f) (r).xlport_intr_enable[0]=(((r).xlport_intr_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLPORT_INTR_ENABLEr_RX_FLOWCONTROL_REQ_FULLf_GET(r) ((((r).xlport_intr_enable[0]) >> 5) & 0xf)
#define XLPORT_INTR_ENABLEr_RX_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).xlport_intr_enable[0]=(((r).xlport_intr_enable[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))

/*
 * These macros can be used to access XLPORT_INTR_ENABLE.
 */
#define READ_XLPORT_INTR_ENABLEr(pa,p,r) bcmpmac_read(pa,p,XLPORT_INTR_ENABLEr_OFFSET,0,XLPORT_INTR_ENABLEr_SIZE,(r._xlport_intr_enable))
#define WRITE_XLPORT_INTR_ENABLEr(pa,p,r) bcmpmac_write(pa,p,XLPORT_INTR_ENABLEr_OFFSET,0,XLPORT_INTR_ENABLEr_SIZE,&(r._xlport_intr_enable))

/*******************************************************************************
 * End of 'XLPORT_INTR_ENABLEr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_INTR_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_INTR_STATUSr_OFFSET 0x00022900

#define XLPORT_INTR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_INTR_STATUS.
 */
typedef union XLPORT_INTR_STATUSr_s {
	uint32_t v[1];
	uint32_t xlport_intr_status[1];
	uint32_t _xlport_intr_status;
} XLPORT_INTR_STATUSr_t;

#define XLPORT_INTR_STATUSr_CLR(r) (r).xlport_intr_status[0] = 0
#define XLPORT_INTR_STATUSr_SET(r,d) (r).xlport_intr_status[0] = d
#define XLPORT_INTR_STATUSr_GET(r) (r).xlport_intr_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_INTR_STATUSr_MIB_TX_MEM_ERRf_GET(r) (((r).xlport_intr_status[0]) & 0x1)
#define XLPORT_INTR_STATUSr_MIB_TX_MEM_ERRf_SET(r,f) (r).xlport_intr_status[0]=(((r).xlport_intr_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_INTR_STATUSr_MIB_RX_MEM_ERRf_GET(r) ((((r).xlport_intr_status[0]) >> 1) & 0x1)
#define XLPORT_INTR_STATUSr_MIB_RX_MEM_ERRf_SET(r,f) (r).xlport_intr_status[0]=(((r).xlport_intr_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_INTR_STATUSr_MAC_TX_CDC_MEM_ERRf_GET(r) ((((r).xlport_intr_status[0]) >> 2) & 0x1)
#define XLPORT_INTR_STATUSr_MAC_TX_CDC_MEM_ERRf_SET(r,f) (r).xlport_intr_status[0]=(((r).xlport_intr_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_INTR_STATUSr_MAC_RX_CDC_MEM_ERRf_GET(r) ((((r).xlport_intr_status[0]) >> 3) & 0x1)
#define XLPORT_INTR_STATUSr_MAC_RX_CDC_MEM_ERRf_SET(r,f) (r).xlport_intr_status[0]=(((r).xlport_intr_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLPORT_INTR_STATUSr_TSC_ERRf_GET(r) ((((r).xlport_intr_status[0]) >> 4) & 0x1)
#define XLPORT_INTR_STATUSr_TSC_ERRf_SET(r,f) (r).xlport_intr_status[0]=(((r).xlport_intr_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define XLPORT_INTR_STATUSr_RX_FLOWCONTROL_REQ_FULLf_GET(r) ((((r).xlport_intr_status[0]) >> 5) & 0xf)
#define XLPORT_INTR_STATUSr_RX_FLOWCONTROL_REQ_FULLf_SET(r,f) (r).xlport_intr_status[0]=(((r).xlport_intr_status[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5))

/*
 * These macros can be used to access XLPORT_INTR_STATUS.
 */
#define READ_XLPORT_INTR_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLPORT_INTR_STATUSr_OFFSET,0,XLPORT_INTR_STATUSr_SIZE,(r._xlport_intr_status))
#define WRITE_XLPORT_INTR_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLPORT_INTR_STATUSr_OFFSET,0,XLPORT_INTR_STATUSr_SIZE,&(r._xlport_intr_status))

/*******************************************************************************
 * End of 'XLPORT_INTR_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_LAG_FAILOVER_CONFIG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_LAG_FAILOVER_CONFIGr_OFFSET 0x10020200

#define XLPORT_LAG_FAILOVER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_LAG_FAILOVER_CONFIG.
 */
typedef union XLPORT_LAG_FAILOVER_CONFIGr_s {
	uint32_t v[1];
	uint32_t xlport_lag_failover_config[1];
	uint32_t _xlport_lag_failover_config;
} XLPORT_LAG_FAILOVER_CONFIGr_t;

#define XLPORT_LAG_FAILOVER_CONFIGr_CLR(r) (r).xlport_lag_failover_config[0] = 0
#define XLPORT_LAG_FAILOVER_CONFIGr_SET(r,d) (r).xlport_lag_failover_config[0] = d
#define XLPORT_LAG_FAILOVER_CONFIGr_GET(r) (r).xlport_lag_failover_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_GET(r) (((r).xlport_lag_failover_config[0]) & 0x1)
#define XLPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_SET(r,f) (r).xlport_lag_failover_config[0]=(((r).xlport_lag_failover_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XLPORT_LAG_FAILOVER_CONFIG.
 */
#define READ_XLPORT_LAG_FAILOVER_CONFIGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_LAG_FAILOVER_CONFIGr_OFFSET,0,XLPORT_LAG_FAILOVER_CONFIGr_SIZE,(r._xlport_lag_failover_config))
#define WRITE_XLPORT_LAG_FAILOVER_CONFIGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_LAG_FAILOVER_CONFIGr_OFFSET,0,XLPORT_LAG_FAILOVER_CONFIGr_SIZE,&(r._xlport_lag_failover_config))

/*******************************************************************************
 * End of 'XLPORT_LAG_FAILOVER_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_LED_CHAIN_CONFIG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_LED_CHAIN_CONFIGr_OFFSET 0x00022300

#define XLPORT_LED_CHAIN_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_LED_CHAIN_CONFIG.
 */
typedef union XLPORT_LED_CHAIN_CONFIGr_s {
	uint32_t v[1];
	uint32_t xlport_led_chain_config[1];
	uint32_t _xlport_led_chain_config;
} XLPORT_LED_CHAIN_CONFIGr_t;

#define XLPORT_LED_CHAIN_CONFIGr_CLR(r) (r).xlport_led_chain_config[0] = 0
#define XLPORT_LED_CHAIN_CONFIGr_SET(r,d) (r).xlport_led_chain_config[0] = d
#define XLPORT_LED_CHAIN_CONFIGr_GET(r) (r).xlport_led_chain_config[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_LED_CHAIN_CONFIGr_INTRA_DELAYf_GET(r) (((r).xlport_led_chain_config[0]) & 0xf)
#define XLPORT_LED_CHAIN_CONFIGr_INTRA_DELAYf_SET(r,f) (r).xlport_led_chain_config[0]=(((r).xlport_led_chain_config[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access XLPORT_LED_CHAIN_CONFIG.
 */
#define READ_XLPORT_LED_CHAIN_CONFIGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_LED_CHAIN_CONFIGr_OFFSET,0,XLPORT_LED_CHAIN_CONFIGr_SIZE,(r._xlport_led_chain_config))
#define WRITE_XLPORT_LED_CHAIN_CONFIGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_LED_CHAIN_CONFIGr_OFFSET,0,XLPORT_LED_CHAIN_CONFIGr_SIZE,&(r._xlport_led_chain_config))

/*******************************************************************************
 * End of 'XLPORT_LED_CHAIN_CONFIGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_LINKSTATUS_DOWN
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_LINKSTATUS_DOWNr_OFFSET 0x00022700

#define XLPORT_LINKSTATUS_DOWNr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_LINKSTATUS_DOWN.
 */
typedef union XLPORT_LINKSTATUS_DOWNr_s {
	uint32_t v[1];
	uint32_t xlport_linkstatus_down[1];
	uint32_t _xlport_linkstatus_down;
} XLPORT_LINKSTATUS_DOWNr_t;

#define XLPORT_LINKSTATUS_DOWNr_CLR(r) (r).xlport_linkstatus_down[0] = 0
#define XLPORT_LINKSTATUS_DOWNr_SET(r,d) (r).xlport_linkstatus_down[0] = d
#define XLPORT_LINKSTATUS_DOWNr_GET(r) (r).xlport_linkstatus_down[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_LINKSTATUS_DOWNr_PORT0_LINKSTATUSf_GET(r) (((r).xlport_linkstatus_down[0]) & 0x1)
#define XLPORT_LINKSTATUS_DOWNr_PORT0_LINKSTATUSf_SET(r,f) (r).xlport_linkstatus_down[0]=(((r).xlport_linkstatus_down[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_LINKSTATUS_DOWNr_PORT1_LINKSTATUSf_GET(r) ((((r).xlport_linkstatus_down[0]) >> 1) & 0x1)
#define XLPORT_LINKSTATUS_DOWNr_PORT1_LINKSTATUSf_SET(r,f) (r).xlport_linkstatus_down[0]=(((r).xlport_linkstatus_down[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_LINKSTATUS_DOWNr_PORT2_LINKSTATUSf_GET(r) ((((r).xlport_linkstatus_down[0]) >> 2) & 0x1)
#define XLPORT_LINKSTATUS_DOWNr_PORT2_LINKSTATUSf_SET(r,f) (r).xlport_linkstatus_down[0]=(((r).xlport_linkstatus_down[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_LINKSTATUS_DOWNr_PORT3_LINKSTATUSf_GET(r) ((((r).xlport_linkstatus_down[0]) >> 3) & 0x1)
#define XLPORT_LINKSTATUS_DOWNr_PORT3_LINKSTATUSf_SET(r,f) (r).xlport_linkstatus_down[0]=(((r).xlport_linkstatus_down[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access XLPORT_LINKSTATUS_DOWN.
 */
#define READ_XLPORT_LINKSTATUS_DOWNr(pa,p,r) bcmpmac_read(pa,p,XLPORT_LINKSTATUS_DOWNr_OFFSET,0,XLPORT_LINKSTATUS_DOWNr_SIZE,(r._xlport_linkstatus_down))
#define WRITE_XLPORT_LINKSTATUS_DOWNr(pa,p,r) bcmpmac_write(pa,p,XLPORT_LINKSTATUS_DOWNr_OFFSET,0,XLPORT_LINKSTATUS_DOWNr_SIZE,&(r._xlport_linkstatus_down))

/*******************************************************************************
 * End of 'XLPORT_LINKSTATUS_DOWNr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_LINKSTATUS_DOWN_CLEAR
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_LINKSTATUS_DOWN_CLEARr_OFFSET 0x00022800

#define XLPORT_LINKSTATUS_DOWN_CLEARr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_LINKSTATUS_DOWN_CLEAR.
 */
typedef union XLPORT_LINKSTATUS_DOWN_CLEARr_s {
	uint32_t v[1];
	uint32_t xlport_linkstatus_down_clear[1];
	uint32_t _xlport_linkstatus_down_clear;
} XLPORT_LINKSTATUS_DOWN_CLEARr_t;

#define XLPORT_LINKSTATUS_DOWN_CLEARr_CLR(r) (r).xlport_linkstatus_down_clear[0] = 0
#define XLPORT_LINKSTATUS_DOWN_CLEARr_SET(r,d) (r).xlport_linkstatus_down_clear[0] = d
#define XLPORT_LINKSTATUS_DOWN_CLEARr_GET(r) (r).xlport_linkstatus_down_clear[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT0_LINKDOWN_CLEARf_GET(r) (((r).xlport_linkstatus_down_clear[0]) & 0x1)
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT0_LINKDOWN_CLEARf_SET(r,f) (r).xlport_linkstatus_down_clear[0]=(((r).xlport_linkstatus_down_clear[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT1_LINKDOWN_CLEARf_GET(r) ((((r).xlport_linkstatus_down_clear[0]) >> 1) & 0x1)
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT1_LINKDOWN_CLEARf_SET(r,f) (r).xlport_linkstatus_down_clear[0]=(((r).xlport_linkstatus_down_clear[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT2_LINKDOWN_CLEARf_GET(r) ((((r).xlport_linkstatus_down_clear[0]) >> 2) & 0x1)
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT2_LINKDOWN_CLEARf_SET(r,f) (r).xlport_linkstatus_down_clear[0]=(((r).xlport_linkstatus_down_clear[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT3_LINKDOWN_CLEARf_GET(r) ((((r).xlport_linkstatus_down_clear[0]) >> 3) & 0x1)
#define XLPORT_LINKSTATUS_DOWN_CLEARr_PORT3_LINKDOWN_CLEARf_SET(r,f) (r).xlport_linkstatus_down_clear[0]=(((r).xlport_linkstatus_down_clear[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access XLPORT_LINKSTATUS_DOWN_CLEAR.
 */
#define READ_XLPORT_LINKSTATUS_DOWN_CLEARr(pa,p,r) bcmpmac_read(pa,p,XLPORT_LINKSTATUS_DOWN_CLEARr_OFFSET,0,XLPORT_LINKSTATUS_DOWN_CLEARr_SIZE,(r._xlport_linkstatus_down_clear))
#define WRITE_XLPORT_LINKSTATUS_DOWN_CLEARr(pa,p,r) bcmpmac_write(pa,p,XLPORT_LINKSTATUS_DOWN_CLEARr_OFFSET,0,XLPORT_LINKSTATUS_DOWN_CLEARr_SIZE,&(r._xlport_linkstatus_down_clear))

/*******************************************************************************
 * End of 'XLPORT_LINKSTATUS_DOWN_CLEARr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MAC_CONTROL
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MAC_CONTROLr_OFFSET 0x00021000

#define XLPORT_MAC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MAC_CONTROL.
 */
typedef union XLPORT_MAC_CONTROLr_s {
	uint32_t v[1];
	uint32_t xlport_mac_control[1];
	uint32_t _xlport_mac_control;
} XLPORT_MAC_CONTROLr_t;

#define XLPORT_MAC_CONTROLr_CLR(r) (r).xlport_mac_control[0] = 0
#define XLPORT_MAC_CONTROLr_SET(r,d) (r).xlport_mac_control[0] = d
#define XLPORT_MAC_CONTROLr_GET(r) (r).xlport_mac_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MAC_CONTROLr_XMAC0_RESETf_GET(r) (((r).xlport_mac_control[0]) & 0x1)
#define XLPORT_MAC_CONTROLr_XMAC0_RESETf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_GET(r) ((((r).xlport_mac_control[0]) >> 1) & 0x1)
#define XLPORT_MAC_CONTROLr_XMAC0_BYPASS_OSTSf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_GET(r) ((((r).xlport_mac_control[0]) >> 2) & 0x1)
#define XLPORT_MAC_CONTROLr_RX_FLEX_TDM_ENABLEf_SET(r,f) (r).xlport_mac_control[0]=(((r).xlport_mac_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access XLPORT_MAC_CONTROL.
 */
#define READ_XLPORT_MAC_CONTROLr(pa,p,r) bcmpmac_read(pa,p,XLPORT_MAC_CONTROLr_OFFSET,0,XLPORT_MAC_CONTROLr_SIZE,(r._xlport_mac_control))
#define WRITE_XLPORT_MAC_CONTROLr(pa,p,r) bcmpmac_write(pa,p,XLPORT_MAC_CONTROLr_OFFSET,0,XLPORT_MAC_CONTROLr_SIZE,&(r._xlport_mac_control))

/*******************************************************************************
 * End of 'XLPORT_MAC_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MAC_RSV_MASK
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MAC_RSV_MASKr_OFFSET 0x10020800

#define XLPORT_MAC_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MAC_RSV_MASK.
 */
typedef union XLPORT_MAC_RSV_MASKr_s {
	uint32_t v[1];
	uint32_t xlport_mac_rsv_mask[1];
	uint32_t _xlport_mac_rsv_mask;
} XLPORT_MAC_RSV_MASKr_t;

#define XLPORT_MAC_RSV_MASKr_CLR(r) (r).xlport_mac_rsv_mask[0] = 0
#define XLPORT_MAC_RSV_MASKr_SET(r,d) (r).xlport_mac_rsv_mask[0] = d
#define XLPORT_MAC_RSV_MASKr_GET(r) (r).xlport_mac_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MAC_RSV_MASKr_MASKf_GET(r) ((r).xlport_mac_rsv_mask[0])
#define XLPORT_MAC_RSV_MASKr_MASKf_SET(r,f) (r).xlport_mac_rsv_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access XLPORT_MAC_RSV_MASK.
 */
#define READ_XLPORT_MAC_RSV_MASKr(pa,p,r) bcmpmac_read(pa,p,XLPORT_MAC_RSV_MASKr_OFFSET,0,XLPORT_MAC_RSV_MASKr_SIZE,(r._xlport_mac_rsv_mask))
#define WRITE_XLPORT_MAC_RSV_MASKr(pa,p,r) bcmpmac_write(pa,p,XLPORT_MAC_RSV_MASKr_OFFSET,0,XLPORT_MAC_RSV_MASKr_SIZE,&(r._xlport_mac_rsv_mask))

/*******************************************************************************
 * End of 'XLPORT_MAC_RSV_MASKr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MIB_RESET
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_RESETr_OFFSET 0x00022400

#define XLPORT_MIB_RESETr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MIB_RESET.
 */
typedef union XLPORT_MIB_RESETr_s {
	uint32_t v[1];
	uint32_t xlport_mib_reset[1];
	uint32_t _xlport_mib_reset;
} XLPORT_MIB_RESETr_t;

#define XLPORT_MIB_RESETr_CLR(r) (r).xlport_mib_reset[0] = 0
#define XLPORT_MIB_RESETr_SET(r,d) (r).xlport_mib_reset[0] = d
#define XLPORT_MIB_RESETr_GET(r) (r).xlport_mib_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MIB_RESETr_CLR_CNTf_GET(r) (((r).xlport_mib_reset[0]) & 0xf)
#define XLPORT_MIB_RESETr_CLR_CNTf_SET(r,f) (r).xlport_mib_reset[0]=(((r).xlport_mib_reset[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access XLPORT_MIB_RESET.
 */
#define READ_XLPORT_MIB_RESETr(pa,p,r) bcmpmac_read(pa,p,XLPORT_MIB_RESETr_OFFSET,0,XLPORT_MIB_RESETr_SIZE,(r._xlport_mib_reset))
#define WRITE_XLPORT_MIB_RESETr(pa,p,r) bcmpmac_write(pa,p,XLPORT_MIB_RESETr_OFFSET,0,XLPORT_MIB_RESETr_SIZE,&(r._xlport_mib_reset))

/*******************************************************************************
 * End of 'XLPORT_MIB_RESETr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MIB_RSC0_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_RSC0_ECC_STATUSr_OFFSET 0x00021d00

#define XLPORT_MIB_RSC0_ECC_STATUSr_SIZE 4

/* XLPORT_MIB_RSC0_ECC_STATUSr is element of XLPORT_MIB_RSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  XLPORT_MIB_RSC1_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_RSC1_ECC_STATUSr_OFFSET 0x00021e00

#define XLPORT_MIB_RSC1_ECC_STATUSr_SIZE 4

/* XLPORT_MIB_RSC1_ECC_STATUSr is element of XLPORT_MIB_RSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  XLPORT_MIB_RSC_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_RSC_ECC_STATUSr_OFFSET 0x00021d00

#define XLPORT_MIB_RSC_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MIB_RSC_ECC_STATUS.
 */
typedef union XLPORT_MIB_RSC_ECC_STATUSr_s {
	uint32_t v[1];
	uint32_t xlport_mib_rsc_ecc_status[1];
	uint32_t _xlport_mib_rsc_ecc_status;
} XLPORT_MIB_RSC_ECC_STATUSr_t;

#define XLPORT_MIB_RSC_ECC_STATUSr_CLR(r) (r).xlport_mib_rsc_ecc_status[0] = 0
#define XLPORT_MIB_RSC_ECC_STATUSr_SET(r,d) (r).xlport_mib_rsc_ecc_status[0] = d
#define XLPORT_MIB_RSC_ECC_STATUSr_GET(r) (r).xlport_mib_rsc_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MIB_RSC_ECC_STATUSr_ECC_ERRf_GET(r) (((r).xlport_mib_rsc_ecc_status[0]) & 0x1)
#define XLPORT_MIB_RSC_ECC_STATUSr_ECC_ERRf_SET(r,f) (r).xlport_mib_rsc_ecc_status[0]=(((r).xlport_mib_rsc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_MIB_RSC_ECC_STATUSr_MULTIPLE_ERRf_GET(r) ((((r).xlport_mib_rsc_ecc_status[0]) >> 1) & 0x1)
#define XLPORT_MIB_RSC_ECC_STATUSr_MULTIPLE_ERRf_SET(r,f) (r).xlport_mib_rsc_ecc_status[0]=(((r).xlport_mib_rsc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_MIB_RSC_ECC_STATUSr_DOUBLE_BIT_ERRf_GET(r) ((((r).xlport_mib_rsc_ecc_status[0]) >> 2) & 0x1)
#define XLPORT_MIB_RSC_ECC_STATUSr_DOUBLE_BIT_ERRf_SET(r,f) (r).xlport_mib_rsc_ecc_status[0]=(((r).xlport_mib_rsc_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_MIB_RSC_ECC_STATUSr_ENTRY_IDXf_GET(r) ((((r).xlport_mib_rsc_ecc_status[0]) >> 3) & 0xff)
#define XLPORT_MIB_RSC_ECC_STATUSr_ENTRY_IDXf_SET(r,f) (r).xlport_mib_rsc_ecc_status[0]=(((r).xlport_mib_rsc_ecc_status[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))

/*
 * These macros can be used to access XLPORT_MIB_RSC_ECC_STATUS.
 */
#define READ_XLPORT_MIB_RSC_ECC_STATUSr(pa,p,i,r) bcmpmac_read(pa,p,XLPORT_MIB_RSC_ECC_STATUSr_OFFSET,i,XLPORT_MIB_RSC_ECC_STATUSr_SIZE,(r._xlport_mib_rsc_ecc_status))
#define WRITE_XLPORT_MIB_RSC_ECC_STATUSr(pa,p,i,r) bcmpmac_write(pa,p,XLPORT_MIB_RSC_ECC_STATUSr_OFFSET,i,XLPORT_MIB_RSC_ECC_STATUSr_SIZE,&(r._xlport_mib_rsc_ecc_status))

/*******************************************************************************
 * End of 'XLPORT_MIB_RSC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MIB_RSC_RAM_CONTROL
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_RSC_RAM_CONTROLr_OFFSET 0x00022200

#define XLPORT_MIB_RSC_RAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MIB_RSC_RAM_CONTROL.
 */
typedef union XLPORT_MIB_RSC_RAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t xlport_mib_rsc_ram_control[1];
	uint32_t _xlport_mib_rsc_ram_control;
} XLPORT_MIB_RSC_RAM_CONTROLr_t;

#define XLPORT_MIB_RSC_RAM_CONTROLr_CLR(r) (r).xlport_mib_rsc_ram_control[0] = 0
#define XLPORT_MIB_RSC_RAM_CONTROLr_SET(r,d) (r).xlport_mib_rsc_ram_control[0] = d
#define XLPORT_MIB_RSC_RAM_CONTROLr_GET(r) (r).xlport_mib_rsc_ram_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_TMf_GET(r) (((r).xlport_mib_rsc_ram_control[0]) & 0xfff)
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_TMf_SET(r,f) (r).xlport_mib_rsc_ram_control[0]=(((r).xlport_mib_rsc_ram_control[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_TMf_GET(r) ((((r).xlport_mib_rsc_ram_control[0]) >> 12) & 0xfff)
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_TMf_SET(r,f) (r).xlport_mib_rsc_ram_control[0]=(((r).xlport_mib_rsc_ram_control[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_LVMf_GET(r) ((((r).xlport_mib_rsc_ram_control[0]) >> 24) & 0x1)
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_LO_LVMf_SET(r,f) (r).xlport_mib_rsc_ram_control[0]=(((r).xlport_mib_rsc_ram_control[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_LVMf_GET(r) ((((r).xlport_mib_rsc_ram_control[0]) >> 25) & 0x1)
#define XLPORT_MIB_RSC_RAM_CONTROLr_MIB_RSC_DATA_HI_LVMf_SET(r,f) (r).xlport_mib_rsc_ram_control[0]=(((r).xlport_mib_rsc_ram_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access XLPORT_MIB_RSC_RAM_CONTROL.
 */
#define READ_XLPORT_MIB_RSC_RAM_CONTROLr(pa,p,r) bcmpmac_read(pa,p,XLPORT_MIB_RSC_RAM_CONTROLr_OFFSET,0,XLPORT_MIB_RSC_RAM_CONTROLr_SIZE,(r._xlport_mib_rsc_ram_control))
#define WRITE_XLPORT_MIB_RSC_RAM_CONTROLr(pa,p,r) bcmpmac_write(pa,p,XLPORT_MIB_RSC_RAM_CONTROLr_OFFSET,0,XLPORT_MIB_RSC_RAM_CONTROLr_SIZE,&(r._xlport_mib_rsc_ram_control))

/*******************************************************************************
 * End of 'XLPORT_MIB_RSC_RAM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MIB_TSC0_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_TSC0_ECC_STATUSr_OFFSET 0x00021f00

#define XLPORT_MIB_TSC0_ECC_STATUSr_SIZE 4

/* XLPORT_MIB_TSC0_ECC_STATUSr is element of XLPORT_MIB_TSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  XLPORT_MIB_TSC1_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_TSC1_ECC_STATUSr_OFFSET 0x00022000

#define XLPORT_MIB_TSC1_ECC_STATUSr_SIZE 4

/* XLPORT_MIB_TSC1_ECC_STATUSr is element of XLPORT_MIB_TSC_ECC_STATUS */

/*******************************************************************************
 * REGISTER:  XLPORT_MIB_TSC_ECC_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_TSC_ECC_STATUSr_OFFSET 0x00021f00

#define XLPORT_MIB_TSC_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MIB_TSC_ECC_STATUS.
 */
typedef union XLPORT_MIB_TSC_ECC_STATUSr_s {
	uint32_t v[1];
	uint32_t xlport_mib_tsc_ecc_status[1];
	uint32_t _xlport_mib_tsc_ecc_status;
} XLPORT_MIB_TSC_ECC_STATUSr_t;

#define XLPORT_MIB_TSC_ECC_STATUSr_CLR(r) (r).xlport_mib_tsc_ecc_status[0] = 0
#define XLPORT_MIB_TSC_ECC_STATUSr_SET(r,d) (r).xlport_mib_tsc_ecc_status[0] = d
#define XLPORT_MIB_TSC_ECC_STATUSr_GET(r) (r).xlport_mib_tsc_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MIB_TSC_ECC_STATUSr_ECC_ERRf_GET(r) (((r).xlport_mib_tsc_ecc_status[0]) & 0x1)
#define XLPORT_MIB_TSC_ECC_STATUSr_ECC_ERRf_SET(r,f) (r).xlport_mib_tsc_ecc_status[0]=(((r).xlport_mib_tsc_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_MIB_TSC_ECC_STATUSr_MULTIPLE_ERRf_GET(r) ((((r).xlport_mib_tsc_ecc_status[0]) >> 1) & 0x1)
#define XLPORT_MIB_TSC_ECC_STATUSr_MULTIPLE_ERRf_SET(r,f) (r).xlport_mib_tsc_ecc_status[0]=(((r).xlport_mib_tsc_ecc_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_MIB_TSC_ECC_STATUSr_DOUBLE_BIT_ERRf_GET(r) ((((r).xlport_mib_tsc_ecc_status[0]) >> 2) & 0x1)
#define XLPORT_MIB_TSC_ECC_STATUSr_DOUBLE_BIT_ERRf_SET(r,f) (r).xlport_mib_tsc_ecc_status[0]=(((r).xlport_mib_tsc_ecc_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_MIB_TSC_ECC_STATUSr_ENTRY_IDXf_GET(r) ((((r).xlport_mib_tsc_ecc_status[0]) >> 3) & 0xff)
#define XLPORT_MIB_TSC_ECC_STATUSr_ENTRY_IDXf_SET(r,f) (r).xlport_mib_tsc_ecc_status[0]=(((r).xlport_mib_tsc_ecc_status[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))

/*
 * These macros can be used to access XLPORT_MIB_TSC_ECC_STATUS.
 */
#define READ_XLPORT_MIB_TSC_ECC_STATUSr(pa,p,i,r) bcmpmac_read(pa,p,XLPORT_MIB_TSC_ECC_STATUSr_OFFSET,i,XLPORT_MIB_TSC_ECC_STATUSr_SIZE,(r._xlport_mib_tsc_ecc_status))
#define WRITE_XLPORT_MIB_TSC_ECC_STATUSr(pa,p,i,r) bcmpmac_write(pa,p,XLPORT_MIB_TSC_ECC_STATUSr_OFFSET,i,XLPORT_MIB_TSC_ECC_STATUSr_SIZE,&(r._xlport_mib_tsc_ecc_status))

/*******************************************************************************
 * End of 'XLPORT_MIB_TSC_ECC_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MIB_TSC_RAM_CONTROL
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MIB_TSC_RAM_CONTROLr_OFFSET 0x00022100

#define XLPORT_MIB_TSC_RAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MIB_TSC_RAM_CONTROL.
 */
typedef union XLPORT_MIB_TSC_RAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t xlport_mib_tsc_ram_control[1];
	uint32_t _xlport_mib_tsc_ram_control;
} XLPORT_MIB_TSC_RAM_CONTROLr_t;

#define XLPORT_MIB_TSC_RAM_CONTROLr_CLR(r) (r).xlport_mib_tsc_ram_control[0] = 0
#define XLPORT_MIB_TSC_RAM_CONTROLr_SET(r,d) (r).xlport_mib_tsc_ram_control[0] = d
#define XLPORT_MIB_TSC_RAM_CONTROLr_GET(r) (r).xlport_mib_tsc_ram_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_TMf_GET(r) (((r).xlport_mib_tsc_ram_control[0]) & 0xfff)
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_TMf_SET(r,f) (r).xlport_mib_tsc_ram_control[0]=(((r).xlport_mib_tsc_ram_control[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_TMf_GET(r) ((((r).xlport_mib_tsc_ram_control[0]) >> 12) & 0xfff)
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_TMf_SET(r,f) (r).xlport_mib_tsc_ram_control[0]=(((r).xlport_mib_tsc_ram_control[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_LVMf_GET(r) ((((r).xlport_mib_tsc_ram_control[0]) >> 24) & 0x1)
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_LO_LVMf_SET(r,f) (r).xlport_mib_tsc_ram_control[0]=(((r).xlport_mib_tsc_ram_control[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_LVMf_GET(r) ((((r).xlport_mib_tsc_ram_control[0]) >> 25) & 0x1)
#define XLPORT_MIB_TSC_RAM_CONTROLr_MIB_TSC_DATA_HI_LVMf_SET(r,f) (r).xlport_mib_tsc_ram_control[0]=(((r).xlport_mib_tsc_ram_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access XLPORT_MIB_TSC_RAM_CONTROL.
 */
#define READ_XLPORT_MIB_TSC_RAM_CONTROLr(pa,p,r) bcmpmac_read(pa,p,XLPORT_MIB_TSC_RAM_CONTROLr_OFFSET,0,XLPORT_MIB_TSC_RAM_CONTROLr_SIZE,(r._xlport_mib_tsc_ram_control))
#define WRITE_XLPORT_MIB_TSC_RAM_CONTROLr(pa,p,r) bcmpmac_write(pa,p,XLPORT_MIB_TSC_RAM_CONTROLr_OFFSET,0,XLPORT_MIB_TSC_RAM_CONTROLr_SIZE,&(r._xlport_mib_tsc_ram_control))

/*******************************************************************************
 * End of 'XLPORT_MIB_TSC_RAM_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_MODE_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_MODE_REGr_OFFSET 0x00020a00

#define XLPORT_MODE_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_MODE_REG.
 */
typedef union XLPORT_MODE_REGr_s {
	uint32_t v[1];
	uint32_t xlport_mode_reg[1];
	uint32_t _xlport_mode_reg;
} XLPORT_MODE_REGr_t;

#define XLPORT_MODE_REGr_CLR(r) (r).xlport_mode_reg[0] = 0
#define XLPORT_MODE_REGr_SET(r,d) (r).xlport_mode_reg[0] = d
#define XLPORT_MODE_REGr_GET(r) (r).xlport_mode_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_GET(r) (((r).xlport_mode_reg[0]) & 0x7)
#define XLPORT_MODE_REGr_XPORT0_PHY_PORT_MODEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define XLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_GET(r) ((((r).xlport_mode_reg[0]) >> 3) & 0x7)
#define XLPORT_MODE_REGr_XPORT0_CORE_PORT_MODEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_GET(r) ((((r).xlport_mode_reg[0]) >> 6) & 0x1)
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_MODEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define XLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_GET(r) ((((r).xlport_mode_reg[0]) >> 7) & 0x1)
#define XLPORT_MODE_REGr_OSTS_TIMER_DISABLEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define XLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_GET(r) ((((r).xlport_mode_reg[0]) >> 8) & 0x1)
#define XLPORT_MODE_REGr_TS_TIMER_OVERRIDEf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_GET(r) ((((r).xlport_mode_reg[0]) >> 9) & 0x1)
#define XLPORT_MODE_REGr_EGR_1588_TIMESTAMPING_CMIC_48_ENf_SET(r,f) (r).xlport_mode_reg[0]=(((r).xlport_mode_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access XLPORT_MODE_REG.
 */
#define READ_XLPORT_MODE_REGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_MODE_REGr_OFFSET,0,XLPORT_MODE_REGr_SIZE,(r._xlport_mode_reg))
#define WRITE_XLPORT_MODE_REGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_MODE_REGr_OFFSET,0,XLPORT_MODE_REGr_SIZE,&(r._xlport_mode_reg))

/*******************************************************************************
 * End of 'XLPORT_MODE_REGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_POWER_SAVE
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_POWER_SAVEr_OFFSET 0x00020d00

#define XLPORT_POWER_SAVEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_POWER_SAVE.
 */
typedef union XLPORT_POWER_SAVEr_s {
	uint32_t v[1];
	uint32_t xlport_power_save[1];
	uint32_t _xlport_power_save;
} XLPORT_POWER_SAVEr_t;

#define XLPORT_POWER_SAVEr_CLR(r) (r).xlport_power_save[0] = 0
#define XLPORT_POWER_SAVEr_SET(r,d) (r).xlport_power_save[0] = d
#define XLPORT_POWER_SAVEr_GET(r) (r).xlport_power_save[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_POWER_SAVEr_XPORT_CORE0f_GET(r) (((r).xlport_power_save[0]) & 0x1)
#define XLPORT_POWER_SAVEr_XPORT_CORE0f_SET(r,f) (r).xlport_power_save[0]=(((r).xlport_power_save[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XLPORT_POWER_SAVE.
 */
#define READ_XLPORT_POWER_SAVEr(pa,p,r) bcmpmac_read(pa,p,XLPORT_POWER_SAVEr_OFFSET,0,XLPORT_POWER_SAVEr_SIZE,(r._xlport_power_save))
#define WRITE_XLPORT_POWER_SAVEr(pa,p,r) bcmpmac_write(pa,p,XLPORT_POWER_SAVEr_OFFSET,0,XLPORT_POWER_SAVEr_SIZE,&(r._xlport_power_save))

/*******************************************************************************
 * End of 'XLPORT_POWER_SAVEr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_SBUS_CONTROL
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_SBUS_CONTROLr_OFFSET 0x00022b00

#define XLPORT_SBUS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_SBUS_CONTROL.
 */
typedef union XLPORT_SBUS_CONTROLr_s {
	uint32_t v[1];
	uint32_t xlport_sbus_control[1];
	uint32_t _xlport_sbus_control;
} XLPORT_SBUS_CONTROLr_t;

#define XLPORT_SBUS_CONTROLr_CLR(r) (r).xlport_sbus_control[0] = 0
#define XLPORT_SBUS_CONTROLr_SET(r,d) (r).xlport_sbus_control[0] = d
#define XLPORT_SBUS_CONTROLr_GET(r) (r).xlport_sbus_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_SBUS_CONTROLr_SBUS_BCAST_BLOCK_IDf_GET(r) (((r).xlport_sbus_control[0]) & 0x7f)
#define XLPORT_SBUS_CONTROLr_SBUS_BCAST_BLOCK_IDf_SET(r,f) (r).xlport_sbus_control[0]=(((r).xlport_sbus_control[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define XLPORT_SBUS_CONTROLr_SBUS_CHAIN_LASTf_GET(r) ((((r).xlport_sbus_control[0]) >> 7) & 0x1)
#define XLPORT_SBUS_CONTROLr_SBUS_CHAIN_LASTf_SET(r,f) (r).xlport_sbus_control[0]=(((r).xlport_sbus_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access XLPORT_SBUS_CONTROL.
 */
#define READ_XLPORT_SBUS_CONTROLr(pa,p,r) bcmpmac_read(pa,p,XLPORT_SBUS_CONTROLr_OFFSET,0,XLPORT_SBUS_CONTROLr_SIZE,(r._xlport_sbus_control))
#define WRITE_XLPORT_SBUS_CONTROLr(pa,p,r) bcmpmac_write(pa,p,XLPORT_SBUS_CONTROLr_OFFSET,0,XLPORT_SBUS_CONTROLr_SIZE,&(r._xlport_sbus_control))

/*******************************************************************************
 * End of 'XLPORT_SBUS_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_SGNDET_EARLYCRS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_SGNDET_EARLYCRSr_OFFSET 0x10020400

#define XLPORT_SGNDET_EARLYCRSr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_SGNDET_EARLYCRS.
 */
typedef union XLPORT_SGNDET_EARLYCRSr_s {
	uint32_t v[1];
	uint32_t xlport_sgndet_earlycrs[1];
	uint32_t _xlport_sgndet_earlycrs;
} XLPORT_SGNDET_EARLYCRSr_t;

#define XLPORT_SGNDET_EARLYCRSr_CLR(r) (r).xlport_sgndet_earlycrs[0] = 0
#define XLPORT_SGNDET_EARLYCRSr_SET(r,d) (r).xlport_sgndet_earlycrs[0] = d
#define XLPORT_SGNDET_EARLYCRSr_GET(r) (r).xlport_sgndet_earlycrs[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_SGNDET_EARLYCRSr_SGN_DETf_GET(r) (((r).xlport_sgndet_earlycrs[0]) & 0x1)
#define XLPORT_SGNDET_EARLYCRSr_SGN_DETf_SET(r,f) (r).xlport_sgndet_earlycrs[0]=(((r).xlport_sgndet_earlycrs[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XLPORT_SGNDET_EARLYCRS.
 */
#define READ_XLPORT_SGNDET_EARLYCRSr(pa,p,r) bcmpmac_read(pa,p,XLPORT_SGNDET_EARLYCRSr_OFFSET,0,XLPORT_SGNDET_EARLYCRSr_SIZE,(r._xlport_sgndet_earlycrs))
#define WRITE_XLPORT_SGNDET_EARLYCRSr(pa,p,r) bcmpmac_write(pa,p,XLPORT_SGNDET_EARLYCRSr_OFFSET,0,XLPORT_SGNDET_EARLYCRSr_SIZE,&(r._xlport_sgndet_earlycrs))

/*******************************************************************************
 * End of 'XLPORT_SGNDET_EARLYCRSr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_SOFT_RESET
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_SOFT_RESETr_OFFSET 0x00020c00

#define XLPORT_SOFT_RESETr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_SOFT_RESET.
 */
typedef union XLPORT_SOFT_RESETr_s {
	uint32_t v[1];
	uint32_t xlport_soft_reset[1];
	uint32_t _xlport_soft_reset;
} XLPORT_SOFT_RESETr_t;

#define XLPORT_SOFT_RESETr_CLR(r) (r).xlport_soft_reset[0] = 0
#define XLPORT_SOFT_RESETr_SET(r,d) (r).xlport_soft_reset[0] = d
#define XLPORT_SOFT_RESETr_GET(r) (r).xlport_soft_reset[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_SOFT_RESETr_PORT0f_GET(r) (((r).xlport_soft_reset[0]) & 0x1)
#define XLPORT_SOFT_RESETr_PORT0f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_SOFT_RESETr_PORT1f_GET(r) ((((r).xlport_soft_reset[0]) >> 1) & 0x1)
#define XLPORT_SOFT_RESETr_PORT1f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_SOFT_RESETr_PORT2f_GET(r) ((((r).xlport_soft_reset[0]) >> 2) & 0x1)
#define XLPORT_SOFT_RESETr_PORT2f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_SOFT_RESETr_PORT3f_GET(r) ((((r).xlport_soft_reset[0]) >> 3) & 0x1)
#define XLPORT_SOFT_RESETr_PORT3f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLPORT_SOFT_RESETr_RESERVED4f_GET(r) ((((r).xlport_soft_reset[0]) >> 4) & 0x1)
#define XLPORT_SOFT_RESETr_RESERVED4f_SET(r,f) (r).xlport_soft_reset[0]=(((r).xlport_soft_reset[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access XLPORT_SOFT_RESET.
 */
#define READ_XLPORT_SOFT_RESETr(pa,p,r) bcmpmac_read(pa,p,XLPORT_SOFT_RESETr_OFFSET,0,XLPORT_SOFT_RESETr_SIZE,(r._xlport_soft_reset))
#define WRITE_XLPORT_SOFT_RESETr(pa,p,r) bcmpmac_write(pa,p,XLPORT_SOFT_RESETr_OFFSET,0,XLPORT_SOFT_RESETr_SIZE,&(r._xlport_soft_reset))

/*******************************************************************************
 * End of 'XLPORT_SOFT_RESETr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_SPARE0_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_SPARE0_REGr_OFFSET 0x10020900

#define XLPORT_SPARE0_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_SPARE0_REG.
 */
typedef union XLPORT_SPARE0_REGr_s {
	uint32_t v[1];
	uint32_t xlport_spare0_reg[1];
	uint32_t _xlport_spare0_reg;
} XLPORT_SPARE0_REGr_t;

#define XLPORT_SPARE0_REGr_CLR(r) (r).xlport_spare0_reg[0] = 0
#define XLPORT_SPARE0_REGr_SET(r,d) (r).xlport_spare0_reg[0] = d
#define XLPORT_SPARE0_REGr_GET(r) (r).xlport_spare0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_SPARE0_REGr_RSVDf_GET(r) ((r).xlport_spare0_reg[0])
#define XLPORT_SPARE0_REGr_RSVDf_SET(r,f) (r).xlport_spare0_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access XLPORT_SPARE0_REG.
 */
#define READ_XLPORT_SPARE0_REGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_SPARE0_REGr_OFFSET,0,XLPORT_SPARE0_REGr_SIZE,(r._xlport_spare0_reg))
#define WRITE_XLPORT_SPARE0_REGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_SPARE0_REGr_OFFSET,0,XLPORT_SPARE0_REGr_SIZE,&(r._xlport_spare0_reg))

/*******************************************************************************
 * End of 'XLPORT_SPARE0_REGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_SW_FLOW_CONTROL
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_SW_FLOW_CONTROLr_OFFSET 0x10020600

#define XLPORT_SW_FLOW_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_SW_FLOW_CONTROL.
 */
typedef union XLPORT_SW_FLOW_CONTROLr_s {
	uint32_t v[1];
	uint32_t xlport_sw_flow_control[1];
	uint32_t _xlport_sw_flow_control;
} XLPORT_SW_FLOW_CONTROLr_t;

#define XLPORT_SW_FLOW_CONTROLr_CLR(r) (r).xlport_sw_flow_control[0] = 0
#define XLPORT_SW_FLOW_CONTROLr_SET(r,d) (r).xlport_sw_flow_control[0] = d
#define XLPORT_SW_FLOW_CONTROLr_GET(r) (r).xlport_sw_flow_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_SW_FLOW_CONTROLr_FC_PAUSEf_GET(r) (((r).xlport_sw_flow_control[0]) & 0x1)
#define XLPORT_SW_FLOW_CONTROLr_FC_PAUSEf_SET(r,f) (r).xlport_sw_flow_control[0]=(((r).xlport_sw_flow_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_SW_FLOW_CONTROLr_FC_ENf_GET(r) ((((r).xlport_sw_flow_control[0]) >> 1) & 0x1)
#define XLPORT_SW_FLOW_CONTROLr_FC_ENf_SET(r,f) (r).xlport_sw_flow_control[0]=(((r).xlport_sw_flow_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLPORT_SW_FLOW_CONTROL.
 */
#define READ_XLPORT_SW_FLOW_CONTROLr(pa,p,r) bcmpmac_read(pa,p,XLPORT_SW_FLOW_CONTROLr_OFFSET,0,XLPORT_SW_FLOW_CONTROLr_SIZE,(r._xlport_sw_flow_control))
#define WRITE_XLPORT_SW_FLOW_CONTROLr(pa,p,r) bcmpmac_write(pa,p,XLPORT_SW_FLOW_CONTROLr_OFFSET,0,XLPORT_SW_FLOW_CONTROLr_SIZE,&(r._xlport_sw_flow_control))

/*******************************************************************************
 * End of 'XLPORT_SW_FLOW_CONTROLr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_TSC_PLL_LOCK_STATUS
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_TSC_PLL_LOCK_STATUSr_OFFSET 0x00021300

#define XLPORT_TSC_PLL_LOCK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_TSC_PLL_LOCK_STATUS.
 */
typedef union XLPORT_TSC_PLL_LOCK_STATUSr_s {
	uint32_t v[1];
	uint32_t xlport_tsc_pll_lock_status[1];
	uint32_t _xlport_tsc_pll_lock_status;
} XLPORT_TSC_PLL_LOCK_STATUSr_t;

#define XLPORT_TSC_PLL_LOCK_STATUSr_CLR(r) (r).xlport_tsc_pll_lock_status[0] = 0
#define XLPORT_TSC_PLL_LOCK_STATUSr_SET(r,d) (r).xlport_tsc_pll_lock_status[0] = d
#define XLPORT_TSC_PLL_LOCK_STATUSr_GET(r) (r).xlport_tsc_pll_lock_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_TSC_PLL_LOCK_STATUSr_CURRENTf_GET(r) (((r).xlport_tsc_pll_lock_status[0]) & 0x1)
#define XLPORT_TSC_PLL_LOCK_STATUSr_CURRENTf_SET(r,f) (r).xlport_tsc_pll_lock_status[0]=(((r).xlport_tsc_pll_lock_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_TSC_PLL_LOCK_STATUSr_LOSTf_GET(r) ((((r).xlport_tsc_pll_lock_status[0]) >> 1) & 0x1)
#define XLPORT_TSC_PLL_LOCK_STATUSr_LOSTf_SET(r,f) (r).xlport_tsc_pll_lock_status[0]=(((r).xlport_tsc_pll_lock_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XLPORT_TSC_PLL_LOCK_STATUS.
 */
#define READ_XLPORT_TSC_PLL_LOCK_STATUSr(pa,p,r) bcmpmac_read(pa,p,XLPORT_TSC_PLL_LOCK_STATUSr_OFFSET,0,XLPORT_TSC_PLL_LOCK_STATUSr_SIZE,(r._xlport_tsc_pll_lock_status))
#define WRITE_XLPORT_TSC_PLL_LOCK_STATUSr(pa,p,r) bcmpmac_write(pa,p,XLPORT_TSC_PLL_LOCK_STATUSr_OFFSET,0,XLPORT_TSC_PLL_LOCK_STATUSr_SIZE,&(r._xlport_tsc_pll_lock_status))

/*******************************************************************************
 * End of 'XLPORT_TSC_PLL_LOCK_STATUSr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_TS_TIMER_31_0_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_TS_TIMER_31_0_REGr_OFFSET 0x00022600

#define XLPORT_TS_TIMER_31_0_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_TS_TIMER_31_0_REG.
 */
typedef union XLPORT_TS_TIMER_31_0_REGr_s {
	uint32_t v[1];
	uint32_t xlport_ts_timer_31_0_reg[1];
	uint32_t _xlport_ts_timer_31_0_reg;
} XLPORT_TS_TIMER_31_0_REGr_t;

#define XLPORT_TS_TIMER_31_0_REGr_CLR(r) (r).xlport_ts_timer_31_0_reg[0] = 0
#define XLPORT_TS_TIMER_31_0_REGr_SET(r,d) (r).xlport_ts_timer_31_0_reg[0] = d
#define XLPORT_TS_TIMER_31_0_REGr_GET(r) (r).xlport_ts_timer_31_0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_TS_TIMER_31_0_REGr_TS_TIMER_31_0_VALUEf_GET(r) ((r).xlport_ts_timer_31_0_reg[0])
#define XLPORT_TS_TIMER_31_0_REGr_TS_TIMER_31_0_VALUEf_SET(r,f) (r).xlport_ts_timer_31_0_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access XLPORT_TS_TIMER_31_0_REG.
 */
#define READ_XLPORT_TS_TIMER_31_0_REGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_TS_TIMER_31_0_REGr_OFFSET,0,XLPORT_TS_TIMER_31_0_REGr_SIZE,(r._xlport_ts_timer_31_0_reg))
#define WRITE_XLPORT_TS_TIMER_31_0_REGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_TS_TIMER_31_0_REGr_OFFSET,0,XLPORT_TS_TIMER_31_0_REGr_SIZE,&(r._xlport_ts_timer_31_0_reg))

/*******************************************************************************
 * End of 'XLPORT_TS_TIMER_31_0_REGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_TS_TIMER_47_32_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_TS_TIMER_47_32_REGr_OFFSET 0x00022500

#define XLPORT_TS_TIMER_47_32_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_TS_TIMER_47_32_REG.
 */
typedef union XLPORT_TS_TIMER_47_32_REGr_s {
	uint32_t v[1];
	uint32_t xlport_ts_timer_47_32_reg[1];
	uint32_t _xlport_ts_timer_47_32_reg;
} XLPORT_TS_TIMER_47_32_REGr_t;

#define XLPORT_TS_TIMER_47_32_REGr_CLR(r) (r).xlport_ts_timer_47_32_reg[0] = 0
#define XLPORT_TS_TIMER_47_32_REGr_SET(r,d) (r).xlport_ts_timer_47_32_reg[0] = d
#define XLPORT_TS_TIMER_47_32_REGr_GET(r) (r).xlport_ts_timer_47_32_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_TS_TIMER_47_32_REGr_TS_TIMER_47_32_VALUEf_GET(r) (((r).xlport_ts_timer_47_32_reg[0]) & 0xffff)
#define XLPORT_TS_TIMER_47_32_REGr_TS_TIMER_47_32_VALUEf_SET(r,f) (r).xlport_ts_timer_47_32_reg[0]=(((r).xlport_ts_timer_47_32_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XLPORT_TS_TIMER_47_32_REG.
 */
#define READ_XLPORT_TS_TIMER_47_32_REGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_TS_TIMER_47_32_REGr_OFFSET,0,XLPORT_TS_TIMER_47_32_REGr_SIZE,(r._xlport_ts_timer_47_32_reg))
#define WRITE_XLPORT_TS_TIMER_47_32_REGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_TS_TIMER_47_32_REGr_OFFSET,0,XLPORT_TS_TIMER_47_32_REGr_SIZE,&(r._xlport_ts_timer_47_32_reg))

/*******************************************************************************
 * End of 'XLPORT_TS_TIMER_47_32_REGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_WC_UCMEM_CTRL
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_WC_UCMEM_CTRLr_OFFSET 0x00021900

#define XLPORT_WC_UCMEM_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_WC_UCMEM_CTRL.
 */
typedef union XLPORT_WC_UCMEM_CTRLr_s {
	uint32_t v[1];
	uint32_t xlport_wc_ucmem_ctrl[1];
	uint32_t _xlport_wc_ucmem_ctrl;
} XLPORT_WC_UCMEM_CTRLr_t;

#define XLPORT_WC_UCMEM_CTRLr_CLR(r) (r).xlport_wc_ucmem_ctrl[0] = 0
#define XLPORT_WC_UCMEM_CTRLr_SET(r,d) (r).xlport_wc_ucmem_ctrl[0] = d
#define XLPORT_WC_UCMEM_CTRLr_GET(r) (r).xlport_wc_ucmem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_GET(r) (((r).xlport_wc_ucmem_ctrl[0]) & 0x1)
#define XLPORT_WC_UCMEM_CTRLr_ACCESS_MODEf_SET(r,f) (r).xlport_wc_ucmem_ctrl[0]=(((r).xlport_wc_ucmem_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_WC_UCMEM_CTRLr_RSVD3_1f_GET(r) ((((r).xlport_wc_ucmem_ctrl[0]) >> 1) & 0x7)
#define XLPORT_WC_UCMEM_CTRLr_RSVD3_1f_SET(r,f) (r).xlport_wc_ucmem_ctrl[0]=(((r).xlport_wc_ucmem_ctrl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access XLPORT_WC_UCMEM_CTRL.
 */
#define READ_XLPORT_WC_UCMEM_CTRLr(pa,p,r) bcmpmac_read(pa,p,XLPORT_WC_UCMEM_CTRLr_OFFSET,0,XLPORT_WC_UCMEM_CTRLr_SIZE,(r._xlport_wc_ucmem_ctrl))
#define WRITE_XLPORT_WC_UCMEM_CTRLr(pa,p,r) bcmpmac_write(pa,p,XLPORT_WC_UCMEM_CTRLr_OFFSET,0,XLPORT_WC_UCMEM_CTRLr_SIZE,&(r._xlport_wc_ucmem_ctrl))

/*******************************************************************************
 * End of 'XLPORT_WC_UCMEM_CTRLr'
 */




/*******************************************************************************
 * MEMORY:  XLPORT_WC_UCMEM_DATA
 * BLOCKS:   XLPORT
 * SIZE:     128
 */
#define XLPORT_WC_UCMEM_DATAm_OFFSET 0x20000000

#define XLPORT_WC_UCMEM_DATAm_MIN 0
#define XLPORT_WC_UCMEM_DATAm_MAX 2047
#define XLPORT_WC_UCMEM_DATAm_CMAX(u) 2047
#define XLPORT_WC_UCMEM_DATAm_SIZE 16

/*
 * This structure should be used to declare and program XLPORT_WC_UCMEM_DATA.
 */
typedef union XLPORT_WC_UCMEM_DATAm_s {
	uint32_t v[4];
	uint32_t xlport_wc_ucmem_data[4];
	uint32_t _xlport_wc_ucmem_data;
} XLPORT_WC_UCMEM_DATAm_t;

#define XLPORT_WC_UCMEM_DATAm_CLR(r) sal_memset(&((r)._xlport_wc_ucmem_data), 0, sizeof(XLPORT_WC_UCMEM_DATAm_t))
#define XLPORT_WC_UCMEM_DATAm_SET(r,i,d) (r).xlport_wc_ucmem_data[i] = d
#define XLPORT_WC_UCMEM_DATAm_GET(r,i) (r).xlport_wc_ucmem_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_WC_UCMEM_DATAm_UC_DATAf_GET(r,a) bcmpmac_field_get((r).xlport_wc_ucmem_data,0,127,a)
#define XLPORT_WC_UCMEM_DATAm_UC_DATAf_SET(r,a) bcmpmac_field_set((r).xlport_wc_ucmem_data,0,127,a)

/*
 * These macros can be used to access XLPORT_WC_UCMEM_DATA.
 */
#define READ_XLPORT_WC_UCMEM_DATAm(pa,p,i,m) bcmpmac_read(pa,p,XLPORT_WC_UCMEM_DATAm_OFFSET,i,XLPORT_WC_UCMEM_DATAm_SIZE,(m._xlport_wc_ucmem_data))
#define WRITE_XLPORT_WC_UCMEM_DATAm(pa,p,i,m) bcmpmac_write(pa,p,XLPORT_WC_UCMEM_DATAm_OFFSET,i,XLPORT_WC_UCMEM_DATAm_SIZE,&(m._xlport_wc_ucmem_data))

/*******************************************************************************
 * End of 'XLPORT_WC_UCMEM_DATAm'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_XGXS0_CTRL_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_XGXS0_CTRL_REGr_OFFSET 0x00021400

#define XLPORT_XGXS0_CTRL_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_XGXS0_CTRL_REG.
 */
typedef union XLPORT_XGXS0_CTRL_REGr_s {
	uint32_t v[1];
	uint32_t xlport_xgxs0_ctrl_reg[1];
	uint32_t _xlport_xgxs0_ctrl_reg;
} XLPORT_XGXS0_CTRL_REGr_t;

#define XLPORT_XGXS0_CTRL_REGr_CLR(r) (r).xlport_xgxs0_ctrl_reg[0] = 0
#define XLPORT_XGXS0_CTRL_REGr_SET(r,d) (r).xlport_xgxs0_ctrl_reg[0] = d
#define XLPORT_XGXS0_CTRL_REGr_GET(r) (r).xlport_xgxs0_ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_XGXS0_CTRL_REGr_RSTB_HWf_GET(r) (((r).xlport_xgxs0_ctrl_reg[0]) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_RSTB_HWf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 1) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_REFOUT_ENf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_XGXS0_CTRL_REGr_REFIN_ENf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 2) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_REFIN_ENf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define XLPORT_XGXS0_CTRL_REGr_PWRDWNf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 3) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_PWRDWNf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define XLPORT_XGXS0_CTRL_REGr_IDDQf_GET(r) ((((r).xlport_xgxs0_ctrl_reg[0]) >> 4) & 0x1)
#define XLPORT_XGXS0_CTRL_REGr_IDDQf_SET(r,f) (r).xlport_xgxs0_ctrl_reg[0]=(((r).xlport_xgxs0_ctrl_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access XLPORT_XGXS0_CTRL_REG.
 */
#define READ_XLPORT_XGXS0_CTRL_REGr(pa,p,r) bcmpmac_read(pa,p,XLPORT_XGXS0_CTRL_REGr_OFFSET,0,XLPORT_XGXS0_CTRL_REGr_SIZE,(r._xlport_xgxs0_ctrl_reg))
#define WRITE_XLPORT_XGXS0_CTRL_REGr(pa,p,r) bcmpmac_write(pa,p,XLPORT_XGXS0_CTRL_REGr_OFFSET,0,XLPORT_XGXS0_CTRL_REGr_SIZE,&(r._xlport_xgxs0_ctrl_reg))

/*******************************************************************************
 * End of 'XLPORT_XGXS0_CTRL_REGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_XGXS0_LN0_STATUS0_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_XGXS0_LN0_STATUS0_REGr_OFFSET 0x00021500

#define XLPORT_XGXS0_LN0_STATUS0_REGr_SIZE 4

/* XLPORT_XGXS0_LN0_STATUS0_REGr is element of XLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  XLPORT_XGXS0_LN1_STATUS0_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_XGXS0_LN1_STATUS0_REGr_OFFSET 0x00021600

#define XLPORT_XGXS0_LN1_STATUS0_REGr_SIZE 4

/* XLPORT_XGXS0_LN1_STATUS0_REGr is element of XLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  XLPORT_XGXS0_LN2_STATUS0_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_XGXS0_LN2_STATUS0_REGr_OFFSET 0x00021700

#define XLPORT_XGXS0_LN2_STATUS0_REGr_SIZE 4

/* XLPORT_XGXS0_LN2_STATUS0_REGr is element of XLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  XLPORT_XGXS0_LN3_STATUS0_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_XGXS0_LN3_STATUS0_REGr_OFFSET 0x00021800

#define XLPORT_XGXS0_LN3_STATUS0_REGr_SIZE 4

/* XLPORT_XGXS0_LN3_STATUS0_REGr is element of XLPORT_XGXS0_STATUS0_REG */

/*******************************************************************************
 * REGISTER:  XLPORT_XGXS0_STATUS0_REG
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_XGXS0_STATUS0_REGr_OFFSET 0x00021500

#define XLPORT_XGXS0_STATUS0_REGr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_XGXS0_STATUS0_REG.
 */
typedef union XLPORT_XGXS0_STATUS0_REGr_s {
	uint32_t v[1];
	uint32_t xlport_xgxs0_status0_reg[1];
	uint32_t _xlport_xgxs0_status0_reg;
} XLPORT_XGXS0_STATUS0_REGr_t;

#define XLPORT_XGXS0_STATUS0_REGr_CLR(r) (r).xlport_xgxs0_status0_reg[0] = 0
#define XLPORT_XGXS0_STATUS0_REGr_SET(r,d) (r).xlport_xgxs0_status0_reg[0] = d
#define XLPORT_XGXS0_STATUS0_REGr_GET(r) (r).xlport_xgxs0_status0_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_XGXS0_STATUS0_REGr_LINK_STATUSf_GET(r) (((r).xlport_xgxs0_status0_reg[0]) & 0x1)
#define XLPORT_XGXS0_STATUS0_REGr_LINK_STATUSf_SET(r,f) (r).xlport_xgxs0_status0_reg[0]=(((r).xlport_xgxs0_status0_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define XLPORT_XGXS0_STATUS0_REGr_SIG_DETf_GET(r) ((((r).xlport_xgxs0_status0_reg[0]) >> 1) & 0x1)
#define XLPORT_XGXS0_STATUS0_REGr_SIG_DETf_SET(r,f) (r).xlport_xgxs0_status0_reg[0]=(((r).xlport_xgxs0_status0_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define XLPORT_XGXS0_STATUS0_REGr_PMD_LOCKf_GET(r) ((((r).xlport_xgxs0_status0_reg[0]) >> 2) & 0x1)
#define XLPORT_XGXS0_STATUS0_REGr_PMD_LOCKf_SET(r,f) (r).xlport_xgxs0_status0_reg[0]=(((r).xlport_xgxs0_status0_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access XLPORT_XGXS0_STATUS0_REG.
 */
#define READ_XLPORT_XGXS0_STATUS0_REGr(pa,p,i,r) bcmpmac_read(pa,p,XLPORT_XGXS0_STATUS0_REGr_OFFSET,i,XLPORT_XGXS0_STATUS0_REGr_SIZE,(r._xlport_xgxs0_status0_reg))
#define WRITE_XLPORT_XGXS0_STATUS0_REGr(pa,p,i,r) bcmpmac_write(pa,p,XLPORT_XGXS0_STATUS0_REGr_OFFSET,i,XLPORT_XGXS0_STATUS0_REGr_SIZE,&(r._xlport_xgxs0_status0_reg))

/*******************************************************************************
 * End of 'XLPORT_XGXS0_STATUS0_REGr'
 */




/*******************************************************************************
 * REGISTER:  XLPORT_XGXS_COUNTER_MODE
 * BLOCKS:   XLPORT
 * SIZE:     32
 */
#define XLPORT_XGXS_COUNTER_MODEr_OFFSET 0x00021100

#define XLPORT_XGXS_COUNTER_MODEr_SIZE 4

/*
 * This structure should be used to declare and program XLPORT_XGXS_COUNTER_MODE.
 */
typedef union XLPORT_XGXS_COUNTER_MODEr_s {
	uint32_t v[1];
	uint32_t xlport_xgxs_counter_mode[1];
	uint32_t _xlport_xgxs_counter_mode;
} XLPORT_XGXS_COUNTER_MODEr_t;

#define XLPORT_XGXS_COUNTER_MODEr_CLR(r) (r).xlport_xgxs_counter_mode[0] = 0
#define XLPORT_XGXS_COUNTER_MODEr_SET(r,d) (r).xlport_xgxs_counter_mode[0] = d
#define XLPORT_XGXS_COUNTER_MODEr_GET(r) (r).xlport_xgxs_counter_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define XLPORT_XGXS_COUNTER_MODEr_CNT_MODEf_GET(r) (((r).xlport_xgxs_counter_mode[0]) & 0x1)
#define XLPORT_XGXS_COUNTER_MODEr_CNT_MODEf_SET(r,f) (r).xlport_xgxs_counter_mode[0]=(((r).xlport_xgxs_counter_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XLPORT_XGXS_COUNTER_MODE.
 */
#define READ_XLPORT_XGXS_COUNTER_MODEr(pa,p,r) bcmpmac_read(pa,p,XLPORT_XGXS_COUNTER_MODEr_OFFSET,0,XLPORT_XGXS_COUNTER_MODEr_SIZE,(r._xlport_xgxs_counter_mode))
#define WRITE_XLPORT_XGXS_COUNTER_MODEr(pa,p,r) bcmpmac_write(pa,p,XLPORT_XGXS_COUNTER_MODEr_OFFSET,0,XLPORT_XGXS_COUNTER_MODEr_SIZE,&(r._xlport_xgxs_counter_mode))

/*******************************************************************************
 * End of 'XLPORT_XGXS_COUNTER_MODEr'
 */




#endif /* BCM56960_A0_XLPORT_DEFS_H */
